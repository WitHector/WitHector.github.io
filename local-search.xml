<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>d71 komeda driver</title>
    <link href="/2023/04/25/d71%20komeda_driver/"/>
    <url>/2023/04/25/d71%20komeda_driver/</url>
    
    <content type="html"><![CDATA[<h1 id="1-D71-资源概述"><a href="#1-D71-资源概述" class="headerlink" title="1 D71 资源概述"></a>1 D71 资源概述</h1><h1 id="1-1-D71-IP概览"><a href="#1-1-D71-IP概览" class="headerlink" title="1.1 D71 IP概览"></a>1.1 D71 IP概览</h1><ul><li>D71采用灵活的、模块化的架构。一个display pipieline由多个独立的components组成，每个component拥有自身特殊的功能对显示流程中的像素数据进行处理。</li><li>D71 component<ul><li>Layer<blockquote><p>pipeline的第一个阶段，其功能是为下一阶段准备像素数据。具体工作为：</p></blockquote><ul><li>从内存中获取像素数据，如果数据是AFBC(D71中使用的一种帧缓冲压缩方法)，Layer还负责对数据进行解码。</li><li>旋转源图像数据(rotate)</li><li>将YUV格式像素转换为RGB</li></ul></li><li>Scaler<blockquote><p>负责图形缩放。用法极其灵活</p></blockquote><ul><li>连接至Layer的输出用作Layer的缩放</li><li>连接至Compositor对整个显示帧进行缩放，同时也可以通过wb_layer将缩放后的显示帧写回内存</li></ul></li><li>Compositor<blockquote><p>将多个Layer或者像素数据流混合为一个显示帧</p></blockquote><ul><li>输出帧可以接至improc用于显示</li><li>输出帧可以接至wb_layer写回内存</li><li>用户可以在Compositor和wb_layer之间加入一个Scaler对显示帧进行缩放之后在写回memory</li></ul></li><li>Writeback Layer(wb_layer)<blockquote><p>连接至Compositor，将Compositor的处理结果写回memory</p></blockquote></li><li>Post Image Processor(improc)<blockquote><p>调整帧数据，比如gamma值和像素的color space等，使像素格式匹配显示器</p></blockquote></li><li>Timing controller(timing_ctrlr)<blockquote><p>display pipeline的最后阶段，用于控制显示时序</p></blockquote></li><li>Merger<blockquote><p>D71的scaler只有Layer一半的输入输出能力，比如Layer支持4k，scaler就只支持2k。为了实现全帧显示，D71引入了<strong>Layer Split</strong>，将一副画面分割成两份，分别使用两个Layer，然后针对两个Layer独立使用Scaler进行缩放，最后通过Merger将两个缩放完成后的画面融合成一幅画面，然后将结果输出至compositor。</p></blockquote></li><li>Splitter<blockquote><p>与Layer Split功能相似，当时此component针对的是writeback，将compositor的输出结果分割成两幅画面，再独立缩放后写回内存</p></blockquote></li></ul></li></ul><h1 id="1-2-possible-D71-Pipeline-usage"><a href="#1-2-possible-D71-Pipeline-usage" class="headerlink" title="1.2 possible D71 Pipeline usage"></a>1.2 possible D71 Pipeline usage</h1><ul><li>D71拥有两个display pipeline，因此支持两种工作模式：<ul><li>双显模式<blockquote><p>两个pipeline独立工作，分别驱动各自的display output</p></blockquote><ul><li>单个pipeline数据流程如下图：<br><img src="/../images/d71_images/single%20pipeline%20data%20flow.png" alt="single pipeline data flow"></li></ul></li><li>单显模式<blockquote><p>两个pipeline同时工作，驱动同一个display output。此种模式下，可以将pipeline_B视为pipeline_A的从设备：pipeline_B将自身compositor的结果输出至pipeline_A，并且其pixel timing也从pipeline_A的timing ctrlr中获得。</p></blockquote><ul><li>单显模式下的数据流程如下图：<br><img src="/../images/d71_images/slave%20pipeline.png" alt="slave pipeline"></li></ul></li></ul></li></ul><h1 id="1-3-sub-pipeline"><a href="#1-3-sub-pipeline" class="headerlink" title="1.3 sub-pipeline"></a>1.3 sub-pipeline</h1><blockquote><p>根据pixel data flow的input&#x2F;output可以一个完整的pipeline划分为几个sub-pipeline：<br>以下3个sub-pipeline与KMS中的<strong>plane&#x2F;wb_conn&#x2F;crtc</strong>一一对应</p></blockquote><ul><li><p>Layer(input) pipeline</p><ul><li><p>layer input data flow</p><p><img src="/../images/d71_images/layer%20input%20flow.png" alt="layer input data flow"></p></li><li><p>layer split pipeline</p><p><img src="/../images/d71_images/layer%20split%20pipeline.png" alt="layer split pipeline"></p></li></ul></li><li><p>Writeback(output) pipeline</p><ul><li><p>writeback(output) data flow</p><p><img src="/../images/d71_images/writeback%20data%20flow.png" alt="writeback data flow"></p></li><li><p>writeback split data flow</p><p><img src="/../images/d71_images/writeback%20split%20data%20flow.png" alt="writeback split data flow"></p></li></ul></li><li><p>Display(output) pipeline</p><p>  <img src="/../images/d71_images/display%20data%20flow.png" alt="display data flow"></p></li></ul><h1 id="1-4-komeda-资源的抽象"><a href="#1-4-komeda-资源的抽象" class="headerlink" title="1.4 komeda 资源的抽象"></a>1.4 komeda 资源的抽象</h1><blockquote><p>d71驱动侧同样采用了与硬件相似的架构，使用pipelin&#x2F;component描述硬件的特点和功能，每个的component都包含以下两部分：</p></blockquote><ul><li>数据流控制</li><li>component特征和功能<blockquote><p>下面对描述d71资源的各个数据结构进行说明：</p></blockquote></li></ul><h2 id="struct-komeda-component"><a href="#struct-komeda-component" class="headerlink" title="struct komeda_component"></a>struct komeda_component</h2><blockquote><p>驱动侧将所有的component的共性抽象出来，用komeda_component进行描述，所有的component都可以看作此结构体的子类</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct komeda_component describe the data flow capabilities for how to link a</span><br><span class="hljs-comment"> * component into the display pipeline.</span><br><span class="hljs-comment"> * all specified components are subclass of this structure.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_private_obj</span> <span class="hljs-title">obj</span>;</span>  <span class="hljs-comment">//将component视为一个provate obj</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">pipeline</span>;</span>  <span class="hljs-comment">//此component所属的pipeline</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">32</span>];  <span class="hljs-comment">//component name</span><br>u32 __iomem *reg; <span class="hljs-comment">//component基地址 由d71初始化，并且仅被d71使用</span><br>u32 id;  <span class="hljs-comment">//component id</span><br>u32 hw_id; <span class="hljs-comment">//component 硬件id 由d71初始化，并且仅被d71使用</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @max_active_inputs:</span><br><span class="hljs-comment"> * @max_active_outputs:</span><br><span class="hljs-comment">     * 同一时刻 可以使用的最大数量的inputs/outputs </span><br><span class="hljs-comment">     * 此数据与supported_inputs/outputs的数量不同，后者表示最多支持的inputs/outputs数量</span><br><span class="hljs-comment">     * 但不一定所有的inputs/outputs可以同时使用</span><br><span class="hljs-comment"> */</span><br>u8 max_active_inputs;  <br>u8 max_active_outputs;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @supported_inputs:</span><br><span class="hljs-comment"> * @supported_outputs:</span><br><span class="hljs-comment"> * bitmask of BIT(component-&gt;id) for the supported inputs/outputs,</span><br><span class="hljs-comment">     * 描述component连接至pipeline的方法</span><br><span class="hljs-comment"> */</span><br>u32 supported_inputs;<br>u32 supported_outputs;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component_funcs</span> *<span class="hljs-title">funcs</span>;</span> <span class="hljs-comment">//访问硬件的方法</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-komeda-component-output"><a href="#struct-komeda-component-output" class="headerlink" title="struct komeda_component_output"></a>struct komeda_component_output</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component_output</span> &#123;</span><br><span class="hljs-comment">/** @component: indicate which component the data comes from */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component</span> *<span class="hljs-title">component</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @output_port:</span><br><span class="hljs-comment"> * the output port of the &amp;komeda_component_output.component</span><br><span class="hljs-comment"> */</span><br>u8 output_port;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-komeda-component-state"><a href="#struct-komeda-component-state" class="headerlink" title="struct komeda_component_state"></a>struct komeda_component_state</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component_state</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_private_state</span> <span class="hljs-title">obj</span>;</span> <span class="hljs-comment">//使用drm_atomic_state跟踪此component state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component</span> *<span class="hljs-title">component</span>;</span>  <span class="hljs-comment">//backpointer to the component</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc</span> *<span class="hljs-title">crtc</span>;</span>  <span class="hljs-comment">//backpointer for user crtc</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane</span> *<span class="hljs-title">plane</span>;</span>  <span class="hljs-comment">//backpointer for user plane</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector</span> *<span class="hljs-title">wb_conn</span>;</span>  <span class="hljs-comment">//backpointer for user wb_connector</span><br><span class="hljs-type">void</span> *binding_user;<br>&#125;;<br>    u16 active_inputs;  <span class="hljs-comment">//active_inputs is bitmask of @inputs index</span><br>u16 changed_active_inputs;  <span class="hljs-comment">//bitmask of the changed @active_inputs</span><br>u16 affected_inputs;  <span class="hljs-comment">//bitmask for affected @inputs</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @inputs:</span><br><span class="hljs-comment"> * the specific inputs[i] only valid on BIT(i) has been set in</span><br><span class="hljs-comment"> * @active_inputs, if not the inputs[i] is undefined.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component_output</span> <span class="hljs-title">inputs</span>[<span class="hljs-title">KOMEDA_COMPONENT_N_INPUTS</span>];</span><br></code></pre></td></tr></table></figure><blockquote><p>关于<strong>bingding_user</strong>，前面在讲sub-pipeline的时候就提过，可以将几个sub-pipeline与kms中的plane&#x2F;wb_conn&#x2F;crtc对应起来，因此我们可以将kms中的各个组件视为d71各个component的user：</p></blockquote><ul><li>对于 <strong>Layer</strong>，user为<strong>plane</strong></li><li>对于<strong>compiz&#x2F;improc&#x2F;timing_ctrlr</strong>，user为<strong>crtc</strong></li><li>对于<strong>wb_layer</strong>，user为<strong>wb_conn</strong></li><li>对于<strong>Scaler</strong>，当它连接至<strong>Layer</strong>时，user为<strong>plane</strong>，当它连接至<strong>compiz</strong>时，user为<strong>wb_conn</strong></li></ul><h2 id="struct-komeda-pipeline"><a href="#struct-komeda-pipeline" class="headerlink" title="struct komeda_pipeline"></a>struct komeda_pipeline</h2><blockquote><p>Represent a complete display pipeline and hold all functional components.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_private_obj</span> <span class="hljs-title">obj</span>;</span>  <span class="hljs-comment">//link pipeline as private obj of drm_atomic_state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev</span> *<span class="hljs-title">mdev</span>;</span>  <span class="hljs-comment">//the parent komeda_dev</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk</span> *<span class="hljs-title">pxlclk</span>;</span>  <span class="hljs-comment">//pixel clock</span><br><span class="hljs-type">int</span> id;  <span class="hljs-comment">//pipeline id </span><br>u32 avail_comps;  <span class="hljs-comment">//available components mask of pipeline</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @standalone_disabled_comps:</span><br><span class="hljs-comment"> * When disable the pipeline, some components can not be disabled</span><br><span class="hljs-comment"> * together with others, but need a sparated and standalone disable.</span><br><span class="hljs-comment"> * The standalone_disabled_comps are the components which need to be</span><br><span class="hljs-comment"> * disabled standalone, and this concept also introduce concept of</span><br><span class="hljs-comment"> * two phase.</span><br><span class="hljs-comment"> * phase 1: for disabling the common components.</span><br><span class="hljs-comment"> * phase 2: for disabling the standalong_disabled_comps.</span><br><span class="hljs-comment"> */</span><br>u32 standalone_disabled_comps;<br><span class="hljs-type">int</span> n_layers;  <span class="hljs-comment">//the number of layer on @layers</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_layer</span> *<span class="hljs-title">layers</span>[<span class="hljs-title">KOMEDA_PIPELINE_MAX_LAYERS</span>];</span>  <span class="hljs-comment">//the pipeline layers</span><br><span class="hljs-type">int</span> n_scalers;  <span class="hljs-comment">//the number of scaler on @scalers</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_scaler</span> *<span class="hljs-title">scalers</span>[<span class="hljs-title">KOMEDA_PIPELINE_MAX_SCALERS</span>];</span>  <span class="hljs-comment">//the pipeline scalers</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_compiz</span> *<span class="hljs-title">compiz</span>;</span>  <span class="hljs-comment">//compositor</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_splitter</span> *<span class="hljs-title">splitter</span>;</span>  <span class="hljs-comment">//for split the compiz output to two half data flows</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_merger</span> *<span class="hljs-title">merger</span>;</span>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_layer</span>  *<span class="hljs-title">wb_layer</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_improc</span> *<span class="hljs-title">improc</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_timing_ctrlr</span> *<span class="hljs-title">ctrlr</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline_funcs</span> *<span class="hljs-title">funcs</span>;</span>  <span class="hljs-comment">//chip private pipeline functions</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">of_node</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">of_output_port</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">of_output_links</span>[2];</span>  <span class="hljs-comment">//output connector device nodes</span><br><span class="hljs-type">bool</span> dual_link;  <span class="hljs-comment">//true if of_output_links[0] and [1] are both valid</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-komeda-pipeline-state"><a href="#struct-komeda-pipeline-state" class="headerlink" title="struct komeda_pipeline_state"></a>struct komeda_pipeline_state</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline_state</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_private_state</span> <span class="hljs-title">obj</span>;</span>  <span class="hljs-comment">//tracking pipeline_state by drm_atomic_state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">//backpointer to the pipeline</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc</span> *<span class="hljs-title">crtc</span>;</span>  <span class="hljs-comment">//当前绑定的crtc</span><br>u32 active_comps;  <span class="hljs-comment">//bitmask - BIT(component-&gt;id) of active components</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1-5-d71资源获取与初始化"><a href="#1-5-d71资源获取与初始化" class="headerlink" title="1.5 d71资源获取与初始化"></a>1.5 d71资源获取与初始化</h1><blockquote><p>由于Komeda不仅仅只作d71的驱动，还要兼容后续设备，因此将komeda device划分为了两层：</p></blockquote><ul><li>CORE：共有的特点和功能</li><li>CHIP：寄存器操作和硬件特点</li><li>CORE可以通过三个函数集访问CHIP<ul><li>struct komeda_dev_funcs</li><li>struct komeda_pipeline_funcs</li><li>struct komeda_component_funcs</li></ul></li><li>而关于设备资源的获取和初始化，集中在komeda_dev_funcs中</li></ul><h2 id="struct-komeda-dev-funcs"><a href="#struct-komeda-dev-funcs" class="headerlink" title="struct komeda_dev_funcs"></a>struct komeda_dev_funcs</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev_funcs</span> &#123;</span><br><span class="hljs-type">void</span> (*init_format_table)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//初始化komeda_dev-&gt;format_table，此函数需要在enum_resource前调用</span><br><span class="hljs-type">int</span> (*enum_resources)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//向core中添加pipeline或者component资源</span><br><span class="hljs-type">void</span> (*cleanup)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//clean komeda_dev-&gt;chip data</span><br><span class="hljs-type">int</span> (*connect_iommu)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//Optional, connect to external iommu</span><br><span class="hljs-type">int</span> (*disconnect_iommu)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//Optional, disconnect to external iommu</span><br><span class="hljs-type">irqreturn_t</span> (*irq_handler)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-keyword">struct</span> komeda_events *events);  <span class="hljs-comment">//中断处理</span><br><span class="hljs-type">int</span> (*enable_irq)(<span class="hljs-keyword">struct</span> komeda_dev *mdev); <br><span class="hljs-type">int</span> (*disable_irq)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);<br><span class="hljs-type">void</span> (*on_off_vblank)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-type">int</span> master_pipe, <span class="hljs-type">bool</span> on);  <span class="hljs-comment">//告知硬件开/关vblank</span><br><span class="hljs-type">void</span> (*dump_register)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-keyword">struct</span> seq_file *seq);<br><span class="hljs-type">int</span> (*change_opmode)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-type">int</span> new_mode);  <span class="hljs-comment">//Notify HW to switch to a new display operation mode</span><br><span class="hljs-type">void</span> (*flush)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-type">int</span> master_pipe, u32 active_pipes);  <span class="hljs-comment">//Notify the HW to flush or kickoff the update</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>此函数集由chip .data引入（xxx_identify）</p></blockquote><h2 id="struct-komeda-dev"><a href="#struct-komeda-dev" class="headerlink" title="struct komeda_dev"></a>struct komeda_dev</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br>u32 __iomem   *reg_base;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_dma_parameters</span> <span class="hljs-title">dma_parms</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_chip_info</span> <span class="hljs-title">chip</span>;</span>  <span class="hljs-comment">//描述chip的特性</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps_table</span> <span class="hljs-title">fmt_tbl</span>;</span>  <span class="hljs-comment">//initialized by &amp;komeda_dev_funcs-&gt;init_format_table</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk</span> *<span class="hljs-title">aclk</span>;</span>  <br><span class="hljs-type">int</span> irq;  <span class="hljs-comment">//中断号</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">lock</span>;</span><br>u32 dpmode;  <span class="hljs-comment">//当前显示模式</span><br><span class="hljs-type">int</span> n_pipelines;  <span class="hljs-comment">//the number of pipe in @pipelines</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">pipelines</span>[<span class="hljs-title">KOMEDA_MAX_PIPELINES</span>];</span>  <span class="hljs-comment">//the komeda pipelines</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev_funcs</span> *<span class="hljs-title">funcs</span>;</span>  <span class="hljs-comment">//chip funcs to access to HW</span><br><span class="hljs-type">void</span> *chip_data;  <span class="hljs-comment">//chip data will be added by &amp;komeda_dev_funcs.enum_resources() and destroyed by &amp;komeda_dev_funcs.cleanup()</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iommu_domain</span> *<span class="hljs-title">iommu</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">debugfs_root</span>;</span>  <span class="hljs-comment">//root directory of komeda debugfs</span><br>u16 err_verbosity;<br><span class="hljs-comment">/* Print a single line per error per frame with error events. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_ERR_EVENTS BIT(0)</span><br><span class="hljs-comment">/* Print a single line per warning per frame with error events. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_WARN_EVENTS BIT(1)</span><br><span class="hljs-comment">/* Print a single line per info event per frame with error events. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_INFO_EVENTS BIT(2)</span><br><span class="hljs-comment">/* Dump DRM state on an error or warning event. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_DUMP_STATE_ON_EVENT BIT(8)</span><br><span class="hljs-comment">/* Disable rate limiting of event prints (normally one per commit) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_DISABLE_RATELIMIT BIT(12)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_fbdev</span> *<span class="hljs-title">fbdev</span>[2];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_display_thread</span> <span class="hljs-title">display_thread</span>[<span class="hljs-title">KOMEDA_MAX_PIPELINES</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1-6-格式处理"><a href="#1-6-格式处理" class="headerlink" title="1.6 格式处理"></a>1.6 格式处理</h1><h2 id="struct-komeda-fomat-caps"><a href="#struct-komeda-fomat-caps" class="headerlink" title="struct komeda_fomat_caps"></a>struct komeda_fomat_caps</h2><blockquote><p>komeda_format_caps is for describing ARM display specific features and limitations for a specific format, and format_caps will be linked into <strong>&amp;komeda_framebuffer</strong> like a extension of &amp;drm_format_info.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps</span> &#123;</span><br>u32 hw_id;<br>u32 fourcc;<br>u32 supported_layer_types;  <span class="hljs-comment">//支持此格式的layer</span><br>u32 supported_rots;         <span class="hljs-comment">//此格式允许的旋转方式</span><br>u32 supported_afbc_layouts;  <br>u64 supported_afbc_features;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-komeda-format-caps-table"><a href="#struct-komeda-format-caps-table" class="headerlink" title="struct komeda_format_caps_table"></a>struct komeda_format_caps_table</h2><blockquote><p>用于管理komeda_format_caps</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps_table</span> &#123;</span><br>u32 n_formats;       <span class="hljs-comment">//size of @format_caps</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps</span> *<span class="hljs-title">format_caps</span>;</span>    <span class="hljs-comment">//array of format_caps list</span><br><span class="hljs-type">bool</span> (*format_mod_supported)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> komeda_format_caps *caps,<br>     u32 layer_type, u64 modifier, u32 rot);  <span class="hljs-comment">//某些硬件可能不能抽象为format_caps 使用此函数对硬件提供支持</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-Komeda-fb"><a href="#struct-Komeda-fb" class="headerlink" title="struct Komeda_fb"></a>struct Komeda_fb</h2><blockquote><p>根据komeda属性扩展drm_framebuffer</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_fb</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_framebuffer</span> <span class="hljs-title">base</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps</span> *<span class="hljs-title">format_caps</span>;</span>  <span class="hljs-comment">//根据komeda的format_caps扩展drm_format_info</span><br><span class="hljs-type">bool</span> is_va;   <span class="hljs-comment">//smmu status</span><br>u32 aligned_w;  <span class="hljs-comment">//aligned frame buffer width</span><br>u32 aligned_h;  <span class="hljs-comment">//aligned frame buffer height</span><br>u32 afbc_size;  <span class="hljs-comment">//minimum size of afbc</span><br>u32 offset_payload;  <span class="hljs-comment">//afbc payload 的起始位置</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1-7-attach-komeda-dev-and-DRM-KMS"><a href="#1-7-attach-komeda-dev-and-DRM-KMS" class="headerlink" title="1.7 attach komeda_dev and DRM-KMS"></a>1.7 attach komeda_dev and DRM-KMS</h1><ul><li>komeda将所有的资源抽象为pipeline或者components，DRM-KMS使用的抽象资源为crtc&#x2F;plane&#x2F;connector。一个KMS obj不能由一个单独的component表示，比如设置gamma、mode等操作，在DRM中都由crtc来完成，但是在komeda中需要compiz、improc和timing_ctrlr共同完成。</li><li>因此，将第三章中的三种sub_pipeline分别抽象为plan&#x2F;wb_connector&#x2F;crtc<ul><li>Layer(input) pipeline ———– plane</li><li>Writeback(output) pipeline —— wb_connector</li><li>Display(output) pipeline ——– crtc<blockquote><p>将每个KMS obj都视为pipeline&#x2F;component的user（对应第4章中komeda_component_state的binding_user成员），每个pipeline&#x2F;component同一时刻只能被一个KMS obj使用，每个pipeline&#x2F;component都作为drm_private_obj，其状态都由drm_atomic_state管理。</p></blockquote></li></ul></li></ul><h1 id="1-8-关于komeda-kms的抽象"><a href="#1-8-关于komeda-kms的抽象" class="headerlink" title="1.8 关于komeda_kms的抽象"></a>1.8 关于komeda_kms的抽象</h1><h2 id="struct-komeda-kms-dev"><a href="#struct-komeda-kms-dev" class="headerlink" title="struct komeda_kms_dev"></a>struct komeda_kms_dev</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_kms_dev</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_device</span> <span class="hljs-title">base</span>;</span><br><span class="hljs-type">int</span> n_crtcs;  <span class="hljs-comment">//有效的crtc数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_crtc</span> <span class="hljs-title">crtcs</span>[<span class="hljs-title">KOMEDA_MAX_PIPELINES</span>];</span>  <span class="hljs-comment">//crtc list</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-komeda-plane"><a href="#struct-komeda-plane" class="headerlink" title="struct komeda_plane"></a>struct komeda_plane</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_plane</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane</span> <span class="hljs-title">base</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_layer</span> *<span class="hljs-title">layer</span>;</span>  <span class="hljs-comment">//输入对应pipeline的有效layer</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-komeda-plane-state"><a href="#struct-komeda-plane-state" class="headerlink" title="struct komeda_plane_state"></a>struct komeda_plane_state</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_plane_state</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane_state</span> <span class="hljs-title">base</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">zlist_node</span>;</span>  <span class="hljs-comment">//z向的层面顺序链表</span><br>u8 layer_split : <span class="hljs-number">1</span>;  <span class="hljs-comment">//layer_split的开关</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-komeda-wb-connector"><a href="#struct-komeda-wb-connector" class="headerlink" title="struct komeda_wb_connector"></a>struct komeda_wb_connector</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_wb_connector</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_writeback_connector</span> <span class="hljs-title">base</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_layer</span> *<span class="hljs-title">wb_layer</span>;</span>  <span class="hljs-comment">//represents associated writeback pipeline of komeda</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-komeda-crtc"><a href="#struct-komeda-crtc" class="headerlink" title="struct komeda_crtc"></a>struct komeda_crtc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_crtc</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc</span> <span class="hljs-title">base</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">master</span>;</span>  <span class="hljs-comment">//only master has display output (对应的单显/双显模式中的display output pipeline)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">slave</span>;</span>  <span class="hljs-comment">//optional,Doesn&#x27;t have its own display output, the handled data flow will merge into the master.</span><br><span class="hljs-type">bool</span> side_by_side;<br>u32 sbs_overlap;<br>u32 slave_planes;  <span class="hljs-comment">//komeda slave planes mask</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_wb_connector</span> *<span class="hljs-title">wb_conn</span>;</span>  <span class="hljs-comment">//komeda write back connector</span><br><br><span class="hljs-comment">/* this flip_done is for trace the disable */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> *<span class="hljs-title">disable_done</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">slave_planes_property</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">clock_ratio_property</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">side_by_side_property</span>;</span><br><span class="hljs-comment">/* assertive display properties */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">assertiveness_property</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">strength_limit_property</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">drc_property</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">hdr_data_property</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">coproc_property</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">vrr_property</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">vrr_enable_property</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_commit</span> *<span class="hljs-title">commit</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="struct-komeda-crtc-state"><a href="#struct-komeda-crtc-state" class="headerlink" title="struct komeda_crtc_state"></a>struct komeda_crtc_state</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_crtc_state</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_state</span> <span class="hljs-title">base</span>;</span><br>u32 affected_pipes;  <span class="hljs-comment">//the affected pipelines in once display instance</span><br>u32 active_pipes;  <span class="hljs-comment">//the active pipelines in once display instance</span><br>u64 clock_ratio;  <span class="hljs-comment">//ratio of (aclk &lt;&lt; 32)/pxlclk</span><br>u32 max_slave_zorder;  <span class="hljs-comment">//the maximum of slave zorder</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="komeda-crtc-atomic-check"><a href="#komeda-crtc-atomic-check" class="headerlink" title="komeda_crtc_atomic_check"></a>komeda_crtc_atomic_check</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">komeda_crtc_atomic_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc, <span class="hljs-keyword">struct</span> drm_atomic_state *state)</span><br><span class="hljs-comment">/***</span><br><span class="hljs-comment">@crtc: drm crtc</span><br><span class="hljs-comment">@state: crtc state obj</span><br><span class="hljs-comment">@description: crtc_atomic_check is the final check stage, so beside build a display data pipeline according to the crtc_state, but still needs to release or disable the unclaimed pipeline resources.</span><br><span class="hljs-comment">***/</span><br></code></pre></td></tr></table></figure><h2 id="komeda-plane-atomic-check"><a href="#komeda-plane-atomic-check" class="headerlink" title="komeda_plane_atomic_check"></a>komeda_plane_atomic_check</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">komeda_plane_atomic_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_plane *plane, <span class="hljs-keyword">struct</span> drm_atomic_state *state)</span><br><span class="hljs-comment">/***</span><br><span class="hljs-comment">@plane: drm plane</span><br><span class="hljs-comment">@state: plane state obj</span><br><span class="hljs-comment">***/</span><br></code></pre></td></tr></table></figure><h1 id="2-komeda-drv-based-on-component-framework"><a href="#2-komeda-drv-based-on-component-framework" class="headerlink" title="2 komeda_drv based on component framework"></a>2 komeda_drv based on component framework</h1><ul><li>通过component framework对整个display subsystem进行管理，d71作为master device对其余的component device（比如dsi、dp）进行管控。本章主要对d71作为master device在component framework中的注册流程进行梳理和分析。</li></ul><h2 id="2-1-component-framework-简介"><a href="#2-1-component-framework-简介" class="headerlink" title="2.1 component framework 简介"></a>2.1 component framework 简介</h2><blockquote><p>主要作用：用来处理内核模块加载&#x2F;卸载顺序，保证最后加载的模块在需要先加载的模块都加载后加载。<br>component framework包含两种设备：master和component。master是超级设备，通过设备树管控多个component加载&#x2F;卸载顺序，保证所有组件正常加载&#x2F;卸载。<br>component framework通过两个链表来维持整个框架中所有的master&#x2F;component device</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">LIST_HEAD</span><span class="hljs-params">(component_list)</span>;   <span class="hljs-comment">//整个component框架中所有的components 可能不属于同一个master device</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">LIST_HEAD</span><span class="hljs-params">(masters)</span>;          <span class="hljs-comment">//所有的master device，每个master device通过一个链表维护下属的components</span><br></code></pre></td></tr></table></figure><ul><li><p>master device</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">master</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span>    <span class="hljs-comment">//下属的components </span><br><span class="hljs-type">bool</span> bound;               <span class="hljs-comment">//绑定状态</span><br><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_master_ops</span> *<span class="hljs-title">ops</span>;</span> <span class="hljs-comment">//回调函数 .attach .bind .unbind</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_match</span> *<span class="hljs-title">match</span>;</span>  <span class="hljs-comment">//master device 通过这个结构体匹配正确的components</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">dentry</span>;</span><br> &#125;;<br></code></pre></td></tr></table></figure><ul><li>component match<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_match</span> &#123;</span><br><span class="hljs-type">size_t</span> alloc;           <span class="hljs-comment">//分配的内存</span><br><span class="hljs-type">size_t</span> num;             <span class="hljs-comment">//实际compare的数量  alloc与num在master未注册之前是不等的 分配的内存会比实际占用内存更大 在master注册时 会根据compare的实际数量重新分配内存</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_match_array</span> *<span class="hljs-title">compare</span>;</span>  <span class="hljs-comment">//匹配表 包含匹配数据和匹配方法 每一个compare表示一个component_device</span><br> &#125;;<br></code></pre></td></tr></table></figure><ul><li>component_match_array<blockquote><p>一般需要传入的就是.data和.compare，将master下属的component device作为data保存至此表，匹配时调用compare将待匹配的设备与此表中的data进行比较，相同即匹配成功。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_match_array</span> &#123;</span><br>  <span class="hljs-type">void</span> *data;<br>  <span class="hljs-type">int</span> (*compare)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-type">void</span> *);<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>component device</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span>  <span class="hljs-comment">//所属链表头</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">master</span> *<span class="hljs-title">master</span>;</span>  <span class="hljs-comment">//所属的master</span><br>    <span class="hljs-type">bool</span> bound;             <span class="hljs-comment">//绑定状态</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_ops</span> *<span class="hljs-title">ops</span>;</span>  <span class="hljs-comment">//回调函数 .bind .unbind</span><br>    <span class="hljs-type">int</span> subcomponent;       <span class="hljs-comment">//子设备数 一般为0</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>绑定流程</p><blockquote><p>在向componnet framework中注册master device 或者 component device时，都会执行<code>try_to_bring_up_master</code>函数，在此函数中会按照master的匹配表的顺序对各个component进行匹配，只有所有的component都已经注册进component framework，此函数才能执行成功。所有components匹配成功后，将执行<code>master-&gt;ops-&gt;bind</code>，在bind函数中执行<code>component_bind_all()</code>，在此函数中将回调所有component的.bind函数。</p></blockquote></li></ul><h2 id="2-2-设备树节点"><a href="#2-2-设备树节点" class="headerlink" title="2.2 设备树节点"></a>2.2 设备树节点</h2><ul><li>komeda d71作为display_subsystem的master device，其设备树节点如下：  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">mdp_ss_dpu0:</span> <span class="hljs-title class_">dpu@e6c80000</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;arm,mali-d71&quot;</span>, <span class="hljs-string">&quot;syscon&quot;</span><span class="hljs-punctuation">;</span><br>        ...<br><span class="hljs-symbol">        dp0_pipe0:</span> <span class="hljs-title class_">pipeline@0</span> <span class="hljs-punctuation">&#123;</span><br>            ...<br>            <span class="hljs-title class_">ports</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>                <span class="hljs-meta">#size-cells = &lt;0&gt;;</span><br>                <span class="hljs-title class_">port@0</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">                    dp0_pipe0_out:</span> <span class="hljs-title class_">endpoint</span> <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">remote-endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;dsi_in</span>&gt;</span><span class="hljs-punctuation">;</span><br>                    <span class="hljs-punctuation">&#125;;</span><br>                <span class="hljs-punctuation">&#125;;</span><br>            <span class="hljs-punctuation">&#125;;</span><br>        <span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li><li>驱动源码文件为<code>komeda_drv.c</code></li></ul><h2 id="2-3-probe函数"><a href="#2-3-probe函数" class="headerlink" title="2.3 probe函数"></a>2.3 probe函数</h2><ul><li>其<code>probe</code>函数主要作用为将其作为master设备注册进component框架，主要分为以下三步：<ol><li><p>通过设备树获取属于master的component设备节点，并将其保存至所属的component链表中。</p><ul><li>通过设备树中的<code>remote-endpoint</code>节点找到其下属的component device:<ul><li>首先获取endpoint节点：<code>of_graph_get_endpoint_by_regs(node, port, endpoint)</code></li><li>找到endpoint下属的remote节点，并通过remote节点找到component设备<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">   np = of_graph_get_remote_endpoint(node);  <br>pp = of_graph_get_port_parent(np);  <span class="hljs-comment">//此np即为remote节点</span><br><span class="hljs-keyword">return</span> pp;<br></code></pre></td></tr></table></figure></li><li>关于pp节点的获取，存在一点疑问：<ul><li><code>of_graph_get_port_parent</code>源码为：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-keyword">for</span> (depth = <span class="hljs-number">3</span>; depth &amp;&amp; node; depth--) &#123;  <span class="hljs-comment">//求三级父节点</span><br>       node = of_get_next_parent(node);<br>       <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">2</span> &amp;&amp; !of_node_name_eq(node, <span class="hljs-string">&quot;ports&quot;</span>))  <span class="hljs-comment">//结合设备树来看，实际上获得的是ports节点</span><br>           <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> node;<br></code></pre></td></tr></table></figure></li><li><code>remote</code>设备树节点为：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">mdp_ss_dsi:</span> <span class="hljs-title class_">dsi@e6d90000</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;siengine,se1000-mipi-dsi&quot;</span><span class="hljs-punctuation">;</span><br>    ...<br>    <span class="hljs-title class_">ports</span> <span class="hljs-punctuation">&#123;</span><br>        ...<br>        <span class="hljs-title class_">port@0</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">            dsi_in:</span> <span class="hljs-title class_">endpoint</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">remote-endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;dp0_pipe0_out</span>&gt;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-punctuation">&#125;;</span><br>        <span class="hljs-punctuation">&#125;;</span><br>        ...<br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li><li><strong>以源码来看，它最终获取的节点是<code>remote</code>节点的二级<code>parent</code>节点–<code>ports</code>节点，但是根据component framework的逻辑来看，最终获取的节点应该是<code>dsi</code>节点。</strong><mark><strong>此处存疑</strong></mark></li></ul></li></ul></li></ul></li><li><p>将设备树中找到的component节点保存至<mark>master-&gt;match-&gt;compare[match-&gt;num]-&gt;data</mark>，具体流程为以下四层调用：</p><blockquote><p>|- drm_of_component_match_add(master, match, compare_of, remote);</p></blockquote><blockquote><p>|— component_match_add_release(master, matchptr, drm_release_of, compare, node);</p></blockquote><blockquote><p>|—– __component_match_add(master, matchptr, release, compare, NULL, compare_data);</p></blockquote><blockquote><p>|——-最终调用：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">     <span class="hljs-comment">/*为新的compare分配内存，一旦之前为match分配的内存使用完 就再为其分配16个sizeof(compare)的内存空间*/</span><br>     <span class="hljs-keyword">if</span> (match-&gt;num == match-&gt;alloc) &#123;<br><span class="hljs-type">size_t</span> new_size = match-&gt;alloc + <span class="hljs-number">16</span>;<br>ret = component_match_realloc(master, match, new_size);<br>...<br>   &#125;<br>     <span class="hljs-comment">/*对新的compare赋值*/</span><br>     match-&gt;compare[match-&gt;num].compare = compare;  <span class="hljs-comment">//匹配函数 非常简单 判断节点是否相等即可</span><br>      ...<br>      match-&gt;compare[match-&gt;num].data = compare_data; <span class="hljs-comment">//匹配数据 被匹配函数调用 compare_data为形参，实际上最终传入的是(void *) (struct device_node *remote)，即component node</span><br>      ...<br>      match-&gt;num++;<br></code></pre></td></tr></table></figure></p></blockquote></li><li><p>注册带match表的master_device</p><ul><li>component_master_add_with_match(dev, &amp;komeda_master_ops, match);<blockquote><p>此函数将master设备注册至component framework的masters链表中，并执行<code>try_to_bring_up_master</code>函数。</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">   ...<br>   master-&gt;dev = dev;<br>master-&gt;ops = ops;  <span class="hljs-comment">//master device 回调函数  .bind/.unbind</span><br>master-&gt;match = match;<br>   list_add(&amp;master-&gt;node, &amp;masters);  <span class="hljs-comment">//将master添加至component framework维护的masters表</span><br>   ...<br>   ret = try_to_bring_up_master(master, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//尝试进行匹配和绑定</span><br></code></pre></td></tr></table></figure></blockquote></li></ul></li></ol></li></ul><h2 id="3-d71-资源初始化及attach-kms"><a href="#3-d71-资源初始化及attach-kms" class="headerlink" title="3 d71 资源初始化及attach kms"></a>3 d71 资源初始化及attach kms</h2><ul><li>本章主要讨论的是master-&gt;ops-&gt;bind()函数，其主要功能是完成对d71资源的获取和初始化，并将各个sub_pipeline与对应的kms obj进行attach</li><li>bind函数围绕着以下数据结构展开，其中两个成员分别在1.5节和1.8节中展开描述过。例化了一个komeda_drv::<mark>mdrv</mark><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_drv</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev</span> *<span class="hljs-title">mdev</span>;</span>     <span class="hljs-comment">//d71设备资源抽象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_kms_dev</span> *<span class="hljs-title">kms</span>;</span> <br> &#125;;<br></code></pre></td></tr></table></figure></li><li>整个bind函数主要由两个动作构成：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_drv</span> *<span class="hljs-title">mdrv</span>;</span><br>...<br>mdrv-&gt;mdev = komeda_dev_create(dev);  <span class="hljs-comment">//获取资源并初始化</span><br>...<br>mdrv-&gt;kms = komeda_kms_attach(mdrv-&gt;mdev);  <span class="hljs-comment">//attach mdrv-&gt;mdev and mdrv-&gt;kms</span><br>...<br></code></pre></td></tr></table></figure></li><li>下面分别对上述两个函数进行讨论</li></ul><h2 id="3-1-komeda-dev-create-dev"><a href="#3-1-komeda-dev-create-dev" class="headerlink" title="3.1 komeda_dev_create(dev)"></a>3.1 komeda_dev_create(dev)</h2><ol><li>在1.5节中提到过一个结构体<code>struct komeda_dev_funcs</code>,此函数集用于core获取chip级的资源，并访问硬件。对应的是<code>komeda_dev.funcs</code>成员。komeda驱动中定义了此函数集，并通过of_match_table的.data成员将此函数集赋值给mdrv-&gt;mdev.funcs。<ul><li><code>&#123; .compatible = &quot;arm,mali-d71&quot;, .data = d71_identify, &#125;,</code> ，其中d71_identify为一个函数指针，指向的函数内包含了funcs的赋值操作。在bind()中，此函数的调用方法为： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">komeda_identify_func komeda_identify;<br>...<br>komeda_identify = of_device_get_match_data(dev);  <span class="hljs-comment">//获取identify函数</span><br>...<br>mdev-&gt;reg_base = devm_platform_ioremap_resource(pdev, <span class="hljs-number">0</span>);<br>...<br>mdev-&gt;funcs = komeda_identify(mdev-&gt;reg_base, &amp;mdev-&gt;chip);<br>...<br></code></pre></td></tr></table></figure></li><li>d71_identify<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> komeda_dev_funcs *<span class="hljs-title function_">d71_identify</span><span class="hljs-params">(u32 __iomem *reg_base, <span class="hljs-keyword">struct</span> komeda_chip_info *chip)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev_funcs</span> *<span class="hljs-title">funcs</span>;</span><br>u32 product_id;<br>chip-&gt;core_id = malidp_read32(reg_base, GLB_CORE_ID);<br>product_id = MALIDP_CORE_ID_PRODUCT_ID(chip-&gt;core_id);<br><span class="hljs-keyword">switch</span> (product_id) &#123;<br><span class="hljs-keyword">case</span> MALIDP_D71_PRODUCT_ID:<br>...<br>funcs = &amp;d71_chip_funcs;<br><span class="hljs-keyword">break</span>;<br>...<br>&#125;<br>chip-&gt;arch_id= malidp_read32(reg_base, GLB_ARCH_ID);<br>chip-&gt;core_info= malidp_read32(reg_base, GLB_CORE_INFO);<br>chip-&gt;bus_width= D71_BUS_WIDTH_16_BYTES;<br><span class="hljs-keyword">return</span> funcs;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>由上述源码可知，d71_identify返回了chip的访问函数集<mark>d71_chip_funcs</mark>的同时，还通过读寄存器的操作对<strong>mdrv-&gt;mdev-&gt;chip</strong>的各个数据进行了初始化。</li></ul></li><li>通过<strong>funcs-&gt;init_format_table</strong>初始化<strong>mdev-&gt;fmt_tbl</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mdev-&gt;funcs-&gt;init_format_table(mdev);  <span class="hljs-comment">//实际上调用的d71_init_fmt_tbl</span><br></code></pre></td></tr></table></figure><ul><li>这一点在1.5节中介绍komeda_dev结构体时已经说明过，此函数内部基本上就是单纯的数据结构的赋值 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">d71_init_fmt_tbl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> komeda_dev *mdev)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps_table</span> *<span class="hljs-title">table</span> =</span> &amp;mdev-&gt;fmt_tbl;<br><br>table-&gt;format_caps = d71_format_caps_table;<br>table-&gt;format_mod_supported = d71_format_mod_supported;<br>table-&gt;n_formats = ARRAY_SIZE(d71_format_caps_table);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>通过<strong>funcs-&gt;enum_resources</strong>获取d71资源列表<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">err = mdev-&gt;funcs-&gt;enum_resources(mdev);  <span class="hljs-comment">//实际上调用d71_enum_resources</span><br></code></pre></td></tr></table></figure><ul><li><p>此函数功能是对mdev-&gt;chipdata(类型为void *)成员进行初始化</p><ul><li>定义了一个d71_dev类型对chip资源进行描述，通过大量的寄存器操作对以下成员进行初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d71_dev</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev</span> *<span class="hljs-title">mdev</span>;</span><br><span class="hljs-type">int</span>num_blocks;<br><span class="hljs-type">int</span>num_pipelines;<br><span class="hljs-type">int</span>num_rich_layers;<br>u32max_line_size;<br>u32max_vsize;<br>u32supports_dual_link : <span class="hljs-number">1</span>;<br>u32integrates_tbu : <span class="hljs-number">1</span>;<br>u32 __iomem*gcu_addr;    <span class="hljs-comment">//mdev-&gt;reg_base</span><br>u32 __iomem*glb_scl_coeff_addr[D71_MAX_GLB_SCL_COEFF];<br>u32 __iomem*periph_addr;  <span class="hljs-comment">//mdev-&gt;reg_base + (D71_BLOCK_OFFSET_PERIPH &gt;&gt; 2);</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d71_pipeline</span> *<span class="hljs-title">pipes</span>[<span class="hljs-title">D71_MAX_PIPELINE</span>];</span><br>&#125;;<br>...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d71_dev</span> *<span class="hljs-title">d71</span>;</span><br>...<br>mdev-&gt;chip_data = d71;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>需要关注的是此函数中对pipeline的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; d71-&gt;num_pipelines; i++) &#123;<br>pipe = komeda_pipeline_add(mdev, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> d71_pipeline),<br>   &amp;d71_pipeline_funcs);<br>...<br>d71-&gt;pipes[i] = to_d71_pipeline(pipe);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>komeda_pipeline_add()功能是根据d71-&gt;num_pipelines对mdev-&gt;pipelines[]进行初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">pipe</span>;</span><br>...<br>pipe-&gt;mdev = mdev;<br>pipe-&gt;id   = mdev-&gt;n_pipelines;<br>pipe-&gt;funcs = funcs;  <span class="hljs-comment">//pipe的操作函数集</span><br>mdev-&gt;pipelines[mdev-&gt;n_pipelines] = pipe;<br>...<br></code></pre></td></tr></table></figure></li><li>to_d71_pipeline()是一个container宏，实际上是已komeda_pipeline为base，扩展称为一个d71_pipeline类型，返回指针并存入d71-&gt;pipes[]表中。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> to_d71_pipeline(x)container_of(x, struct d71_pipeline, base)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>通过<code>komeda_assemble_pipelines(mdev)</code>对pipe下的component进行获取，并验证pipeline各个component之间的连接<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mdev-&gt;n_pipelines; i++) &#123;<br>pipe = mdev-&gt;pipelines[i];<br>komeda_pipeline_assemble(pipe);<br>komeda_pipeline_dump(pipe);    <span class="hljs-comment">//这函数好像没啥用 最后就输出一堆log</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>komeda_pipeline_assemble(pipe)</code>工作主要由此函数完成<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> avail_comps = pipe-&gt;avail_comps;<br>for_each_set_bit(id, &amp;avail_comps, <span class="hljs-number">32</span>) &#123;<br>c = komeda_pipeline_get_component(pipe, id);<br>komeda_component_verify_inputs(c);<br>&#125;<br>...<br></code></pre></td></tr></table></figure><ul><li><strong>komeda_pipeline_get_component</strong>主要通过位操作获取当前pipe下属的component，并将其component指针返回，其调用了<code>komeda_pipeline_get_component_pos(pipe, id)</code>以compositor为例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component</span> **<span class="hljs-title">pos</span> =</span> <span class="hljs-literal">NULL</span>;<br>  ...<br>  <span class="hljs-keyword">switch</span> (id) &#123;<br>...<br><span class="hljs-keyword">case</span> KOMEDA_COMPONENT_COMPIZ0:<br><span class="hljs-keyword">case</span> KOMEDA_COMPONENT_COMPIZ1:<br>temp = mdev-&gt;pipelines[id - KOMEDA_COMPONENT_COMPIZ0];<br>pos = to_cpos(temp-&gt;compiz);  <span class="hljs-comment">//to_cops是一个宏 将&amp;(temp-&gt;compiz)转换为一个struct component **指针</span><br><span class="hljs-keyword">break</span>;<br>...<br>  &#125;<br>  ...<br>  <span class="hljs-keyword">return</span> pos;<br></code></pre></td></tr></table></figure><ul><li>komeda_pipeline_get_component在上述源码外由封装了一层 返回的是*pos，因此c是一个struct component *类型</li></ul></li><li><strong>komeda_component_verify_inputs</strong>同样通过位操作找到当前component的input方法，即在pipeline中找到可以作为它上一个stage的component_2，并将component_2的supported_outputs通过位操作与当前component的id进行关联，使pipeline连通<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"> ...<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> supported_inputs = c-&gt;supported_inputs;<br> ...<br> for_each_set_bit(id, &amp;supported_inputs, <span class="hljs-number">32</span>) &#123;<br>input = komeda_pipeline_get_component(pipe, id);<br>...<br>input-&gt;supported_outputs |= BIT(c-&gt;id);<br> &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h2 id="3-2-komeda-kms-attach-mdrv-gt-mdev"><a href="#3-2-komeda-kms-attach-mdrv-gt-mdev" class="headerlink" title="3.2 komeda_kms_attach(mdrv-&gt;mdev)"></a>3.2 komeda_kms_attach(mdrv-&gt;mdev)</h2><ul><li>此函数主要完成drm kms中的一系列操作，围绕两个例化对象展开：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_kms_dev</span> *<span class="hljs-title">kms</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_device</span> *<span class="hljs-title">drm</span>;</span><br>drm = &amp;kms-&gt;base;<br>drm-&gt;dev_private = mdev;<br></code></pre></td></tr></table></figure></li></ul><ol><li>结合drm_driver 创建drm container device — kms<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">kms = devm_drm_dev_alloc(mdev-&gt;dev, &amp;komeda_kms_driver,<br> <span class="hljs-keyword">struct</span> komeda_kms_dev, base);<br></code></pre></td></tr></table></figure><ul><li>关于<code>komeda_kms_driver</code>的定义<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_driver</span> <span class="hljs-title">komeda_kms_driver</span> =</span> &#123;<br>.driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,<br>.lastclose= komeda_lastclose,<br>DRM_GEM_CMA_DRIVER_OPS_WITH_DUMB_CREATE(komeda_gem_cma_dumb_create),<br>.fops = &amp;komeda_cma_fops,<br>.name = <span class="hljs-string">&quot;komeda&quot;</span>,<br>.desc = <span class="hljs-string">&quot;Arm Komeda Display Processor driver&quot;</span>,<br>.date = <span class="hljs-string">&quot;20181101&quot;</span>,<br>.major = <span class="hljs-number">0</span>,<br>.minor = <span class="hljs-number">1</span>,<br>.gem_free_object_unlocked       = drm_gem_cma_free_object,<br>.gem_vm_ops                     = &amp;drm_gem_cma_vm_ops,<br>.dumb_create                    = komeda_gem_cma_dumb_create,<br>.prime_handle_to_fd             = drm_gem_prime_handle_to_fd,<br>.prime_fd_to_handle             = drm_gem_prime_fd_to_handle,<br>.gem_prime_export               = drm_gem_prime_export,<br>.gem_prime_import               = drm_gem_prime_import,<br>.gem_prime_get_sg_table         = drm_gem_cma_prime_get_sg_table,<br>.gem_prime_import_sg_table      = drm_gem_cma_prime_import_sg_table,<br>.gem_prime_vmap                 = drm_gem_cma_prime_vmap,<br>.gem_prime_vunmap               = drm_gem_cma_prime_vunmap,<br>.gem_prime_mmap                 = drm_gem_cma_prime_mmap,<br>     &#125;;<br> ```  <br><span class="hljs-number">2.</span> mode_config_init drm框架中最重要的操作之一<br>   ```c<br>   <span class="hljs-title function_">komeda_kms_mode_config_init</span><span class="hljs-params">(kms, mdev)</span>;<br></code></pre></td></tr></table></figure></li><li>在此函数内对mode_config进行初始化，并创建standard property objs<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_mode_config</span> *<span class="hljs-title">config</span> =</span> &amp;kms-&gt;base.mode_config;<br>drm_mode_config_init(&amp;kms-&gt;base);  <br>komeda_kms_setup_crtcs(kms, mdev);<br><span class="hljs-comment">/* Get value from dev */</span><br>config-&gt;min_width= <span class="hljs-number">0</span>;<br>config-&gt;min_height= <span class="hljs-number">0</span>;<br>config-&gt;max_width= <span class="hljs-number">4096</span>;<br>config-&gt;max_height= <span class="hljs-number">4096</span>;<br>config-&gt;allow_fb_modifiers = <span class="hljs-literal">true</span>;<br>config-&gt;funcs = &amp;komeda_mode_config_funcs;<br>config-&gt;helper_private = &amp;komeda_mode_config_helpers;<br></code></pre></td></tr></table></figure></li><li>重点关注 <strong>komeda_kms_setup_crtcs(kms, mdev)<strong>函数，此函数主要是根据mdrv-&gt;mdev中的pipeline填充mdrv-&gt;kms-&gt;crtc[]表。其中的</strong>slave</strong>只有在<strong>单显模式</strong>下才存在，之前在1.2节中已经有描述，相关数据结构前文也已说明。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_crtc</span> *<span class="hljs-title">crtc</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">master</span>;</span><br>kms-&gt;n_crtcs = <span class="hljs-number">0</span>;<br>   ...<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mdev-&gt;n_pipelines; i++) &#123;<br> crtc = &amp;kms-&gt;crtcs[kms-&gt;n_crtcs];<br> master = mdev-&gt;pipelines[i];<br> ...<br> crtc-&gt;master = master;<br> crtc-&gt;slave  = komeda_pipeline_get_slave(master);<br> ...<br> kms-&gt;n_crtcs++;<br>&#125;<br>...<br></code></pre></td></tr></table></figure></li></ul></li><li>将各个pipeline&#x2F;component设为drm_private_obj<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">komeda_kms_add_private_objs(kms, mdev);<br></code></pre></td></tr></table></figure><ul><li>封装以下函数：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*****</span><br><span class="hljs-comment">xxx为d71组件，包括：</span><br><span class="hljs-comment">- pipeline</span><br><span class="hljs-comment">- layer</span><br><span class="hljs-comment">- wb_layer</span><br><span class="hljs-comment">- scaler</span><br><span class="hljs-comment">- compositor</span><br><span class="hljs-comment">- splitter</span><br><span class="hljs-comment">- merger</span><br><span class="hljs-comment">- improc</span><br><span class="hljs-comment">- timing_ctrlr</span><br><span class="hljs-comment">*****/</span><br>komeda_xxx_obj_add(kms, xxx);<br></code></pre></td></tr></table></figure><ul><li>各个函数最终调用：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline_state</span> *<span class="hljs-title">st</span>;</span><br>...<br>drm_atomic_private_obj_init(&amp;kms-&gt;base, &amp;xxx-&gt;obj, &amp;st-&gt;obj, &amp;komeda_xxx_obj_funcs);<br></code></pre></td></tr></table></figure><ul><li>funcs的类型为：<code>struct drm_private_state_funcs</code>，状态操作函数，包括<code>.xxx_atomic_duplicate_state</code>和<code>.xxx_atomic_destroy_state</code></li></ul></li></ul></li></ul></li><li>向KMS中添加KMS obj，创建各个obj的属性<ul><li><code>komeda_kms_add_planes(kms, mdev);</code><ul><li><code>komeda_plane_add</code><ul><li><code>drm_universal_plane_init(&amp;kms-&gt;base, plane,    get_possible_crtcs(kms, c-&gt;pipeline),    &amp;komeda_plane_funcs,    formats, n_formats, komeda_supported_modifiers,    get_plane_type(kms, c),    &quot;%s&quot;, c-&gt;name);</code>  &#x2F;&#x2F;plane初始化 xxx_plane_funcs注册</li><li><code>drm_plane_helper_add(plane, &amp;komeda_plane_helper_funcs);</code>  &#x2F;&#x2F;xxx_plane_helper_funcs注册</li><li><code>drm_plane_create_rotation_property(plane, DRM_MODE_ROTATE_0, layer-&gt;supported_rots);</code> &#x2F;&#x2F;创建属性并与obj attach</li></ul></li></ul></li><li><code>komeda_kms_add_crtcs(kms, mdev)</code><ul><li><code>komeda_crtc_add</code><ul><li><code>drm_crtc_init_with_planes(&amp;kms-&gt;base, crtc,        get_crtc_primary(kms, kcrtc), NULL,        &amp;komeda_crtc_funcs, NULL);</code>  &#x2F;&#x2F;crtc初始化 xxx_crtc_funcs注册</li><li><code>drm_crtc_helper_add(crtc, &amp;komeda_crtc_helper_funcs);</code>  &#x2F;&#x2F;xxx_crtc_helper_funcs注册</li><li><code>crtc-&gt;port = kcrtc-&gt;master-&gt;of_output_port;</code> &#x2F;&#x2F;crtc output port nede</li><li><code>komeda_crtc_create_slave_planes_property(kcrtc);</code>  &#x2F;&#x2F;创建属性并attach</li></ul></li></ul></li><li><code>komeda_kms_add_wb_connectors(kms, mdev);</code> <ul><li><code>komeda_wb_connector_add</code></li><li><code>drm_writeback_connector_init(&amp;kms-&gt;base, wb_conn,             &amp;komeda_wb_connector_funcs,             &amp;komeda_wb_encoder_helper_funcs,             formats, n_formats);</code>  &#x2F;&#x2F;创建并初始化wb_connector，同时创建一个内部encoder与之关联</li><li>drm_connector_helper_add(&amp;wb_conn-&gt;base, &amp;komeda_wb_conn_helper_funcs);</li></ul></li></ul></li><li>根据crtc初始化vblank<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_crtcs; i++) &#123;<br>...<br>init_waitqueue_head(&amp;vblank-&gt;<span class="hljs-built_in">queue</span>);<br>...<br>timer_setup(&amp;vblank-&gt;disable_timer, vblank_disable_fn, <span class="hljs-number">0</span>);<br>...<br>drmm_add_action_or_reset(dev, drm_vblank_init_release, vblank);<br>...<br>drm_vblank_worker_init(vblank);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>component_bind_all(mdev-&gt;dev, kms);</code> &#x2F;&#x2F;完成component framework的绑定 与drm无关</li><li>drm_mode_config_reset(drm);</li><li>中断申请<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">devm_request_irq(drm-&gt;dev, mdev-&gt;irq,<br>       komeda_kms_irq_handler, IRQF_SHARED,<br>       drm-&gt;driver-&gt;name, drm);  <span class="hljs-comment">//注册中断处理函数</span><br></code></pre></td></tr></table></figure><ul><li>对<code>komeda_kms_irq_handler</code>进行分析<ul><li>其中定义了<code>struct komeda_events evts;</code>用于表示d71的中断事件</li><li>调用<code>mdev-&gt;funcs-&gt;irq_handler(mdev, &amp;evts);</code>通过读取寄存器中相关中断标志位生成对应的中断事件<ul><li>实际调用<code>d71_irq_handler</code>，此函数是函数集<code>d71_chip_funcs</code>中的一员，在3.1节中有提到过</li><li>相关操作如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">gcu_status = malidp_read32(d71-&gt;gcu_addr, GLB_IRQ_STATUS);<br><br><span class="hljs-keyword">if</span> (gcu_status &amp; GLB_IRQ_STATUS_GCU) &#123;<br> raw_status = malidp_read32(d71-&gt;gcu_addr, BLK_IRQ_RAW_STATUS);<br> <span class="hljs-keyword">if</span> (raw_status &amp; GCU_IRQ_CVAL0)<br>evts-&gt;pipes[<span class="hljs-number">0</span>] |= KOMEDA_EVENT_FLIP;<br> <span class="hljs-keyword">if</span> (raw_status &amp; GCU_IRQ_CVAL1)<br>evts-&gt;pipes[<span class="hljs-number">1</span>] |= KOMEDA_EVENT_FLIP;<br> <span class="hljs-keyword">if</span> (raw_status &amp; GCU_IRQ_ERR) &#123;<br>status = malidp_read32(d71-&gt;gcu_addr, BLK_STATUS);<br><span class="hljs-keyword">if</span> (status &amp; GCU_STATUS_MERR) &#123;<br>evts-&gt;global |= KOMEDA_ERR_MERR;<br>malidp_write32_mask(d71-&gt;gcu_addr, BLK_STATUS,<br>GCU_STATUS_MERR, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br>malidp_write32(d71-&gt;gcu_addr, BLK_IRQ_CLEAR, raw_status);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>将上一级的中断事件传递给真正的处理函数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">komeda_crtc_handle_event(&amp;kms-&gt;crtcs[i], &amp;evts);  <span class="hljs-comment">//由crtc根据不同的中断事件进行不同的显示处理</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><code>drm_dev_register(drm, 0);</code>   &#x2F;&#x2F;注册drm device</li></ol><blockquote><p>kms attach中的内容是很标准的drm-kms驱动框架，与<a href="https://withector.github.io/2022/10/21/DRM%E7%BB%BC%E5%90%88/#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84KMS%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-atomic">withector.github.io–DRM应用及驱动浅析</a>中<code>最简单的kms驱动</code>流程基本一致，但是其中涉及的硬件操作，引入的wb_connector的obj，以及各个硬件与KMS obj的映射都要复杂很多。</p></blockquote>  <!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
      <category>DRM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>时钟子系统</title>
    <link href="/2023/04/09/%E6%97%B6%E9%92%9F%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/04/09/%E6%97%B6%E9%92%9F%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<div align = "center"><h3 id="linux时钟子系统"><a href="#linux时钟子系统" class="headerlink" title="linux时钟子系统"></a>linux时钟子系统</h3></div><h4 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h4><ul><li>内核使用CCF(common clock framework)对时钟进行管理，linux时钟子系统框架结构如下图所示：<br> <img src="/../images/clk_imgs/ccf.jpg" alt="pic"><ul><li>右侧为时钟的提供者clock provider，比如各种有&#x2F;无源晶振</li><li>中间为CCF，将时钟与对应的设备匹配</li><li>左侧为时钟的使用者clock consumer，即各个设备</li></ul></li></ul><h4 id="clock-consumer"><a href="#clock-consumer" class="headerlink" title="clock consumer"></a>clock consumer</h4><ul><li>clock子系统向clock comsumer提供一套通用API用于访问底层时钟，从而屏蔽底层硬件的差异，在进行设备驱动的编写时可以使用以下API函数对设备所需的时钟进行操作。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *id)</span>;<br><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">devm_clk_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *id)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">clk_prepare</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk)</span>;       <span class="hljs-comment">//启动clock前的准备工作，可能会睡眠</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">clk_unprepare</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk)</span>;    <span class="hljs-comment">//停止clock之后的善后工作，可能会睡眠</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">clk_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk)</span>;    <span class="hljs-comment">//启动clock，不会睡眠</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">clk_disable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk)</span>;  <span class="hljs-comment">//停止clock，不会睡眠</span><br><br><span class="hljs-comment">/*clock的频率获取和设置*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">clk_get_rate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk)</span>;<br><span class="hljs-type">long</span> <span class="hljs-title function_">clk_round_rate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rate)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">clk_set_rate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rate)</span>;<br><br><span class="hljs-comment">/*获取或者设置clock的parent*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">clk_set_parent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk, <span class="hljs-keyword">struct</span> clk *parent)</span>;<br><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_get_parent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">clk_prepare_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk)</span>;    <span class="hljs-comment">//将preparea和enable组合起来</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">clk_disable_unprepare</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk *clk)</span>;<span class="hljs-comment">//将unprepare和disable组合起来</span><br></code></pre></td></tr></table></figure></li><li>需要注意的是，在进行设备驱动编写时，如果需要对时钟进行操作，必须先使用<code>clk_get</code>或者<code>devm_clk_get</code>函数获取对应的时钟，会返回一个<code>struct clk *</code>结构体，即为一个clk对象，在使用其他API时均通过传入此clk对象对具体的clk进行操作。</li></ul><h4 id="CCF-common-clock-framework"><a href="#CCF-common-clock-framework" class="headerlink" title="CCF(common clock framework)"></a>CCF(common clock framework)</h4><ul><li>CCF是linux时钟子系统的核心，将其抽象为一个<code>struct clk_core</code>，每一个注册的时钟设备都对应一个<code>clk_core</code>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_core</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_ops</span>*<span class="hljs-title">ops</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_hw</span>*<span class="hljs-title">hw</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span>*<span class="hljs-title">owner</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>*<span class="hljs-title">dev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>*<span class="hljs-title">of_node</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_core</span>*<span class="hljs-title">parent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_parent_map</span>*<span class="hljs-title">parents</span>;</span><br>u8num_parents;<br>u8new_parent_index;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>rate;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>req_rate;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>new_rate;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_core</span>*<span class="hljs-title">new_parent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_core</span>*<span class="hljs-title">new_child</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>flags;<br><span class="hljs-type">bool</span>orphan;<br><span class="hljs-type">bool</span>rpm_enabled;<br><span class="hljs-type">bool</span>need_sync;<br><span class="hljs-type">bool</span>boot_enabled;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>enable_count;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>prepare_count;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>protect_count;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>min_rate;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>max_rate;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>accuracy;<br><span class="hljs-type">int</span>phase;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_duty</span><span class="hljs-title">duty</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span><span class="hljs-title">children</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span><span class="hljs-title">child_node</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span><span class="hljs-title">clks</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>notifier_count;<br> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_FS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>*<span class="hljs-title">dentry</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span><span class="hljs-title">debug_node</span>;</span><br> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span><span class="hljs-title">ref</span>;</span><br> &#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="clock-provider"><a href="#clock-provider" class="headerlink" title="clock provider"></a>clock provider</h4><ul><li>时钟子系统将所有的clock_provider分为6类<ul><li>fixed_clk：固定频率时钟</li><li>fixed_factor_clk：固定分频系数时钟</li><li>devider：分频器</li><li>gate：门，控制时钟使能&#x2F;失能</li><li>mux：多路选择器，用于选择时钟源</li><li>composite：从多个时钟中选一个父时钟，并对其进行分频</li></ul></li></ul><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul><li><p>将所有的clock_provider中共有的硬件特性抽象出来，使用<code>struct clk_hw</code>描述一个具体的硬件时钟</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_hw</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_core</span> *<span class="hljs-title">core</span>;</span>  <span class="hljs-comment">//和clk_hw互相包含 point back</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk</span> *<span class="hljs-title">clk</span>;</span>  <span class="hljs-comment">//指向consummer中的clk实例，用于 call clk API </span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_init_data</span> *<span class="hljs-title">init</span>;</span> <span class="hljs-comment">//contains the init data shared with the common clock framework</span><br> &#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>struct clk_init_data</code>描述时钟的初始化数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_init_data</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_ops</span>*<span class="hljs-title">ops</span>;</span>  <span class="hljs-comment">//操作函数集合 consummer调用的API函数实际上就是此函数集的抽象</span><br>    <span class="hljs-comment">/* Only one of the following three should be assigned */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> *parent_names;<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_parent_data</span>*<span class="hljs-title">parent_data</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_hw</span>**<span class="hljs-title">parent_hws</span>;</span><br>    u8num_parents;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>flags;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>struct clk_ops</code>时钟操作函数集合，定义在<code>kernel/include/linux/clk-provider.h</code>中<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk_ops</span> &#123;</span><br>    <span class="hljs-type">int</span>(*prepare)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">void</span>(*unprepare)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">int</span>(*is_prepared)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">void</span>(*unprepare_unused)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">int</span>(*enable)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">void</span>(*disable)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">int</span>(*is_enabled)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">void</span>(*disable_unused)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">int</span>(*save_context)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">void</span>(*restore_context)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span><span class="hljs-params">(*recalc_rate)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> parent_rate)</span>;<br>    <span class="hljs-type">long</span>(*round_rate)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rate, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *parent_rate);<br>    <span class="hljs-type">int</span>(*determine_rate)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-keyword">struct</span> clk_rate_request *req);<br>    <span class="hljs-type">int</span>(*set_parent)(<span class="hljs-keyword">struct</span> clk_hw *hw, u8 index);<br>    u8(*get_parent)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">int</span>(*set_rate)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rate, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> parent_rate);<br>    <span class="hljs-type">int</span>(*set_rate_and_parent)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rate,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> parent_rate, u8 index);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span><span class="hljs-params">(*recalc_accuracy)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> parent_accuracy)</span>;<br>    <span class="hljs-type">int</span>(*get_phase)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">int</span>(*set_phase)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-type">int</span> degrees);<br>    <span class="hljs-type">int</span>(*get_duty_cycle)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-keyword">struct</span> clk_duty *duty);<br>    <span class="hljs-type">int</span>(*set_duty_cycle)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-keyword">struct</span> clk_duty *duty);<br>    <span class="hljs-type">int</span>(*init)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">void</span>(*<span class="hljs-built_in">terminate</span>)(<span class="hljs-keyword">struct</span> clk_hw *hw);<br>    <span class="hljs-type">void</span>(*debug_init)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-keyword">struct</span> dentry *dentry);<br>    <span class="hljs-type">int</span>(*pre_rate_change)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rate, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> new_rate);<br>    <span class="hljs-type">int</span>(*post_rate_change)(<span class="hljs-keyword">struct</span> clk_hw *hw, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> old_rate,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rate);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>常用的函数，需要在clock驱动中实现</li></ul><div align="center"><table><thead><tr><th align="center">function</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">recalc_rate</td><td align="center">通过查询硬件，重新计算此时钟的速率。可选，但建议——如果未设置此操作，则时钟速率初始化为0</td></tr><tr><td align="center">round_rate</td><td align="center">给定目标速率作为输入，返回时钟实际支持的最接近速率</td></tr><tr><td align="center">set_rate</td><td align="center">更改此时钟的速率,请求的速率由第二个参数指定，该参数通常应该是调用.round_rate返回;第三个参数给出了父速率，这对大多数.set_rate实现有帮助;成功返回0，否则返回-EERROR</td></tr><tr><td align="center">enable</td><td align="center">…</td></tr><tr><td align="center">disable</td><td align="center">…</td></tr></tbody></table></li></ul></li><li><p>各个数据结构之间的关系如下图所示：</p><p>  <img src="/../images/clk_imgs/relation.jpg" alt="relationship"></p></li></ul><h4 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h4><ul><li>fixed rate clock<ul><li>这一类clock具有固定的频率，不能开关、不能调整频率、不能选择parent，是最简单的一类clock。可以直接通过 DTS 配置的方式支持。也可以通过接口，可以直接注册 fixed rate clock，如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">CLK_OF_DECLARE(fixed_clk, <span class="hljs-string">&quot;fixed-clock&quot;</span>, of_fixed_clk_setup);<br><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_register_fixed_rate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, </span><br><span class="hljs-params">          <span class="hljs-type">const</span> <span class="hljs-type">char</span> *parent_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, </span><br><span class="hljs-params">          <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fixed_rate)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li>gate clock<ul><li>这类clock只能选择开关，通过提供<code>.enable</code>和<code>.disable</code>回调函数实现，可通过下面接口进行注册：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_register_gate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">          <span class="hljs-type">const</span> <span class="hljs-type">char</span> *parent_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, </span><br><span class="hljs-params">          <span class="hljs-type">void</span> __iomem *reg, u8 bit_idx, u8 clk_gate_flags, </span><br><span class="hljs-params">          <span class="hljs-type">spinlock_t</span> *lock)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li>divider clock<ul><li>这类clock可以设置分频值，因此会提供<code>.recal_rate</code>、<code>.set_rate</code>、<code>.round_date</code>，可通过下面两个接口注册<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_register_divider</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, </span><br><span class="hljs-params">          <span class="hljs-type">const</span> <span class="hljs-type">char</span> *parent_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, </span><br><span class="hljs-params">          <span class="hljs-type">void</span> __iomem *reg, u8 shift, u8 width, u8 clk_divider_flags, </span><br><span class="hljs-params">          <span class="hljs-type">spinlock_t</span> *lock)</span>;<br><br><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_register_divider_table</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, </span><br><span class="hljs-params">          <span class="hljs-type">const</span> <span class="hljs-type">char</span> *parent_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">void</span> __iomem *reg, </span><br><span class="hljs-params">          u8 shift, u8 width, u8 clk_divider_flags, </span><br><span class="hljs-params">          <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> clk_div_table *table, <span class="hljs-type">spinlock_t</span> *lock)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li>mux clock<ul><li>这类clock可以设置多个parent，实现<code>.get_parent</code>、<code>.set_parent</code>、<code>.recal_rate</code>回调函数，可通过下面两个接口注册：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_register_mux</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">          <span class="hljs-type">const</span> <span class="hljs-type">char</span> **parent_names, u8 num_parents, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, </span><br><span class="hljs-params">          <span class="hljs-type">void</span> __iomem *reg, u8 shift, u8 width, u8 clk_mux_flags, </span><br><span class="hljs-params">          <span class="hljs-type">spinlock_t</span> *lock)</span>;<br>              <br><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_register_mux_table</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, </span><br><span class="hljs-params">          <span class="hljs-type">const</span> <span class="hljs-type">char</span> **parent_names, u8 num_parents, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,</span><br><span class="hljs-params">          <span class="hljs-type">void</span> __iomem *reg, u8 shift, u32 mask, u8 clk_mux_flags, </span><br><span class="hljs-params">          u32 *table, <span class="hljs-type">spinlock_t</span> *lock)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li>fixed factor clock<ul><li>这一类clock具有固定的factor（即multiplier和divider），clock的频率是由parent clock的频率，乘以mul，除以div，多用于一些具有固定分频系数的clock。由于parent clock的频率可以改变，因而fix factor clock也可该改变频率，因此也会提供<code>.recalc_rate</code>、<code>.set_rate</code>、<code>.round_rate</code>等回调。可通过下面接口注册：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_register_fixed_factor</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, </span><br><span class="hljs-params">          <span class="hljs-type">const</span> <span class="hljs-type">char</span> *parent_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, </span><br><span class="hljs-params">          <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mult, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> div)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li>composite clock<ul><li>其余各类clock的组合<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> clk *<span class="hljs-title function_">clk_register_composite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,</span><br><span class="hljs-params">              <span class="hljs-type">const</span> <span class="hljs-type">char</span> **parent_names, <span class="hljs-type">int</span> num_parents,</span><br><span class="hljs-params">              <span class="hljs-keyword">struct</span> clk_hw *mux_hw, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> clk_ops *mux_ops,</span><br><span class="hljs-params">              <span class="hljs-keyword">struct</span> clk_hw *rate_hw, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> clk_ops *rate_ops,</span><br><span class="hljs-params">              <span class="hljs-keyword">struct</span> clk_hw *gate_hw, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> clk_ops *gate_ops,</span><br><span class="hljs-params">              <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>imx6ull和虚拟机网络配置说明</title>
    <link href="/2022/12/26/imx6ull%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/12/26/imx6ull%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<ol><li><p>硬件结构拓扑：开发板和PC连接同一个路由器，电脑通过WIFI接入，开发板使用网线与路由器直接连接（开发板在UBOOT阶段只能使用物理网口，不能使用WIFI，UBOOT不支持WiFi驱动）</p></li><li><p>打开虚拟机软件，本人使用的是virtual box，选择虚拟机网络配置为桥接网卡，网卡选择为当前电脑使用的WIFI网卡</p></li><li><p>启动UBUNTU，进入UBUNTU的网络设置，配置其IPV4网络，将其设置为手动，设置静态IP，IP必须与当前当前WIFI的IP4网段相同</p></li><li><p>配置ubuntu的nfs，<code>sudo vi /etc/hosts</code>，将其中的ip更改为开发板要设定的ip，也必须处于同一网段</p></li><li><p>开发板上电，修改uboot中的环境变量</p> <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">setenv</span></span> ipaddr ... <span class="hljs-comment">//开发板ip</span><br><span class="hljs-function"><span class="hljs-title">setenv</span></span> severip ... <span class="hljs-comment">//虚拟机ip</span><br><span class="hljs-function"><span class="hljs-title">setenv</span></span> gatewayip ... <span class="hljs-comment">//网关</span><br>saveenv <br></code></pre></td></tr></table></figure></li><li><p>修改bootcmd 和 bootargs</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> bootcmd &#x27;nfs <span class="hljs-number">80800000</span> <span class="hljs-number">192.168.6.194</span>:/home/hector/linux/nfs_share/zImage;nfs <span class="hljs-number">83000000</span> <span class="hljs-number">192.168.6.194</span>:/home/hector/linux/nfs_share/imx6ull-alientek-emmc.dtb;bootz <span class="hljs-number">80800000</span> - <span class="hljs-number">83000000</span>&#x27; //其中的ip需要根据虚拟机ip自行配置一下<br><span class="hljs-attribute">setenv</span> bootargs &#x27;console=ttymxc0,<span class="hljs-number">115200</span> root=/dev/nfs nfsroot=<span class="hljs-number">192.168.6.194</span>:/home/hector/linux/nfs_share/rootfs,proto=tcp rw ip=<span class="hljs-number">192.168.6.191:192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">6</span>.<span class="hljs-number">194</span>:<span class="hljs-number">192.168.6.1:255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span>::eth0:<span class="hljs-literal">off</span>&#x27; //其中的ip需要自行配置一下 最后一部分几个连续的ip分别是开发板ip，虚拟机ip，网关ip，掩码<br><span class="hljs-attribute">saveenv</span> <br></code></pre></td></tr></table></figure></li><li><p>配置完成后先在开发板ping虚拟机ip，如果能ping通基本上就没啥问题了，直接重启，或者执行boot命令即可</p></li></ol><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>nxp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dsi introduction</title>
    <link href="/2022/12/06/dsi%20introduction/"/>
    <url>/2022/12/06/dsi%20introduction/</url>
    
    <content type="html"><![CDATA[<div align="center"><h1 id="DSI-Introduction"><a href="#DSI-Introduction" class="headerlink" title="DSI Introduction"></a>DSI Introduction</h1><p><em>参考文档：《MIPI_DSI_Specification_V1.02.00》</em></p></div><h2 id="1-MIPI-DSI-简介"><a href="#1-MIPI-DSI-简介" class="headerlink" title="1 MIPI DSI 简介"></a>1 MIPI DSI 简介</h2><ul><li><p>Display Serial Interface，用于显示模块的一个串行接口，基于MIPI协议而产生，兼容DPI(Display Pixel Interface)、DBI(Display Bus Interface)、DCS(Display Command Set</p></li><li><p>接口定义示意图如下</p><p>  <img src="/../images/dsi_images/%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="接口定义示意图"></p></li><li><p>MIPI-DSI具备高速模式和低速模式两种工作模式，全部数据通道（1~4组数据通道）都可以用于单向的高速传输，但只有第一个数据通道(DATA Lane 0)才可用于低速双向传输<em>关于高速模式和低速模式参考D-PHY的那篇blog</em></p></li></ul><h2 id="2-DSI分层"><a href="#2-DSI分层" class="headerlink" title="2 DSI分层"></a>2 DSI分层</h2><ul><li><p>DSI分层结构图（与D-PHY中的第一张图相同，D-PHY完成其物理层的工作）</p><p>  <img src="/../images/dsi_images/dsi%E5%88%86%E5%B1%82%E5%9B%BE.png" alt="DSI分层图"></p></li></ul><h3 id="2-1-PHY-Layer-物理层，上一篇blog已作详细介绍"><a href="#2-1-PHY-Layer-物理层，上一篇blog已作详细介绍" class="headerlink" title="2.1 PHY-Layer:物理层，上一篇blog已作详细介绍"></a>2.1 PHY-Layer:物理层，上一篇blog已作详细介绍</h3><h3 id="2-2-Lane-Management"><a href="#2-2-Lane-Management" class="headerlink" title="2.2 Lane Management"></a>2.2 Lane Management</h3><ul><li><p>通道管理层，对于Master来说，负责将所有的数据按照一定顺序分配给所有的数据Lane；对于Slave来说，负责从所有的Data Lane接收数据后将数据重组为原始数据</p></li><li><p>通道分配关系如下图：</p><p>  <img src="/../images/dsi_images/%E9%80%9A%E9%81%93%E5%88%86%E9%85%8D%E5%85%B3%E7%B3%BB.png" alt="通道分配关系"></p></li></ul><h3 id="2-3-Low-Level-Protocol"><a href="#2-3-Low-Level-Protocol" class="headerlink" title="2.3 Low Level Protocol"></a>2.3 Low Level Protocol</h3><ul><li><p>协议层，负责对数据进行封包（Master）或者错误校验（Slave）</p></li><li><p>信息传输采用两种数据格式–长数据包(long packet)和短数据包(short packet),发送数据时根据数据类型和内容对数据进行封装，完成ECC码和CRC码的添加；接收数据的时候根据ECC码和CRC校验码对数据包进行校验。</p></li><li><p>两种数据包的结构如下图所示：</p><p>  <img src="/../images/dsi_images/%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.png" alt="数据包格式"></p></li><li><p>短数据包(short packet)</p><ul><li>只有数据包头</li><li>固定长度四个字节<ul><li>byte3：Data Identifier (DI)，0-5bit描述数据类型(详细见附录)，6-7bit描述通道号</li><li>byte1-2：Packet Data，命令或者数据（有效荷载），Data0为寄存器地址，Data1为值，如果不需要值将Data1置为0</li><li>byte0：ECC码</li></ul></li></ul></li><li><p>长数据包(long packet)</p><ul><li>不固定长度，长度范围为 4+(0<del>65535)+2 &#x3D; 6</del>65541bytes</li><li>包头由DI、两字节的WordCount（数据长度，不含Checksum）和一个字节的ECC码组成</li><li>校验和为2bytes</li></ul></li></ul><h3 id="2-4-Application"><a href="#2-4-Application" class="headerlink" title="2.4 Application"></a>2.4 Application</h3><ul><li>应用层，在此层对命令和数据进行初步编码转化为MIPI-DSI所规定的格式并发送（Master）；图将接收的数据还原为应用模块所支持的数据格式及时序要求（Slave）</li></ul><h2 id="3-Command-Mode-and-Video-Mode"><a href="#3-Command-Mode-and-Video-Mode" class="headerlink" title="3 Command Mode and Video Mode"></a>3 Command Mode and Video Mode</h2><ul><li>command mode的屏幕一般就是一些单片机或者低端产品上会用的液晶屏幕，它们在发送图像和命令时需要先制定写入地址。而我们日常所使用到的mipi液晶屏基本都是video mode的屏幕，刷新时是整个屏幕的进行刷新，不需要我们去先指定地址。</li><li>同步刷新机制：<ul><li>command mode：通过TE pin来同步</li><li>video mode：通过将v-sync及h-sync信号包含在数据包里发送给panel来做同步</li></ul></li><li>Command Mode：对于本身有framebuffer的外设，使用command Mode向其指定地址写入数据，使其更新显示屏幕，主要用与静态显示的屏幕，更新频率较低，需要双向接口</li><li>video mode：不间断的向外设发送像素流数据，实时更新，多用于动态图像显示，更新频率高，数据只能在HS Mode下传输（有些video mode架构中存在简单的时钟控制器和部分framebuffer，在低功耗时允许保持部分屏幕或者以低分辨率显示屏幕，从而达到允许关闭接口降低功耗的目的），为了降低系统复杂性和成本，至工作在video mode下的系统可能仅仅使用一个单向数据通道。</li></ul><h2 id="4-时钟管理"><a href="#4-时钟管理" class="headerlink" title="4 时钟管理"></a>4 时钟管理</h2><ul><li>DSI clock是从host到外设的时钟信号：<ul><li>DSI Bit　Clock:作源同步位时钟，用于捕获接收端接口中的串行数据位</li><li>Byte Clock：在协议层和应用层接口之间作字节时钟，在协议层和应用层之间的操作都与此字节时钟保持同步</li><li>Application Clock：DSI位时钟的分频版本可用于外围设备的其他时钟功能。这些“应用程序时钟”可能需要在没有串行数据传输时运行，或者它们可能需要持续运行（连续时钟）以支持外围设备的有源电路。（非标）</li></ul></li><li>时钟计算公式：<mark>dsi clk &#x3D; Bitclk &#x2F; 2  &#x3D; H-total x V-total x fps x 位深 &#x2F; lane number &#x2F; 2</mark><ul><li>H-total：行所有像素点 行分辨率还要加上HSYNC和HBP、HFP</li><li>V-total: 列所有限速点 列分辨率还要加上VSYNC和VBP、VFP</li><li>&#x2F;2的原因是MIPI采用的双边沿触发，一个时钟脉冲会触发两次</li><li>fps：帧数</li><li>位深：每个像素的数据位，rgb888-24 rgb565-16</li></ul></li></ul><h2 id="5-数据传输方法"><a href="#5-数据传输方法" class="headerlink" title="5 数据传输方法"></a>5 数据传输方法</h2><ul><li><p>最简单的传输状况，一个Transmiss包含一个packet，但是multiple packets时，由于每次HS mode传输间会插入LPS(Low-Power State)，这样效率会很低。所有有如下Separate transmission和Single Transmission两种传输方式，目的就是在一次Transmission中能狗传输多个packets</p><p>  <img src="/../images/dsi_images/transmission%20packets.png" alt="transmission packets"></p></li><li><p>DSI 协议层还提供了一个专用的short packet用于表示传输结束（EoTp-end of transmission packet）,这个packet默认是disable状态，enable方法没有在Specification文件中说明，用的比较少。</p><p>  <img src="/../images/dsi_images/EoTp%20transmisson%20packet.png" alt="EoTp transmission packets"></p></li></ul><h2 id="6-video-mode-接口时序"><a href="#6-video-mode-接口时序" class="headerlink" title="6 video mode 接口时序"></a>6 video mode 接口时序</h2><ul><li>video mode下的三种操作模式如下：</li><li>下面图中顶部有圆弧的代表数据包，长方形的代表时序的状态</li><li>video中用到的数据包有以下几种(具体packet见附录)<table><thead><tr><th align="center">packet</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">VSS</td><td align="center">DSI Sync Event Packet: V Sync Start</td></tr><tr><td align="center">VSE</td><td align="center">DSI Sync Event Packet: V Sync End</td></tr><tr><td align="center">BLLP</td><td align="center">DSI Packet: Arbitrary sequence of non-restricted DSI packets or Low Power Mode incluing optional BTA</td></tr><tr><td align="center">HSS</td><td align="center">DSI Sync Event Packet: H Sync Start</td></tr><tr><td align="center">HAS</td><td align="center">DSI Blanking Packet: Horizontal Sync Active or Low Power Mode, No Data</td></tr><tr><td align="center">HSE</td><td align="center">DSI Sync Event Packet: H Sync End</td></tr><tr><td align="center">HFP</td><td align="center">DSI Blanking Packet: Horizontal Front Porch or Low Power Mode</td></tr><tr><td align="center">HBP</td><td align="center">DSI Blanking Packet: Horizontal Back Porch or Low Power Mode</td></tr><tr><td align="center">RGB</td><td align="center">DSI Packet: Arbitrary sequence of pixel stream and Null Packets</td></tr><tr><td align="center">LPM</td><td align="center">Low Power Mode incuding optional BTA</td></tr></tbody></table></li></ul><h3 id="6-1-Non-Burst-Mode-with-Sync-Pulses"><a href="#6-1-Non-Burst-Mode-with-Sync-Pulses" class="headerlink" title="6.1 Non-Burst Mode with Sync Pulses"></a>6.1 Non-Burst Mode with Sync Pulses</h3><ul><li><p>使用此格式，目标是通过DSI串行链路准确传达DPI类型的时序，包括匹配DPI像素传输速率和同步脉冲的宽度等，因此，使用传输同步脉冲的开始和结束的来定义同步周期。</p><p>  <img src="/../images/dsi_images/non%20burst%20with%20sync%20.png" alt="non burst with sync"></p><ul><li>HSA (Horizontal Sync Active)</li><li>HBP (Horizontal Back Porch)</li><li>HFP (Horizontal Front Porch)</li><li>以上三个阶段一般由空数据包填充，且处于以上三个阶段时，Lane保持LP-11状态</li></ul></li></ul><h3 id="6-2-Non-Burst-Mode-with-Sync-Events"><a href="#6-2-Non-Burst-Mode-with-Sync-Events" class="headerlink" title="6.2 Non-Burst Mode with Sync Events"></a>6.2 Non-Burst Mode with Sync Events</h3><ul><li><p>是 Non-Burst Mode with Sync Pulses的简化版，只传输同步脉冲的开始信号，外围设备可以根据需要从接收到的每个同步事件包中重新生成同步脉冲。</p><p>  <img src="/../images/dsi_images/non%20burst%20with%20sync%20events.png" alt="non burst with sync events"></p></li></ul><h3 id="6-3-Burst-mode-用的最多"><a href="#6-3-Burst-mode-用的最多" class="headerlink" title="6.3 Burst mode(用的最多)"></a>6.3 Burst mode(用的最多)</h3><ul><li>在horizontal 的时序是一样的情况下DSI会把连接的速度提升到Panel支持的最大速度。在这种模式下发送RGB数据包的时间被压缩，以留出更多的时间用来传送其他的数据。<br><img src="/../images/dsi_images/burst%20mode.png" alt="burst mode"></li></ul><h3 id="6-4-参数"><a href="#6-4-参数" class="headerlink" title="6.4 参数"></a>6.4 参数</h3><p>  <img src="/../images/dsi_images/Parameters.png" alt="parameters"><br>  <img src="/../images/dsi_images/parameters2.png" alt="parameters2"></p><h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3><ul><li>上述三种模式的时序框架都是相同的，VSA Lines、 VBP Lines 和 VFP Lines是帧同步时序所必须的，在Active Video Area里面对每一行进行刷新，每一行的数据包由行同步所必须的数据包加上RGB数据包组成</li></ul><h2 id="附录-Packet-Data-Types"><a href="#附录-Packet-Data-Types" class="headerlink" title="附录 Packet Data Types"></a>附录 Packet Data Types</h2><ul><li>文档 MIPI_DSI_Specification_V1.02.00 第八章有关于各个data type的详细描述<br>  <img src="/../images/dsi_images/packet%20data%20type1.png" alt="packet data type 1"><br>  <img src="/../images/dsi_images/packet%20data%20type%202.png" alt="packet data type 2"></li></ul><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>MIPI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPI D-PHY</title>
    <link href="/2022/12/03/mipi%20d-phy/"/>
    <url>/2022/12/03/mipi%20d-phy/</url>
    
    <content type="html"><![CDATA[<div align="center"><h1 id="MIPI-D-PHY"><a href="#MIPI-D-PHY" class="headerlink" title="MIPI D-PHY"></a>MIPI D-PHY</h1></div><h2 id="1-MIPI-D-PHY介绍"><a href="#1-MIPI-D-PHY介绍" class="headerlink" title="1 MIPI D-PHY介绍"></a>1 MIPI D-PHY介绍</h2><h3 id="1-1-关于MIPI"><a href="#1-1-关于MIPI" class="headerlink" title="1.1 关于MIPI"></a>1.1 关于MIPI</h3><ul><li><p>MIPI - Mobile Industry Processor Interface</p></li><li><p>两个通过MIPI通信的硬件结构如下图：</p><p>  <img src="/../images/mipi_images/mipi%E9%80%9A%E4%BF%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="mipi通信"> </p><ul><li>PHY LAYER为物理层 （如D-PHY）</li><li>low level protocol和lane management为中间层</li><li>application为应用层</li></ul></li></ul><h3 id="1-2-关于D-PHY"><a href="#1-2-关于D-PHY" class="headerlink" title="1.2 关于D-PHY"></a>1.2 关于D-PHY</h3><ul><li><p>DSI - Display Serial Interface (主机与显示模块之间的高速串行接口)</p></li><li><p>D-PHY为DSI提供一个物理接口 (CSI也是D-PHY)</p><p><img src="/../images/mipi_images/ppi%E5%92%8Cappi.png" alt="ppi&amp;appi"></p><ul><li><p>MIPI连接包含一个master设备和一个slave设备，主设备向clock lane提供高速时钟信号，是主要的时钟源；slave设备是主要的设备接受端。从主设备到从设备为正向传输，所有的情况下时钟信号都保持正向传输，只有双向data lane才能反向传输。</p></li><li><p>D-PHY包括 one clock Lane and one or more Data Lane</p></li><li><p>Clock Lane总是单(正)向的，Data Lane可以双向</p></li><li><p>lane types</p><ul><li>单向Clock Lane</li><li>单向Data Lane</li><li>双向Data Lane</li></ul></li><li><p>传输模式：</p><ul><li>low power，主要用于控制(CTRL)</li><li>high speed，主要用于高速数据(DATA)传输</li></ul></li><li><p>HS模式和LP模式区别</p><table><thead><tr><th align="center"></th><th align="center">HS模式</th><th align="center">LP模式</th></tr></thead><tbody><tr><td align="center">传输模式</td><td align="center">差分信号</td><td align="center">单端信号</td></tr><tr><td align="center">传输速度</td><td align="center">80M-1.5Gbps</td><td align="center">&lt;10Mbps</td></tr><tr><td align="center">功耗</td><td align="center">大</td><td align="center">小</td></tr></tbody></table></li></ul></li><li><p>最小数据单元— 1 byte  (LSB first)</p></li></ul><h2 id="2-Lane-Module"><a href="#2-Lane-Module" class="headerlink" title="2 Lane Module"></a>2 Lane Module</h2><ul><li><p>lane内部结构如下图：</p><p><img src="/../images/mipi_images/lane%20module%20arch.png" alt="lane module arch"></p><ul><li>PHY由多个D-PHY组成 一个D-PHY实际上就是一个Lane Module</li><li>D-PHY主要输入输出：<ul><li>LP-TX</li><li>LP-RX</li><li>HS-TX</li><li>HS-RX</li><li>LP-CD(low power contention detector)</li></ul></li><li>通过两根线Dp和Dn与另一侧lane连接通信</li><li><mark>DSI实际配置中，DATA0的LP双向，HS单向，其他的DATA LANE的LP和HS均为单向</mark></li></ul></li><li><p>Lane Module的主要类型配置</p><ul><li>单向 Clock Lane<ul><li>Master: HS-TX LP-TX</li><li>Slave: HS-RX LP-RX</li></ul></li><li>单向 Data Lane<ul><li>Master: HS-TX LP-TX</li><li>Slave: HS-RX LP-RX</li></ul></li><li>双向 Data Lane<ul><li>Master&#x2F;Slave: HS-TX  HS-RX LP-RX LP-TX LP-CD</li></ul></li></ul></li></ul><h2 id="3-lane-states-and-line-level-Dp-and-Dn"><a href="#3-lane-states-and-line-level-Dp-and-Dn" class="headerlink" title="3 lane states and line level(Dp and Dn)"></a>3 lane states and line level(Dp and Dn)</h2><ul><li><p>同样的两根线Dp和Dn，HS模式使用的是差分信号，因此同一时刻根据两根线上的电平只能得出0&#x2F;1两种结果；LP模式使用的是单端信号，因此可能存在00&#x2F;01&#x2F;10&#x2F;11四种情况</p></li><li><p>关于lane state和line level的描述见下图 </p><p><img src="/../images/mipi_images/lane%20state%20and%20line%20level.png" alt="lane state and line level"></p><ul><li>note 1: 在高速传输时，LP receiver在线上观察到的状态始终是LP-00</li><li>note 2：如果在escape mode中出现LP-11, lane module会返回一个停止状态(也就是control mode 下的 LP-11)</li></ul></li></ul><h2 id="4-Data-Lane-操作模式"><a href="#4-Data-Lane-操作模式" class="headerlink" title="4 Data Lane 操作模式"></a>4 Data Lane 操作模式</h2><ul><li>data lane有三种操作模式– <mark>Control Mode、High-Speed(Data Burst) Mode、Escape Mode</mark></li><li>在control mode下以stop state作为起始信号可以提出进入以下三种模式的请求：<ul><li><strong>Escape Mode Requset: (LP-11→LP-10→LP-00→LP-01→LP-00)</strong></li><li><strong>High-Speed Request: (LP-11→LP-01→LP-00)</strong></li><li><strong>Turnaround Request: (LP-11→LP-10→LP-00→LP-10→LP-00)</strong></li></ul></li></ul><h3 id="4-1-Escape-Mode"><a href="#4-1-Escape-Mode" class="headerlink" title="4.1 Escape Mode"></a>4.1 Escape Mode</h3><ul><li><p>Escape Mode 是 Data Lane 在 LP 状态下的一种特殊操作模式</p></li><li><p>Escape Mode下有以下三种可用的附加功能：</p><ul><li>LPDT (Low-Power Data Transmission)</li><li>ULPS (Ultra Low-Power State)</li><li>Trigger</li></ul></li><li><p>一旦进入Escape Mode，需要发送8 bit的entry command来指示所请求的动作</p></li><li><p>escape mode下的传输格式如下图：</p><p><img src="/../images/mipi_images/escape%20mode%20format.png" alt="escape mode fromat"></p></li><li><p>Escape Mode 下对Data Lane的操作的时钟不依赖于Clock Lane，而是由Dp和Dn异或产生的时钟信号</p></li><li><p>Escape Mode 使用 Spaced-One-Hot Encoding</p><ul><li><strong>每一个要传输的状态都要与一个Space State(LP-00)交错进行(上图中每个虚线周期内有体现)</strong></li><li><strong>在每一个Space State后面发送Mark-0&#x2F;1（见第三章图）表示传输一个0-bit 或者 1-bit</strong></li></ul></li><li><p><strong>Data Lane退出Escape Mode的指令：LP-10→LP-11</strong></p></li><li><p>关于上图中的Entry Command见下图，可通过下图中的code进入不同的state或者trigger</p><p><img src="/../images/mipi_images/escape%20entry%20codes.png" alt="escape entry codes"></p></li><li><p>下面对几种state 和 trigger进行说明：</p><ul><li><p>Remote Triggers（只有一个reset trigger）:If the Entry Command Pattern matches the Reset-Trigger Command a Trigger is flagged to the protocol at the receive side via the logical PPI. Any bit received after a Trigger Command but before the Lines go to Stop state shall be ignored. Therefore, dummy bytes can be concatenated in order to provide Clock information to the receive side.（不是很理解这个作用）</p></li><li><p>Low-Power Data Transmission(LPDT): </p><ul><li>低速传输数据</li><li>同样使用Spaced-One-Hot Encoding</li><li>同样不依赖Clock Lane，使用自编码的时钟</li><li>传输过程中可以保持Space State来暂停传输</li></ul></li><li><p>Ultra Low-Power State类似于休眠模式</p><ul><li>处于ULPS时，Dp和Dn处于Space state(LP-00)</li><li>退出ULPS：长度为T(wakeup)&#x3D;1ms的Mark-1,然后一个Stop state</li></ul></li></ul></li></ul><h3 id="4-2-High-Speed-Mode-Data-Burst"><a href="#4-2-High-Speed-Mode-Data-Burst" class="headerlink" title="4.2 High-Speed Mode(Data Burst)"></a>4.2 High-Speed Mode(Data Burst)</h3><ul><li><p>所有的Lane同步开始</p></li><li><p>不同的Lane可能在不同的时机结束</p></li><li><p>Clock Lane应该处于High-Speed Mode，向Slave side 提供一个DDR时钟</p></li><li><p>开始传输序列如下图</p><p><img src="/../images/mipi_images/Start-of-Transmission%20Sequence.png" alt="Start-of-Transmission Sequence"></p></li><li><p>结束传输序列如下图</p><p><img src="/../images/mipi_images/End-of-Transmission%20Sequence.png" alt="End-of-Transmission Sequence"></p></li><li><p>传输示例见下图</p><p><img src="/../images/mipi_images/High-Speed%20Data%20Transmission%20in%20Bursts.png" alt="High-Speed Data Transmission in Bursts"></p><ul><li>图中蓝色线条表示单端信号（LP-Control）</li><li>图中红色线条表示差分信号（HS-Data Burst）</li></ul></li></ul><h3 id="4-3-Bi-directional-Data-Lane-Turnaround"><a href="#4-3-Bi-directional-Data-Lane-Turnaround" class="headerlink" title="4.3 Bi-directional Data Lane Turnaround"></a>4.3 Bi-directional Data Lane Turnaround</h3><ul><li><p>双向数据通道允许通过Turnaround Procedure使数据在与当前方向相反的方向传输</p></li><li><p>正向改为反向或者反向改为正向的步骤相同</p></li><li><p>只能更改数据传输方向，不能改变Master和Slave side</p></li><li><p>Turnaround 应该完全在 LP-Control Mode下进行</p></li><li><p>Tunraround 序列如下图所示：</p><p><img src="/../images/mipi_images/Turnaround%20Sequence1.png" alt="Turnaround Sequence1"><br><img src="/../images/mipi_images/Turnaround%20Sequence2.png" alt="Turnaround Sequence2"></p></li><li><p>Turnaround Procedure 示例时序图如下：</p><p><img src="/../images/mipi_images/Turnaround%20Procedure.png" alt="Turnaround Procedure"></p></li></ul><h2 id="5-Clock-Lane"><a href="#5-Clock-Lane" class="headerlink" title="5 Clock Lane"></a>5 Clock Lane</h2><ul><li>支持High-Speed和ULPS Clock Lane</li></ul><h3 id="5-1-High-Speed-Clock-Transmission"><a href="#5-1-High-Speed-Clock-Transmission" class="headerlink" title="5.1 High-Speed Clock Transmission"></a>5.1 High-Speed Clock Transmission</h3><ul><li><p>时钟信号相位应该与正向数据通道上的bit切换序列相位正交</p></li><li><p>Data Burst 传输的第一个 bit 应该在时钟信号的上升沿</p></li><li><p>High-Speed Clock Transmission初始化和结束为LP Mode的时序如下图</p><p><img src="/../images/mipi_images/Procedure%20to%20Initiate%20High-Speed%20Clock%20Transmission.png" alt="Procedure to Initiate High-Speed Clock Transmission"></p></li><li><p>当最后一个Data Lane完成HS Data Transmission后，以HS-0结束，并且进入LP Mode，高速时钟信号应继续运行T(CLK-POST)时间，下图给出了Clock Lane由High-Speed Clock Transmission切换至LP Mode和由LP Mode 切换至High-Speed Clock Transmission的过程</p><p><img src="/../images/mipi_images/Switching%20the%20Clock%20Lane%20between%20Clock%20Transmission%20and%20Low-Power%20Mode.png" alt="Switching the Clock Lane between Clock Transmission and Low-Power Mode"></p></li></ul><h3 id="5-2-Clock-Lane-Ultra-Low-Power-State"><a href="#5-2-Clock-Lane-Ultra-Low-Power-State" class="headerlink" title="5.2 Clock Lane Ultra-Low Power State"></a>5.2 Clock Lane Ultra-Low Power State</h3><ul><li>进入Ultra-Low Power State<ol><li>Stop state (LP-11)</li><li>TX-ULPS-Rqst State (LP-10)</li><li>TX-ULPS State (LP-00)</li><li>进入 Ultra-Low Power State后，两条线保持TX-ULPS State (LP-00)</li></ol></li><li>退出Ultra-Low Power State ： Mark-1 TX-ULPS-Exit State</li></ul><h2 id="6-System-Power-States"><a href="#6-System-Power-States" class="headerlink" title="6 System Power States"></a>6 System Power States</h2><ul><li>三种功耗等级<ol><li>High-Speed Transmission mode</li><li>Low-Power mode</li><li>Ultra-Low Power State</li></ol></li></ul><h2 id="7-Lane-Module初始化"><a href="#7-Lane-Module初始化" class="headerlink" title="7 Lane Module初始化"></a>7 Lane Module初始化</h2><ul><li><p>Master Lane Module的初始化由系统输入信号完成</p></li><li><p>Slave Lane Module的初始化由Master发出一个时长超过T(INIT)的STOP信号完成</p><p><img src="/../images/mipi_images/Initialization%20States.png" alt="Initialization States"></p></li></ul><h2 id="8-状态变换总结"><a href="#8-状态变换总结" class="headerlink" title="8 状态变换总结"></a>8 状态变换总结</h2><ul><li><p>Data Lane</p><p><img src="/../images/mipi_images/Data%20Lane%20Module%20State%20Diagram.png" alt="Data Lane Module State Diagram"></p></li><li><p>Clock Lane</p><p><img src="/../images/mipi_images/Clock%20Lane%20Module%20State%20Diagram.png" alt="Clock Lane Module State Diagram"></p></li></ul><h2 id="附录-时间参数"><a href="#附录-时间参数" class="headerlink" title="附录-时间参数"></a>附录-时间参数</h2><p><img src="/../images/mipi_images/Global%20Operation%20Timing%20Parameters1.png" alt="Global Operation Timing Parameters1"><br><img src="/../images/mipi_images/Global%20Operation%20Timing%20Parameters2.png" alt="Global Operation Timing Parameters2"><br><img src="/../images/mipi_images/Global%20Operation%20Timing%20Parameters3.png" alt="Global Operation Timing Parameters3"></p><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>MIPI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>linux tty 串口驱动</title>
    <link href="/2022/11/27/linux%20tty%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/"/>
    <url>/2022/11/27/linux%20tty%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<div align="center"><h1 id="linux-tty-串口驱动"><a href="#linux-tty-串口驱动" class="headerlink" title="linux tty 串口驱动"></a>linux tty 串口驱动</h1></div><h2 id="TTY和serial-port"><a href="#TTY和serial-port" class="headerlink" title="TTY和serial port"></a>TTY和serial port</h2><blockquote><p>tty:描述各类终端设备，主要包括tty核心、tty线路规划、tty驱动。tty核心是对整个tty设备的抽象，对用户空间提供统一的接口；tty线路规划是对传输数据的格式化，tty驱动则是面向tty设备的硬件驱动。<br>serial port也是tty的一种，主要负责对串口硬件的驱动</p></blockquote><ul><li>串口驱动结构如下图所示：</li></ul><p><img src="/../images/tty%E4%B8%8Eserial%20port.png" alt="tty&amp;serial port"></p><h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><ul><li><p>uart_driver</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_driver</span>&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *driver_name;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name;<br>  <span class="hljs-type">int</span> major;<br>  <span class="hljs-type">int</span> minor;<br>  <span class="hljs-type">int</span> nr;       <span class="hljs-comment">//uart_driver支持的串口个数</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span> *<span class="hljs-title">cons</span>;</span><br><br>  <span class="hljs-comment">/*以下两个成员不在初始化uart_driver时赋值*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_state</span> *<span class="hljs-title">state</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">tty_driver</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>tty_driver与上层tty联系，会在register_uart_driver的过程中被赋值</li><li>uart_state中的uart_port成员是uart_driver中真正与硬件打交道的成员，在register_uart_driver的过程中为其分配内存</li></ul></li><li><p>uart_state</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_state</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_port</span> <span class="hljs-title">port</span>;</span><br>  <span class="hljs-type">int</span> pm_state;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circ_buf</span> <span class="hljs-title">xmit</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> <span class="hljs-title">tlet</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_port</span> *<span class="hljs-title">uart_port</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>此结构体中最重要的成员就是uart_port，在register时会根据uart_driver-&gt;nr成员的值去为uart_state分配内存，存放驱动支持的串口物理信息</li></ul></li><li><p>uart_port</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_port</span> &#123;</span><br>  <span class="hljs-type">spinlock_t</span>             lock;           <span class="hljs-comment">/* 串口端口锁 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>           iobase;         <span class="hljs-comment">/* IO端口基地址 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> __iomem *membase;        <span class="hljs-comment">/* IO内存基地址,经映射(如ioremap)后的IO内存虚拟基地址 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>           irq;            <span class="hljs-comment">/* 中断号 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>           uartclk;        <span class="hljs-comment">/* 串口时钟 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>           fifosize;       <span class="hljs-comment">/* 串口FIFO缓冲大小 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>          x_char;         <span class="hljs-comment">/* xon/xoff字符 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>          regshift;       <span class="hljs-comment">/* 寄存器位移 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>          iotype;         <span class="hljs-comment">/* IO访问方式 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>          unused1;<br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPIO_PORT        (0)               <span class="hljs-comment">/* IO端口 */</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPIO_HUB6        (1)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPIO_MEM         (2)               <span class="hljs-comment">/* IO内存 */</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPIO_MEM32       (3)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPIO_AU          (4)               <span class="hljs-comment">/* Au1x00 type IO */</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPIO_TSI         (5)               <span class="hljs-comment">/* Tsi108/109 type IO */</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPIO_DWAPB       (6)               <span class="hljs-comment">/* DesignWare APB UART */</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPIO_RM9000      (7)               <span class="hljs-comment">/* RM9000 type IO */</span></span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        read_status_mask;  <span class="hljs-comment">/* 关心的Rx error status */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        ignore_status_mask;<span class="hljs-comment">/* 忽略的Rx error status */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_info</span>      *<span class="hljs-title">info</span>;</span>           <span class="hljs-comment">/* pointer to parent info */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_icount</span>     <span class="hljs-title">icount</span>;</span>         <span class="hljs-comment">/* 计数器 */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">console</span>        *<span class="hljs-title">cons</span>;</span>           <span class="hljs-comment">/* console结构体 */</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SERIAL_CORE_CONSOLE</span><br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>         sysrq;           <span class="hljs-comment">/* sysrq timeout */</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-type">upf_t</span>                 flags;<br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_FOURPORT         ((__force upf_t) (1 &lt;&lt; 1))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_SAK              ((__force upf_t) (1 &lt;&lt; 2))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_SPD_MASK         ((__force upf_t) (0x1030))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_SPD_HI           ((__force upf_t) (0x0010))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_SPD_VHI          ((__force upf_t) (0x0020))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_SPD_CUST         ((__force upf_t) (0x0030))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_SPD_SHI          ((__force upf_t) (0x1000))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_SPD_WARP         ((__force upf_t) (0x1010))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_SKIP_TEST        ((__force upf_t) (1 &lt;&lt; 6))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_AUTO_IRQ         ((__force upf_t) (1 &lt;&lt; 7))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_HARDPPS_CD       ((__force upf_t) (1 &lt;&lt; 11))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_LOW_LATENCY      ((__force upf_t) (1 &lt;&lt; 13))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_BUGGY_UART       ((__force upf_t) (1 &lt;&lt; 14))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_MAGIC_MULTIPLIER ((__force upf_t) (1 &lt;&lt; 16))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_CONS_FLOW        ((__force upf_t) (1 &lt;&lt; 23))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_SHARE_IRQ        ((__force upf_t) (1 &lt;&lt; 24))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_BOOT_AUTOCONF    ((__force upf_t) (1 &lt;&lt; 28))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_FIXED_PORT       ((__force upf_t) (1 &lt;&lt; 29))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_DEAD             ((__force upf_t) (1 &lt;&lt; 30))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_IOREMAP          ((__force upf_t) (1 &lt;&lt; 31))</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_CHANGE_MASK      ((__force upf_t) (0x17fff))</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPF_USR_MASK         ((__force upf_t) (UPF_SPD_MASK|UPF_LOW_LATENCY))</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>             mctrl;        <span class="hljs-comment">/* 当前的moden设置 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>             timeout;      <span class="hljs-comment">/* character-based timeout */</span>        <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>             type;         <span class="hljs-comment">/* 端口类型 */</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_ops</span>   *<span class="hljs-title">ops</span>;</span>          <span class="hljs-comment">/* 串口端口操作函数集 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>             custom_divisor;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>             line;         <span class="hljs-comment">/* 端口索引 uart_driver.dev_name加上line组成串口的设备节点的名字 */</span><br>  <span class="hljs-type">resource_size_t</span>          mapbase;      <span class="hljs-comment">/* IO内存物理基地址，可用于ioremap */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>           *<span class="hljs-title">dev</span>;</span>          <span class="hljs-comment">/* 父设备 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>            hub6;         <span class="hljs-comment">/* this should be in the 8250 driver */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>            suspended;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>            unused[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">void</span>                    *private_data; <span class="hljs-comment">/* 端口私有数据,一般为platform数据指针 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>每一个uart_port对应一个串口设备，uart_port通过uart_add_port添加到uart_state-&gt;port数组中去，此结构体中最重要的成员变量是uart_ops,uart操作函数集</li></ul></li><li><p>struct uart_ops</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This structure describes all the operations that can be</span><br><span class="hljs-comment">* done on the physical hardware.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uart_ops</span> &#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*tx_empty)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> uart_port *)</span>; <span class="hljs-comment">/* 串口的Tx FIFO缓存是否为空。如果为空，函数应返回TIOCSER_TEMT，否则返回0。如果端口不支持此操作，返回TIOCSER_TEMT。*/</span><br>  <span class="hljs-type">void</span>         (*set_mctrl)(<span class="hljs-keyword">struct</span> uart_port *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mctrl); <span class="hljs-comment">/* 设置串口modem控制 */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*get_mctrl)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> uart_port *)</span>; <span class="hljs-comment">/* 获取串口modem控制 */</span><br>  <span class="hljs-type">void</span>         (*stop_tx)(<span class="hljs-keyword">struct</span> uart_port *); <span class="hljs-comment">/* 禁止串口发送数据 */</span><br>  <span class="hljs-type">void</span>         (*start_tx)(<span class="hljs-keyword">struct</span> uart_port *); <span class="hljs-comment">/* 使能串口发送数据 */</span><br>  <span class="hljs-type">void</span>         (*send_xchar)(<span class="hljs-keyword">struct</span> uart_port *, <span class="hljs-type">char</span> ch);<span class="hljs-comment">/* 发送xChar */</span><br>  <span class="hljs-type">void</span>         (*stop_rx)(<span class="hljs-keyword">struct</span> uart_port *); <span class="hljs-comment">/* 禁止串口接收数据 */</span><br>  <span class="hljs-type">void</span>         (*enable_ms)(<span class="hljs-keyword">struct</span> uart_port *); <span class="hljs-comment">/* 使能modem的状态信号 */</span><br>  <span class="hljs-type">void</span>         (*break_ctl)(<span class="hljs-keyword">struct</span> uart_port *, <span class="hljs-type">int</span> ctl); <span class="hljs-comment">/* 设置break信号 */</span><br>  <span class="hljs-type">int</span>          (*startup)(<span class="hljs-keyword">struct</span> uart_port *); <span class="hljs-comment">/* 启动串口,应用程序打开串口设备文件时,该函数会被调用 */</span><br>  <span class="hljs-type">void</span>         (*shutdown)(<span class="hljs-keyword">struct</span> uart_port *); <span class="hljs-comment">/* 关闭串口,应用程序关闭串口设备文件时,该函数会被调用 */</span><br>  <span class="hljs-type">void</span>         (*set_termios)(<span class="hljs-keyword">struct</span> uart_port *, <span class="hljs-keyword">struct</span> ktermios *new, <span class="hljs-keyword">struct</span> ktermios *old); <span class="hljs-comment">/* 设置串口参数 */</span><br>  <span class="hljs-type">void</span>         (*pm)(<span class="hljs-keyword">struct</span> uart_port *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state,<br>           <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> oldstate); <span class="hljs-comment">/* 串口电源管理 */</span><br>  <span class="hljs-type">int</span>          (*set_wake)(<span class="hljs-keyword">struct</span> uart_port *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state); <span class="hljs-comment">/*  */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>  *(*type)(<span class="hljs-keyword">struct</span> uart_port *); <span class="hljs-comment">/* 返回一描述串口类型的字符串 */</span><br>  <span class="hljs-type">void</span>         (*release_port)(<span class="hljs-keyword">struct</span> uart_port *); <span class="hljs-comment">/* 释放串口已申请的IO端口/IO内存资源,必要时还需iounmap */</span><br>  <span class="hljs-type">int</span>          (*request_port)(<span class="hljs-keyword">struct</span> uart_port *); <span class="hljs-comment">/* 申请必要的IO端口/IO内存资源,必要时还可以重新映射串口端口 */</span><br>  <span class="hljs-type">void</span>         (*config_port)(<span class="hljs-keyword">struct</span> uart_port *, <span class="hljs-type">int</span>); <span class="hljs-comment">/* 执行串口所需的自动配置 */</span><br>  <span class="hljs-type">int</span>          (*verify_port)(<span class="hljs-keyword">struct</span> uart_port *, <span class="hljs-keyword">struct</span> serial_struct *); <span class="hljs-comment">/* 核实新串口的信息 */</span><br>  <span class="hljs-type">int</span>          (*ioctl)(<span class="hljs-keyword">struct</span> uart_port *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>); <span class="hljs-comment">/* IO控制 */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>tty_driver是在register过程中构建的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> &#123;</span><br>  <span class="hljs-type">int</span>     magic;          <span class="hljs-comment">/* magic number for this structure */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span> <span class="hljs-title">kref</span>;</span>       <span class="hljs-comment">/* Reference management */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> **<span class="hljs-title">cdevs</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span>   *<span class="hljs-title">owner</span>;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>      *driver_name;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>      *name;<br>  <span class="hljs-type">int</span>     name_base;      <span class="hljs-comment">/* offset of printed name */</span><br>  <span class="hljs-type">int</span>     major;          <span class="hljs-comment">/* major device number */</span><br>  <span class="hljs-type">int</span>     minor_start;    <span class="hljs-comment">/* start of minor device number */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    num;    <span class="hljs-comment">/* number of devices allocated */</span><br>  <span class="hljs-type">short</span>   type;           <span class="hljs-comment">/* type of tty driver */</span><br>  <span class="hljs-type">short</span>   subtype;        <span class="hljs-comment">/* subtype of tty driver */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ktermios</span> <span class="hljs-title">init_termios</span>;</span> <span class="hljs-comment">/* Initial termios */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   flags;          <span class="hljs-comment">/* tty driver flags */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_dir_entry</span> *<span class="hljs-title">proc_entry</span>;</span> <span class="hljs-comment">/* /proc fs entry */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">other</span>;</span> <span class="hljs-comment">/* only used for the PTY driver */</span><br><br>  <span class="hljs-comment">//Pointer to the tty data structures</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> **<span class="hljs-title">ttys</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_port</span> **<span class="hljs-title">ports</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ktermios</span> **<span class="hljs-title">termios</span>;</span><br>  <span class="hljs-type">void</span> *driver_state;<br><br>  <span class="hljs-comment">//Driver methods</span><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_operations</span> *<span class="hljs-title">ops</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tty_drivers</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>tty_operations提供操作函数，供用户空间调用</li><li>将tty_driver构建完成后 通过tty_regoster_driver注册到tty_core中</li></ul></li></ul><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>arm64指令集-加载与储存</title>
    <link href="/2022/11/21/arm64%E6%8C%87%E4%BB%A4%E9%9B%86-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%82%A8%E5%AD%98%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/11/21/arm64%E6%8C%87%E4%BB%A4%E9%9B%86-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%82%A8%E5%AD%98%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<div align="center"><h1 id="加载与储存指令"><a href="#加载与储存指令" class="headerlink" title="加载与储存指令"></a>加载与储存指令</h1></div><h2 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h2><ul><li>常见内存加载指令是LDR指令，储存指令是STR指令，基本格式如下：<ul><li>LDR 目标寄存器，&lt;存储器地址&gt;   &#x2F;&#x2F;把存储器地址中的数据加载到目标寄存器中</li><li>STR 源寄存器，&lt;存储器地址&gt;     &#x2F;&#x2F;把源寄存器中的数据存储到存储器地址中</li></ul></li><li>加载和存储指令的寻址模式：</li></ul><table><thead><tr><th align="center">寻址模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">基地址模式</td><td align="center">[Xn]</td></tr><tr><td align="center">基地址加偏移量模式</td><td align="center">[Xn,#offset]</td></tr><tr><td align="center">前变基模式</td><td align="center">[Xn,#offset]!</td></tr><tr><td align="center">后变基模式</td><td align="center">[Xn],#offset</td></tr><tr><td align="center">PC相对地址模式</td><td align="center">&lt; label &gt;</td></tr></tbody></table><ol><li>基地址模式<ul><li>LDR Xt,[Xn]  &#x2F;&#x2F;以Xn寄存器中的数据作为内存地址，加载此地址中的数据到Xt寄存器</li><li>STR Xt,[Xn]  &#x2F;&#x2F;以Xn寄存器中的数据作为内存地址，将Xt中的内容存储到此内存地址中</li></ul></li><li>基地址加偏移量模式<ul><li>LDR Xt,[Xn,#offset] &#x2F;&#x2F;以Xn寄存器中的数据加上offset的值作为一个内存地址，加载此地址中的数据到Xt寄存器</li><li>STR Xt,[Xn,#offset] &#x2F;&#x2F;以Xn寄存器中的数据加上offset的值作为一个内存地址，将Xt中的内容存储到此内存地址中</li></ul></li><li>基地址扩展模式<ul><li>LDR &lt; Xt &gt;, [&lt; Xn &gt;,(&lt; Xm &gt;){,&lt; extend &gt;{&lt; amount &gt;}}]</li><li>STR &lt; Xt &gt;, [&lt; Xn &gt;,(&lt; Xm &gt;){,&lt; extend &gt;{&lt; amount &gt;}}]<ul><li>Xt：目标寄存器</li><li>Xn：基地址寄存器</li><li>Xm：表示偏移的寄存器</li><li>extend：扩展&#x2F;移位指示符，默认LSL，可选LSL、UXTW、SXTW、SXTX</li><li>amount：索引偏移量，只能为#0或者#3</li></ul></li><li>LDR X0, [X1, X2]  &#x2F;&#x2F;内存地址为X1的值加上X2的值，将此内存地址中的值加载到X0寄存器</li><li>LDR X0, [X1, X2, LSL #3]  &#x2F;&#x2F;内存地址为X1的值加上（X2的值&lt;&lt;3），将此内存地址中的值加载到X0寄存器</li><li>LDR X0, [X1, W2 SXTW]  &#x2F;&#x2F;先对W2中的值做有符号扩展，再和X1的值相加，结果作为内存地址，将此内存地址中的值加载到X0寄存器</li></ul></li><li>前变基模式<ul><li>LDR &lt; Xt &gt;,[&lt; Xn &gt;, #&lt; simm &gt;]!  &#x2F;&#x2F;先更新Xn寄存器的值为Xn寄存器的值加simm，然后以新的Xn寄存器的值作为地址，加载该地址的数据到Xt寄存器</li></ul></li><li>后变基模式<ul><li>LDR &lt; Xt &gt;,[&lt; Xn &gt;], #&lt; simm &gt; &#x2F;&#x2F;首先以Xn寄存器的值作为地址，加载该地址的数据到Xt寄存器，然后更新Xn寄存器的值为Xn寄存器的值加simm</li></ul></li><li>PC相对地址模式<ul><li>LDR &lt; Xt &gt;, &lt; label &gt; &#x2F;&#x2F;读取label所在内存地址的内容到Xt寄存器中，label地址必须在当前PC前后1M的地址范围内</li><li>&#96;&#96;&#96;s<br>my_data:<br>    .word 0x40<br>ldr x0, my_data<br>&#x2F;&#x2F;将my_data标签中的数据0x40载入x0寄存器<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">-    ```s<br>     <span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_LABEL 0x20</span><br>     ldr x6, MY_LABEL<br>     <span class="hljs-comment">//以当前PC的值加上0x20作为内存地址，将此地址中的值载入x6寄存器中</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="出栈与入栈"><a href="#出栈与入栈" class="headerlink" title="出栈与入栈"></a>出栈与入栈</h2><p>armv8取消了push与pop指令，使用ldr和str指令完成出入栈的操作</p><ul><li>入栈<ul><li>str x29,[sp,#-8]!</li><li>前变基 首先sp的值减8，栈空间是向下增长，也就是新增8byte的栈空间，然后将x29的值写入当前sp指针指向的地址处，也就是栈顶</li></ul></li><li>出栈<ul><li>ldr x29,[sp],#8</li><li>后变基 首先将sp的值指向的内存中的数据存入x29，然后sp的值加8，也就是释放8byte的栈空间</li></ul></li></ul><h2 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h2><blockquote><p>mov指令用于寄存器之间的搬移和立即数搬移</p></blockquote><ul><li><p>mov &lt; Xd &gt;, &lt; Xn &gt;</p></li><li><p>mov &lt; Xd &gt;, #&lt; imm &gt;</p><ul><li>立即数只能为16位的立即数或者16位立即数左移16位、32位、48位后的立即数</li></ul><!--PC版--></li></ul><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Arm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>armv8体系结构基础</title>
    <link href="/2022/11/21/armv8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/11/21/armv8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<div align="center"><h1 id="ARMv8体系结构基础"><a href="#ARMv8体系结构基础" class="headerlink" title="ARMv8体系结构基础"></a>ARMv8体系结构基础</h1></div><p>armv8是arm公司发布的第一代支持64位处理器的指令集和体系结构，且能够兼容上一代体系结构指令集，一次可以运行32位应用程序和64位应用程序。</p><h2 id="armv8体系结构中的基本概念"><a href="#armv8体系结构中的基本概念" class="headerlink" title="armv8体系结构中的基本概念"></a>armv8体系结构中的基本概念</h2><ul><li><strong>处理机</strong>：处理器处理事务的过程称为处理机（PE-process element）</li><li><strong>执行状态</strong>：处理器运行时的环境，包括寄存器的位宽、支持的指令集、异常模型、内存管理以及编程模型等，armv8定义了两种执行状态：<ol><li>AArch64：64位的执行状态<ul><li>提供31个64位通用寄存器</li><li>提供64位的PC、SP、ELR（异常链接寄存器）</li><li>支持A64指令集</li><li>定义armv8异常模型，支持4个异常等级EL0-EL3</li><li>提供64位内存模型</li><li>定义一组处理器状态PSTATE用来保存PE的状态</li></ul></li><li>AArch32：32位执行状态<ul><li>提供13个32位通用寄存器，再加上PC、SP、LR寄存器</li><li>支持A32和T32指令集</li><li>支持armv7-a异常模型，基于PE模式并映射到armv8异常模型中</li><li>提供32位虚拟内存访问机制</li><li>定义一组处理器状态PSTATE用来保存PE的状态</li></ul></li></ol></li><li>系统寄存器的命名：在AArch64状态下，很多系统寄存器会根据不同的异常等级提供不同的变种寄存器，使用方法如下：<ul><li><register_name>_Elx (x&#x3D;0&#x2F;1&#x2F;2&#x2F;3带表不同的异常等级)</li></ul></li></ul><h2 id="armv8异常等级"><a href="#armv8异常等级" class="headerlink" title="armv8异常等级"></a>armv8异常等级</h2><table><thead><tr><th align="center">等级</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">EL0</td><td align="center">用户特权，用于运行普通的用户程序</td></tr><tr><td align="center">EL1</td><td align="center">系统特权，用于操作系统内核，如果使能了虚拟化扩展，运行虚拟机系统内核</td></tr><tr><td align="center">EL2</td><td align="center">运行虚拟化扩展的虚拟机监控器（hypervisor）</td></tr><tr><td align="center">EL3</td><td align="center">运行安全世界中的安全监控器(secure monitor)</td></tr></tbody></table><h2 id="armv8寄存器-AArch64"><a href="#armv8寄存器-AArch64" class="headerlink" title="armv8寄存器(AArch64)"></a>armv8寄存器(AArch64)</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><ul><li>31个通用寄存器：X0-X30</li><li>W表示低32位数据，W0表示X0低32位</li><li>X0-X7:用于传递参数和结果</li><li>X8：用于返回结果</li><li>X9-X15：caller save register，易失寄存器，子函数使用这些寄存器时无需save&#x2F;restore，如果需要下次使用的话，由子函数的caller保存这些参数</li><li>X16-X18：平台寄存器</li><li>X19-X28：callee save register，非易失寄存器，子函数使用这些寄存器时需要save&#x2F;restore</li><li>X29：栈帧指针寄存器(FP)</li><li>X30：链接寄存器(LR)</li></ul><h3 id="PSTATE寄存器"><a href="#PSTATE寄存器" class="headerlink" title="PSTATE寄存器"></a>PSTATE寄存器</h3><p>使用PSTATE寄存器表示当前处理器状态，类似armv7中的cpsr寄存器，根据各个字段的功能可将PSTATE寄存器的分割为下面几类：</p><ul><li>条件标志位：N、Z、C、V分别表示负数标志位、0标志位、进位标志位、有符号溢出标志位</li><li>执行状态控制：<ul><li>nRW：0-处于AArch64状态，1-处于AArch32状态</li><li>EL：表示当前异常等级，0-3分别表示EL0-EL-3</li><li>SP：选择SP寄存器，0-SP_EL0, 1-SP_ELn</li></ul></li><li>异常掩码标志位：<ul><li>A：用来屏蔽系统错误</li><li>I：用来屏蔽IRQ</li><li>F：用来屏蔽FIQ</li></ul></li></ul><h3 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h3><h4 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h4><ul><li>通常用来指向当前运行指令的下一条指令地址，与流水线模式有关，无法通过指令直接访问此寄存器</li></ul><h4 id="SP寄存器"><a href="#SP寄存器" class="headerlink" title="SP寄存器"></a>SP寄存器</h4><ul><li>4个异常等级每个异常等级都有一个专门的SP寄存器即SP_ELn</li><li>异常等级高于EL0时，处理器也可以访问SP_EL0寄存器作为一个临时寄存器，如linux内核中使用该寄存器作为进程中task_struct数据结构的指针</li><li>异常等级处于EL0时，只能访问SP_EL0，无法访问更高等级的SP</li></ul><h4 id="备份程序状态寄存器SPSR"><a href="#备份程序状态寄存器SPSR" class="headerlink" title="备份程序状态寄存器SPSR"></a>备份程序状态寄存器SPSR</h4><ul><li>异常发生时，处理器会将PSTATE寄存器中的值备份在SPSR寄存器中，异常处理完成并返回时，再从SPSR寄存器中回复PSTATE寄存器</li></ul><h4 id="ELR寄存器"><a href="#ELR寄存器" class="headerlink" title="ELR寄存器"></a>ELR寄存器</h4><ul><li>存放异常返回的地址</li></ul><h4 id="CurrentEL寄存器"><a href="#CurrentEL寄存器" class="headerlink" title="CurrentEL寄存器"></a>CurrentEL寄存器</h4><ul><li>表示PSTATE寄存器中的EL字段，即当前的异常等级，使用MRS指令可以读取当前异常等级</li></ul><h4 id="DAIF寄存器"><a href="#DAIF寄存器" class="headerlink" title="DAIF寄存器"></a>DAIF寄存器</h4><ul><li>表示PSTATE寄存器中的异常掩码标志位D、A、I、F</li></ul><h4 id="SPSel寄存器"><a href="#SPSel寄存器" class="headerlink" title="SPSel寄存器"></a>SPSel寄存器</h4><ul><li>表示PSTATE寄存器中的SP字段，用于选择SP寄存器</li></ul><h3 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h3><p>7类系统寄存器代替armv7中的cp15协处理器</p><ol><li>通用系统控制寄存器</li><li>调试寄存器</li><li>性能监控寄存器</li><li>活动监控寄存器</li><li>统计扩展寄存器</li><li>RAS寄存器</li><li>通用定时器寄存器</li></ol><ul><li><p>系统寄存器支持不同异常等级的访问，通常系统寄存器会使用Reg_ELn的方式表示：</p></li><li><p>处理器处于高异常等级时可以访问低异常等级的系统寄存器</p></li><li><p>大部分系统寄存器不支持处理器处于EL0等级时访问</p></li><li><p>通过MSR和MRS访问系统寄存器</p><ul><li>mrs 目标 源   -&gt; 从源（系统寄存器）中读取数据存放到目标中</li><li>msr 目标 源   -&gt; 从源中读取数据写入目标（系统寄存器）中</li></ul><!--PC版--></li></ul><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Arm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32mp157_drm驱动源码分析</title>
    <link href="/2022/10/24/stm32mp157_drm%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/"/>
    <url>/2022/10/24/stm32mp157_drm%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<div align="center">### stm32mp157_drm驱动源码分析</div><blockquote><p>stm32mp1系列出厂SDK中自带LTDC接口驱动，用于连接RGB LCD，对其驱动源码分析如下。</p></blockquote><ol><li><p>从其设备树文件中找出LTDC对应的节点：&lt;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;stm32mp151.dtsi&gt;，stm32mp1系列共有的LTDC节点：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">ltdc:</span> <span class="hljs-title class_">display-controller@5a001000</span> <span class="hljs-punctuation">&#123;</span> <br> <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;st,stm32-ltdc&quot;</span><span class="hljs-punctuation">;</span> <br> <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x5a001000</span> <span class="hljs-number">0x400</span>&gt;</span><span class="hljs-punctuation">;</span> <br> <span class="hljs-attr">interrupts</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;GIC_SPI <span class="hljs-number">88</span> IRQ_TYPE_LEVEL_HIGH&gt;</span>, <br>             <span class="hljs-params">&lt;GIC_SPI <span class="hljs-number">89</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="hljs-punctuation">;</span><br> <span class="hljs-attr">clocks</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;rcc</span> LTDC_PX&gt;</span><span class="hljs-punctuation">;</span><br> <span class="hljs-attr">clock-names</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lcd&quot;</span><span class="hljs-punctuation">;</span><br> <span class="hljs-attr">resets</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;rcc</span> LTDC_R&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-number">1660</span> <span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">;</span> <span class="hljs-number">1661</span> <span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><ul><li>compatible属性：”st,stm32-ltdc”,在源码中检索此字符串，找到驱动源码</li></ul></li><li><p>DRM驱动源码：&lt;drivers&#x2F;gpu&#x2F;drm&#x2F;stm&#x2F;drv.c&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">drv_dt_ids</span>[] =</span> &#123;<br>     &#123; .compatible = <span class="hljs-string">&quot;st,stm32-ltdc&quot;</span>&#125;,<br>     &#123; <span class="hljs-comment">/* end node */</span> &#125;,<br> &#125;;<br> MODULE_DEVICE_TABLE(of, drv_dt_ids);<br><br> <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">stm_drm_platform_driver</span> =</span> &#123;<br>     .probe = stm_drm_platform_probe,<br>     .remove = stm_drm_platform_remove,<br>     .driver = &#123;<br>         .name = <span class="hljs-string">&quot;stm32-display&quot;</span>,<br>         .of_match_table = drv_dt_ids,<br>         .pm = &amp;drv_pm_ops,     <span class="hljs-comment">//power manage</span><br>     &#125;,<br> &#125;;<br></code></pre></td></tr></table></figure><ul><li>标准platform总线驱动，与设备树中LTDC接口匹配</li><li>匹配成功后执行probe函数</li></ul></li><li><p>stm_drm_platform_probe函数源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">stm_drm_platform_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;pdev-&gt;dev;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_device</span> *<span class="hljs-title">ddev</span>;</span>          <span class="hljs-comment">//drm设备</span><br>    <span class="hljs-type">int</span> ret;<br><br>    DRM_DEBUG(<span class="hljs-string">&quot;%s\n&quot;</span>, __func__);<br><br>    dma_set_coherent_mask(dev, DMA_BIT_MASK(<span class="hljs-number">32</span>));  <span class="hljs-comment">//DMA内存映射相关</span><br><br>    ddev = drm_dev_alloc(&amp;drv_driver, dev);    <span class="hljs-comment">//为drm设备分配内存，将drm设备与驱动绑定并完成初始化工作</span><br><br>    <span class="hljs-keyword">if</span> (IS_ERR(ddev))<br>        <span class="hljs-keyword">return</span> PTR_ERR(ddev);<br><br>    ret = drv_load(ddev);     <span class="hljs-comment">//完成KMS的相关初始化工作 这是一个st自己封装的函数，下详解</span><br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">goto</span> err_put;<br><br>    ret = drm_dev_register(ddev, <span class="hljs-number">0</span>);  <span class="hljs-comment">//将drm dev注册进drm core</span><br>    <span class="hljs-keyword">if</span> (ret)<br>        <span class="hljs-keyword">goto</span> err_put;<br><br>    drm_fbdev_generic_setup(ddev, <span class="hljs-number">16</span>);   <span class="hljs-comment">//设置prefer bpp</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    err_put:<br>    drm_dev_put(ddev);<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>drm_dev_alloc函数：   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> drm_device *<span class="hljs-title function_">drm_dev_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_driver *driver, <span class="hljs-keyword">struct</span> device *parent)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_device</span> *<span class="hljs-title">dev</span>;</span><br>    <span class="hljs-type">int</span> ret;<br><br>    dev = kzalloc(<span class="hljs-keyword">sizeof</span>(*dev), GFP_KERNEL);   <span class="hljs-comment">//分配内存</span><br>    <span class="hljs-keyword">if</span> (!dev)<br>        <span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br>    ret = drm_dev_init(dev, driver, parent);  <span class="hljs-comment">//初始化drm_dev设备，此函数会使drm_device结构体下的driver成员变量指向drm_driver</span><br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        kfree(dev);<br>        <span class="hljs-keyword">return</span> ERR_PTR(ret);<br>&#125;<br><br><span class="hljs-keyword">return</span> dev;         <span class="hljs-comment">//返回drm_dev结构体指针</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>drv_load函数解析：   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">drv_load</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_device *ddev)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">pdev</span> =</span> to_platform_device(ddev-&gt;dev);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ltdc_device</span> *<span class="hljs-title">ldev</span>;</span><br><span class="hljs-type">int</span> ret;<br><br>DRM_DEBUG(<span class="hljs-string">&quot;%s\n&quot;</span>, __func__);<br><br>ldev = devm_kzalloc(ddev-&gt;dev, <span class="hljs-keyword">sizeof</span>(*ldev), GFP_KERNEL);  <span class="hljs-comment">//为ltdc设备申请内存</span><br><span class="hljs-keyword">if</span> (!ldev)<br>    <span class="hljs-keyword">return</span> -ENOMEM;<br><br>ddev-&gt;dev_private = (<span class="hljs-type">void</span> *)ldev;<br><br>drm_mode_config_init(ddev);  <span class="hljs-comment">//创建一些全局数据结构 包括standard properties</span><br><br><span class="hljs-comment">//设置宽度和高度，在调用drm_mode_addbf()函数时限制framebuffer的size，</span><br>ddev-&gt;mode_config.min_width = <span class="hljs-number">0</span>;<br>ddev-&gt;mode_config.min_height = <span class="hljs-number">0</span>;<br>ddev-&gt;mode_config.max_width = STM_MAX_FB_WIDTH;<br>ddev-&gt;mode_config.max_height = STM_MAX_FB_HEIGHT;<br><br>ddev-&gt;mode_config.funcs = &amp;drv_mode_config_funcs;   <span class="hljs-comment">//设置mode config回调函数结构体 struct drm_mode_config_funcs&#123;...&#125;;</span><br><br>ret = ltdc_load(ddev);<br><span class="hljs-keyword">if</span> (ret)<br>    <span class="hljs-keyword">goto</span> err;<br><br>drm_mode_config_reset(ddev);<br>drm_kms_helper_poll_init(ddev);<br><br>platform_set_drvdata(pdev, ddev);   <span class="hljs-comment">//将ddev设置为platform_dev-&gt;dev的私有数据</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>err:<br>drm_mode_config_cleanup(ddev);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ltdc_load函数解析<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ltdc_load</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_device *ddev)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> *<span class="hljs-title">pdev</span> =</span> to_platform_device(ddev-&gt;dev);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ltdc_device</span> *<span class="hljs-title">ldev</span> =</span> ddev-&gt;dev_private;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> ddev-&gt;dev;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span> =</span> dev-&gt;of_node;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_bridge</span> *<span class="hljs-title">bridge</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_panel</span> *<span class="hljs-title">panel</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc</span> *<span class="hljs-title">crtc</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reset_control</span> *<span class="hljs-title">rstc</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">res</span>;</span><br>    <span class="hljs-type">int</span> irq, i, nb_endpoints;<br>    <span class="hljs-type">int</span> ret = -ENODEV;<br><br>    DRM_DEBUG_DRIVER(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    nb_endpoints = of_graph_get_endpoint_count(np);    <span class="hljs-comment">//实际上在property.c中定义的,获取节点的num</span><br>    <span class="hljs-keyword">if</span> (!nb_endpoints)<br>        <span class="hljs-keyword">return</span> -ENODEV;<br><br>    ldev-&gt;pixel_clk = devm_clk_get(dev, <span class="hljs-string">&quot;lcd&quot;</span>);       <span class="hljs-comment">//通过设备树中的clock-names获取ltdc-px clock，&quot;lcd&quot;为设备树中该属性的名字</span><br>    <span class="hljs-keyword">if</span> (IS_ERR(ldev-&gt;pixel_clk)) &#123;<br>        <span class="hljs-keyword">if</span> (PTR_ERR(ldev-&gt;pixel_clk) != -EPROBE_DEFER)<br>            DRM_ERROR(<span class="hljs-string">&quot;Unable to get lcd clock\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> PTR_ERR(ldev-&gt;pixel_clk);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (clk_prepare_enable(ldev-&gt;pixel_clk)) &#123;        <span class="hljs-comment">//enable clk</span><br>        DRM_ERROR(<span class="hljs-string">&quot;Unable to prepare pixel clock\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -ENODEV;<br>    &#125;<br><br>    <span class="hljs-comment">/* Get endpoints if any */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nb_endpoints; i++) &#123;            <br>        ret = drm_of_find_panel_or_bridge(np, <span class="hljs-number">0</span>, i, &amp;panel, &amp;bridge);<br><br>        <span class="hljs-keyword">if</span> (ret == -ENODEV)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret)<br>            <span class="hljs-keyword">goto</span> err;<br><br>        <span class="hljs-keyword">if</span> (panel) &#123;      <span class="hljs-comment">//panel在panel-simple.c中完成定义</span><br>            bridge = drm_panel_bridge_add(panel, DRM_MODE_CONNECTOR_DPI);  <span class="hljs-comment">//Creates a &amp;drm_bridge and &amp;drm_connector that just calls the appropriate functions from &amp;drm_panel.</span><br>            <span class="hljs-keyword">if</span> (IS_ERR(bridge)) &#123;<br>                DRM_ERROR(<span class="hljs-string">&quot;panel-bridge endpoint %d\n&quot;</span>, i);<br>                ret = PTR_ERR(bridge);<br>                <span class="hljs-keyword">goto</span> err;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (bridge) &#123;<br>            ret = ltdc_encoder_init(ddev, bridge);    <span class="hljs-comment">//encoder的创建和初始化 并且attach encoder and bridge</span><br>            <span class="hljs-keyword">if</span> (ret) &#123;<br>                DRM_ERROR(<span class="hljs-string">&quot;init encoder endpoint %d\n&quot;</span>, i);<br>                <span class="hljs-keyword">goto</span> err;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    rstc = devm_reset_control_get_exclusive(dev, <span class="hljs-literal">NULL</span>);<br><br>    mutex_init(&amp;ldev-&gt;err_lock);<br><br>    <span class="hljs-keyword">if</span> (!IS_ERR(rstc)) &#123;<br>        reset_control_assert(rstc);<br>        usleep_range(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        reset_control_deassert(rstc);<br>    &#125;<br><br>    res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number">0</span>);    <span class="hljs-comment">//获取ltdc的mem资源</span><br>    ldev-&gt;regs = devm_ioremap_resource(dev, res);            <span class="hljs-comment">//remap 得到base</span><br>    <span class="hljs-keyword">if</span> (IS_ERR(ldev-&gt;regs)) &#123;<br>        DRM_ERROR(<span class="hljs-string">&quot;Unable to get ltdc registers\n&quot;</span>);<br>        ret = PTR_ERR(ldev-&gt;regs);<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    reg_clear(ldev-&gt;regs, LTDC_IER, IER_LIE | IER_RRIE | IER_FUIE | IER_TERRIE);  <span class="hljs-comment">//关闭ltdc中断</span><br><br>    ret = ltdc_get_caps(ddev);<br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        DRM_ERROR(<span class="hljs-string">&quot;hardware identifier (0x%08x) not supported!\n&quot;</span>, ldev-&gt;caps.hw_version);<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    DRM_DEBUG_DRIVER(<span class="hljs-string">&quot;ltdc hw version 0x%08x\n&quot;</span>, ldev-&gt;caps.hw_version);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ldev-&gt;caps.nb_irq; i++) &#123;<br>        irq = platform_get_irq(pdev, i);       <span class="hljs-comment">//获取中断号</span><br>        <span class="hljs-keyword">if</span> (irq &lt; <span class="hljs-number">0</span>) &#123;<br>            ret = irq;<br>            <span class="hljs-keyword">goto</span> err;<br>        &#125;<br><br>        ret = devm_request_threaded_irq(dev, irq, ltdc_irq, ltdc_irq_thread, IRQF_ONESHOT, dev_name(dev), ddev);  <span class="hljs-comment">//申请中断</span><br>        <span class="hljs-keyword">if</span> (ret) &#123;<br>            DRM_ERROR(<span class="hljs-string">&quot;Failed to register LTDC interrupt\n&quot;</span>);<br>            <span class="hljs-keyword">goto</span> err;<br>        &#125;<br><br>    &#125;<br><br>    crtc = devm_kzalloc(dev, <span class="hljs-keyword">sizeof</span>(*crtc), GFP_KERNEL);<br>    <span class="hljs-keyword">if</span> (!crtc) &#123;<br>        DRM_ERROR(<span class="hljs-string">&quot;Failed to allocate crtc\n&quot;</span>);<br>        ret = -ENOMEM;<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    ddev-&gt;mode_config.allow_fb_modifiers = <span class="hljs-literal">true</span>;<br><br>    ret = ltdc_crtc_init(ddev, crtc);       <span class="hljs-comment">//plane 和 crtc的创建和初始化</span><br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        DRM_ERROR(<span class="hljs-string">&quot;Failed to init crtc\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    ret = drm_vblank_init(ddev, NB_CRTC);  <span class="hljs-comment">//initialize vblank support</span><br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        DRM_ERROR(<span class="hljs-string">&quot;Failed calling drm_vblank_init()\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    <span class="hljs-comment">/* Allow usage of vblank without having to call drm_irq_install */</span><br>    ddev-&gt;irq_enabled = <span class="hljs-number">1</span>;<br><br>    clk_disable_unprepare(ldev-&gt;pixel_clk);<br><br>    pinctrl_pm_select_sleep_state(ddev-&gt;dev);<br><br>    pm_runtime_enable(ddev-&gt;dev);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    err:<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nb_endpoints; i++)<br>        drm_of_panel_bridge_remove(ddev-&gt;dev-&gt;of_node, <span class="hljs-number">0</span>, i);<br><br>    clk_disable_unprepare(ldev-&gt;pixel_clk);<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>panel-simple.c文件解析</p><ul><li>数据结构   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">panel_simple</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_panel</span> <span class="hljs-title">base</span>;</span>   <span class="hljs-comment">//继承的基础数据结构</span><br>    <span class="hljs-type">bool</span> prepared;<br>    <span class="hljs-type">bool</span> enabled;<br>    <span class="hljs-type">bool</span> no_hpd;<br><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">panel_desc</span> *<span class="hljs-title">desc</span>;</span>  <span class="hljs-comment">//panel describe</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">backlight_device</span> *<span class="hljs-title">backlight</span>;</span>  <span class="hljs-comment">//背光</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">regulator</span> *<span class="hljs-title">supply</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_adapter</span> *<span class="hljs-title">ddc</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gpio_desc</span> *<span class="hljs-title">enable_gpio</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_display_mode</span> <span class="hljs-title">override_mode</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>struct drm_panel base  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_panel</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_device</span> *<span class="hljs-title">drm</span>;</span>  <span class="hljs-comment">//拥有此panel的drm_dev</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector</span> *<span class="hljs-title">connector</span>;</span>  <span class="hljs-comment">//connector attached to the panel</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span>  <span class="hljs-comment">//parent device</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_panel_funcs</span> *<span class="hljs-title">funcs</span>;</span>   <span class="hljs-comment">//panel的操作函数集</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>struct panel_desc *desc   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">panel_desc</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_display_mode</span> *<span class="hljs-title">modes</span>;</span>  <span class="hljs-comment">//指向一个适合此panel的mode array,设置屏幕参数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_modes;                <span class="hljs-comment">//size of mode array</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">display_timing</span> *<span class="hljs-title">timings</span>;</span>  <span class="hljs-comment">//指向一个timing array</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_timings;              <span class="hljs-comment">//size of timing array</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bpc;                      <span class="hljs-comment">// bits/color</span><br>    <span class="hljs-comment">/*屏幕大小 单位为毫米*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> width;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> height;<br>    &#125; size;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prepare;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hpd_absent_delay;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> enable;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> disable;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unprepare;<br>    &#125; delay;<br><br>    u32 bus_format;  <span class="hljs-comment">//See MEDIA_BUS_FMT_... defines.</span><br>    u32 bus_flags;   <span class="hljs-comment">//See DRM_BUS_FLAG_... defines.</span><br></code></pre></td></tr></table></figure></li></ul></li><li>代码分析</li></ul><blockquote><p>panel-simple也是一个标准的platform总线驱动</p></blockquote><p> -<br>     <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">panel_simple_platform_driver</span> =</span> &#123;<br>    .driver = &#123;<br>        .name = <span class="hljs-string">&quot;panel-simple&quot;</span>,<br>        .of_match_table = platform_of_match,<br>    &#125;,<br>    .probe = panel_simple_platform_probe,<br>    .remove = panel_simple_platform_remove,<br>    .shutdown = panel_simple_platform_shutdown,<br>&#125;;<br></code></pre></td></tr></table></figure><br>     - platform_of_match中包含了大量的匹配项用于匹配不同的屏幕设备<br>         <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">platform_of_match</span>[] =</span> &#123;<br>    &#123;<br>        .compatible = <span class="hljs-string">&quot;ampire,am-480272h3tmqw-t01h&quot;</span>,   <span class="hljs-comment">//用于与设备树匹配</span><br>        .data = &amp;ampire_am_480272h3tmqw_t01h,   <span class="hljs-comment">//指向一个panel_desc结构体</span><br>    &#125;,<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><br>     - panel_simple_platform_probe中核心是panel_simple_probe函数，主要完成屏幕设备的参数设置、初始化、注册<br>         <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">panel_simple_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> panel_desc *desc)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">backlight</span>, *<span class="hljs-title">ddc</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">panel_simple</span> *<span class="hljs-title">panel</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">display_timing</span> <span class="hljs-title">dt</span>;</span><br>    <span class="hljs-type">int</span> err;<br><br>    panel = devm_kzalloc(dev, <span class="hljs-keyword">sizeof</span>(*panel), GFP_KERNEL);   <span class="hljs-comment">//为panel开辟内存</span><br>    <span class="hljs-keyword">if</span> (!panel)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br><br>    panel-&gt;enabled = <span class="hljs-literal">false</span>;<br>    panel-&gt;prepared = <span class="hljs-literal">false</span>;<br>    panel-&gt;desc = desc;<br><br>    panel-&gt;no_hpd = of_property_read_bool(dev-&gt;of_node, <span class="hljs-string">&quot;no-hpd&quot;</span>);<br><br>    panel-&gt;supply = devm_regulator_get(dev, <span class="hljs-string">&quot;power&quot;</span>);<br>    <span class="hljs-keyword">if</span> (IS_ERR(panel-&gt;supply))<br>        <span class="hljs-keyword">return</span> PTR_ERR(panel-&gt;supply);<br><br>    panel-&gt;enable_gpio = devm_gpiod_get_optional(dev, <span class="hljs-string">&quot;enable&quot;</span>, GPIOD_OUT_LOW);                          <br>    <span class="hljs-keyword">if</span> (IS_ERR(panel-&gt;enable_gpio)) &#123;<br>        err = PTR_ERR(panel-&gt;enable_gpio);<br>        <span class="hljs-keyword">if</span> (err != -EPROBE_DEFER)<br>            dev_err(dev, <span class="hljs-string">&quot;failed to request GPIO: %d\n&quot;</span>, err);<br>        <span class="hljs-keyword">return</span> err;<br>    &#125;<br><br>    backlight = of_parse_phandle(dev-&gt;of_node, <span class="hljs-string">&quot;backlight&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (backlight) &#123;<br>        panel-&gt;backlight = of_find_backlight_by_node(backlight);<br>        of_node_put(backlight);<br><br>        <span class="hljs-keyword">if</span> (!panel-&gt;backlight)<br>            <span class="hljs-keyword">return</span> -EPROBE_DEFER;<br>    &#125;<br><br>    ddc = of_parse_phandle(dev-&gt;of_node, <span class="hljs-string">&quot;ddc-i2c-bus&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ddc) &#123;<br>        panel-&gt;ddc = of_find_i2c_adapter_by_node(ddc);<br>        of_node_put(ddc);<br><br>        <span class="hljs-keyword">if</span> (!panel-&gt;ddc) &#123;<br>            err = -EPROBE_DEFER;<br>            <span class="hljs-keyword">goto</span> free_backlight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!of_get_display_timing(dev-&gt;of_node, <span class="hljs-string">&quot;panel-timing&quot;</span>, &amp;dt))<br>        panel_simple_parse_panel_timing_node(dev, panel, &amp;dt);<br><br>    drm_panel_init(&amp;panel-&gt;base);<br>    panel-&gt;base.dev = dev;<br>    panel-&gt;base.funcs = &amp;panel_simple_funcs;<br><br>    err = drm_panel_add(&amp;panel-&gt;base);<br>    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> free_ddc;<br><br>    dev_set_drvdata(dev, panel);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>free_ddc:<br>    <span class="hljs-keyword">if</span> (panel-&gt;ddc)<br>        put_device(&amp;panel-&gt;ddc-&gt;dev);<br>free_backlight:<br>    <span class="hljs-keyword">if</span> (panel-&gt;backlight)<br>        put_device(&amp;panel-&gt;backlight-&gt;dev);<br><br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol>  <!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>             ]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
      <category>DRM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DRM应用及驱动浅析</title>
    <link href="/2022/10/21/DRM%E7%BB%BC%E5%90%88/"/>
    <url>/2022/10/21/DRM%E7%BB%BC%E5%90%88/</url>
    
    <content type="html"><![CDATA[<div align="center"><blockquote><p>drm相关函数原型：<a href="https://blog.csdn.net/weixin_42645653/article/details/115486627">https://blog.csdn.net/weixin_42645653/article/details/115486627</a></p><p>参考何小龙老师的博客：<a href="https://blog.csdn.net/hexiaolong2009/article/details/83720940">https://blog.csdn.net/hexiaolong2009/article/details/83720940</a></p></blockquote><h3 id="1-DRM简介"><a href="#1-DRM简介" class="headerlink" title="1.DRM简介"></a>1.DRM简介</h3></div><blockquote><p>DRM 是linux图形显示子系统，主要分为三个部分：</p></blockquote><ol><li>libdrm：for userspace，提供各种API供用户空间使用，主要是对IOCTL函数的封装；</li><li>KMS：kernel mode setting，主要作用是设置参数和控制显示；</li><li>GEM：graphic execution manager，主要做内存管理</li></ol><p>在驱动侧主要工作在和KMS和GEM上，这两个模块又包含以下元素：</p><ul><li>KMS：<ul><li>crtc：对显示buffer进行扫描，并产生时序信号的硬件模块，通常指Display Controller； </li><li>encoder：负责将CRTC输出的timing时序转换成外部设备所需要的信号的模块，如HDMI转换器或DSI Controller；</li><li>connector：连接物理显示设备的连接器，如HDMI、DisplayPort、DSI总线，通常和Encoder驱动绑定在一起；</li><li>plane：硬件图层，有的Display硬件支持多层合成显示，但所有的Display Controller至少要有1个plane；</li><li>framebuffer：Framebuffer，单个图层的显示内容，唯一一个和硬件无关的基本元素；</li><li>vblank：软件和硬件的同步机制，RGB时序中的垂直消影区，软件通常使用硬件VSYNC来实现；</li><li>property：任何你想设置的参数，都可以做成property，是DRM驱动中最灵活、最方便的Mode setting机制；</li></ul></li><li>GEM：<ul><li>dumb：只支持连续物理内存，基于kernel中通用CMA API实现，多用于小分辨率简单场景；</li><li>prime：连续、非连续物理内存都支持，基于DMA-BUF机制，可以实现buffer共享，多用于大内存复杂场景；</li><li>fence：buffer同步机制，基于内核dma_fence机制实现，用于防止显示内容出现异步问题；</li></ul></li></ul><div align="center"><h3 id="2-从最简单的DRM应用程序入手-plane-legacy"><a href="#2-从最简单的DRM应用程序入手-plane-legacy" class="headerlink" title="2.从最简单的DRM应用程序入手(plane) (legacy)"></a>2.从最简单的DRM应用程序入手(plane) (legacy)</h3></div><ul><li><p>什么是plane？</p><blockquote><p>RM中的Plane指的是Display Controller中用于多层合成的单个硬件图层模块，属于硬件层面。plane是连接fb与crtc的纽带，是内存的搬运工。<br>上图：</p></blockquote><p><img src="/images/fb-plane.png" alt="fb-plane"></p><blockquote><p>以framebuffer为图源，利用drmModeSetPlane函数设置plane。</p></blockquote><blockquote><p>当 SRC 与 CRTC 的 X&#x2F;Y 不相等时，则实现了平移的效果；</p></blockquote><blockquote><p>当 SRC 与 CRTC 的 W&#x2F;H 不相等时，则实现了缩放的效果；</p></blockquote><blockquote><p>当 SRC 与 FrameBuffer 的 W&#x2F;H 不相等时，则实现了裁剪的效果；</p></blockquote><ul><li>一个高级plane通常具有如下功能</li></ul><table><thead><tr><th align="center">功能</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">crop</td><td align="center">裁剪 如上图</td></tr><tr><td align="center">scaling</td><td align="center">缩放 放大或者缩小</td></tr><tr><td align="center">rotation</td><td align="center">旋转 90 180 270 X&#x2F;Y镜像</td></tr><tr><td align="center">z-order</td><td align="center">z-顺序 调整当前plane在所有图层中的顺序</td></tr><tr><td align="center">blending</td><td align="center">合成 pixel alpha&#x2F;global alpha</td></tr><tr><td align="center">format</td><td align="center">颜色格式,ARGB888 XRGB888 YUV240等</td></tr></tbody></table><ul><li>plane的类型</li></ul><table><thead><tr><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">cursor</td><td align="center">光标图层 一般用于pc系统，用于显示鼠标</td></tr><tr><td align="center">overlay</td><td align="center">叠加图层 通常用于YUV格式的视频图层</td></tr><tr><td align="center">primary</td><td align="center">主要图层 通常用于仅支持RGB格式的简单图层</td></tr></tbody></table><blockquote><p>DRM框架规定 任何一个CRTC，必须要有一个primary plane</p></blockquote></li></ul><p>legacy版本的简单plane显示代码流程如下</p><ol><li><p>定义一个buffer_obj:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_object</span> &#123;</span><br><span class="hljs-type">uint32_t</span> width;<br><span class="hljs-type">uint32_t</span> height;<br><span class="hljs-type">uint32_t</span> pitch;<br><span class="hljs-type">uint32_t</span> handle;<br><span class="hljs-type">uint32_t</span> size;<br><span class="hljs-type">uint8_t</span> *vaddr;   <span class="hljs-comment">//物理内存映射后的地址</span><br><span class="hljs-type">uint32_t</span> fb_id;   <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_object</span> <span class="hljs-title">buf</span>;</span><br></code></pre></td></tr></table></figure></li><li><p>打开显示设备<br><code>int fd = open(&quot;/dev/dri/card0&quot;, O_RDWR);</code></p></li><li><p>获取显示资源，包括crtc、encoder和connector信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drmModeRes</span> *<span class="hljs-title">res</span> =</span> drmModeGetResources(fd);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">获取crtc id和connector id，res中包含各个显示元素信息，且crtc和connector可能不止一个</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">uint32_t</span> conn_id = res-&gt;connectors[<span class="hljs-number">0</span>];<br><span class="hljs-type">uint32_t</span> crtc_id = res-&gt;crtcs[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure></li><li><p>获取plane有关设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//必须设置DRM_CLIENT_CAP_UNIVERSAL_PLANES，如果不设置，drmModeGetPlaneResources只会返回verlay plane，如果设置则会返回所有的支持的plane资源</span><br>drmSetClientCap(fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, <span class="hljs-number">1</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drmModePlaneRes</span> *<span class="hljs-title">plane_res</span> =</span> drmModeGetPlaneResources(fd);   <span class="hljs-comment">//获取plane资源列表</span><br><span class="hljs-type">uint32_t</span> plane_id = plane_res-&gt;planes[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure></li><li><p>通过conn_id获取connector，connector中包含显示设备的信息，用显示设备的信息初始化buf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">srmModeConnector</span> *<span class="hljs-title">conn</span> =</span> drmModeGetConnector(fd, conn_id);<br>buf.width = conn-&gt;modes[<span class="hljs-number">0</span>].hdisplay;<br>buf.height = conn-&gt;modes[<span class="hljs-number">0</span>].vdisplay;<br></code></pre></td></tr></table></figure></li><li><p>根据buf创建framebuffer</p><ul><li>(1)根据buf创建一个dumb buf   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_mode_create_dumb</span> <span class="hljs-title">create</span>;</span><br>create.width = buf.width;<br>create.height = buf.height;<br>create.bpp = <span class="hljs-number">32</span>;    <span class="hljs-comment">//bpp-bits per pixel</span><br>drmIoctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;create); <span class="hljs-comment">//为create创建dumb 内存，同时creat得到初始化</span><br></code></pre></td></tr></table></figure></li><li>(2)创建一个framebuffer  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将create初始化后的值反赋给buf</span><br>buf.pitch = create.pitch;<br>buf.size = create.size;<br>buf.handle = create.handle;<br>drmModeAddFB(fd, buf.width, buf.height, <span class="hljs-number">24</span>, <span class="hljs-number">32</span>, buf.pitch, buf.handle, &amp;buf.fb_id);<br></code></pre></td></tr></table></figure></li><li>(3)将dumb buffer映射到userspace  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_mode_map_dumb</span> <span class="hljs-title">map</span>;</span><br>   <span class="hljs-built_in">map</span>.handle = create.handle;<br>drmIoctl(fd, DRM_IOCTL_MODE_MAP_DUMB, &amp;<span class="hljs-built_in">map</span>);   <span class="hljs-comment">//映射一个用于CPU访问的dumb buffer</span><br>buf.vaddr = mmap(<span class="hljs-number">0</span>, create.size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-built_in">map</span>.offset); <span class="hljs-comment">//将dumb buffer映射到用户空间</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>通过映射的内存地址画framebuffer</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memset</span>(buf.vaddr, <span class="hljs-number">0xff</span>, buf.size); <span class="hljs-comment">//画白色</span><br></code></pre></td></tr></table></figure></li><li><p>设置crtc，实现显示framebuffer</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">drmModeSetCrtc(fd, crtc_id, buf.fb_id, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;conn_id, <span class="hljs-number">1</span>, &amp;conn-&gt;modes[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure></li><li><p>从framebuffer(100,150)位置crop一个320x320的plane放到crtc上,显示plane</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">drmModeSetPlane(fd, plane_id, crtc_id, buf.fb_id, <span class="hljs-number">0</span>,<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">320</span>, <span class="hljs-number">320</span>, <span class="hljs-number">100</span> &lt;&lt; <span class="hljs-number">16</span>, <span class="hljs-number">150</span> &lt;&lt; <span class="hljs-number">16</span>, <span class="hljs-number">320</span> &lt;&lt; <span class="hljs-number">16</span>, <span class="hljs-number">320</span> &lt;&lt; <span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>drmModeSetPlane函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">drmModeSetPlane</span> <span class="hljs-params">( <span class="hljs-type">int</span> fd, <span class="hljs-type">uint32_t</span> plane_id, <span class="hljs-type">uint32_t</span> crtc_id, <span class="hljs-type">uint32_t</span> fb_id, <span class="hljs-type">uint32_t</span> flags, <span class="hljs-type">uint32_t</span> crtc_x, <span class="hljs-type">uint32_t</span> crtc_y, <span class="hljs-type">uint32_t</span> crtc_w, <span class="hljs-type">uint32_t</span> crtc_h, <span class="hljs-type">uint32_t</span> src_x, <span class="hljs-type">uint32_t</span> src_y, <span class="hljs-type">uint32_t</span> src_w, <span class="hljs-type">uint32_t</span> src_h )</span><br><span class="hljs-comment">/******</span><br><span class="hljs-comment">     fd:打开的DRM设备的文件描述符。</span><br><span class="hljs-comment">     plane_id:平面需要修改的平面ID。</span><br><span class="hljs-comment">     crtc_id:CRTC该平面所在CRTC的ID。</span><br><span class="hljs-comment">     fb_id:Framebuffer在平面上显示的Framebuffer ID，或-1表示保持Framebuffer不变。</span><br><span class="hljs-comment">     flags:控制函数行为的标志。目前不支持外部使用标志。</span><br><span class="hljs-comment">     crtc_x:从有源显示区域左侧显示平面的偏移量</span><br><span class="hljs-comment">     crtc_y:从有源显示区域顶部到显示平面的偏移量。</span><br><span class="hljs-comment">     crtc_w:显示输出矩形的宽度。</span><br><span class="hljs-comment">     crtc_h:显示输出矩形的高度</span><br><span class="hljs-comment">     src_x:从源framebuffer左侧的剪辑偏移量(Q16.16固定点)。</span><br><span class="hljs-comment">     src_y:来自源framebuffer顶部的剪辑偏移量(Q16.16固定点)。</span><br><span class="hljs-comment">     src_w:源矩形的宽度(Q16.16固定点)。</span><br><span class="hljs-comment">     src_h:源矩形的高度(Q16.16固定点)。</span><br><span class="hljs-comment"> ***/</span><br></code></pre></td></tr></table></figure></li><li><p>完成显示后释放资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">modeset_destroy_fb(fd, &amp;buf);<br>drmModeFreeConnector(conn);<br>drmModeFreePlaneResources(plane_res);<br>drmModeFreeResources(res);<br>close(fd);<br></code></pre></td></tr></table></figure></li></ol><div align="center"><h3 id="3-property简述"><a href="#3-property简述" class="headerlink" title="3.property简述"></a>3.property简述</h3><blockquote><p>property是atomic接口必须依赖的基本元素</p></blockquote></div><ul><li><p>property：</p><ul><li>把legacy接口传入的参数做成一个个独立的全局属性，通过设置这些属性参数，可以完成对显示参数的设置；</li><li>property由name、id、value三部分组成。其中id为该property在DRM框架中唯一的标识符；</li><li>property机制的好处：<ul><li>减少上层应用接口的维护工作量；添加新功能时无需增加新的函数和IOCTL，只需要在底层中新增一个property，然后在应用程序中获取&#x2F;操作property即可；</li><li>增加了参数设置的灵活性；一次IOCTL可以同时设置多个property，减少了usersapce与kernel的切换次数。</li></ul></li></ul></li><li><p>常用的property</p><ul><li>crtc相关</li></ul><table><thead><tr><th align="center">name</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">ACTIVE</td><td align="center">crtc当前的使能状态，一般用于CRTC上下电</td></tr><tr><td align="center">MODE_ID</td><td align="center">crtc当前使用的display mode id，通过该id可以找到具体的display mode参数</td></tr><tr><td align="center">OUT_FENCE_PTR</td><td align="center">输出fence指针，指向当前正在显示的buffer所对应的fence id，该fence由DRM驱动创建，供上层应用使用，用来表示当前buffer crtc是否还在占用</td></tr></tbody></table><ul><li>plane相关</li></ul><table><thead><tr><th align="center">name</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">type</td><td align="center">plane的类型，CURSOR、PRIMARY或者OVERLAY</td></tr><tr><td align="center">FB_ID</td><td align="center">与当前plane绑定的framebuffer object ID</td></tr><tr><td align="center">IN_FENCE_FD</td><td align="center">与当前plane相关联的input fence fd，由buffer的生产者创建，供DRM底层驱动使用，用来标识当前传下来的buffer是否可以开始访问</td></tr><tr><td align="center">CRTC_ID</td><td align="center">当前plane所关联的CRTC object ID，与CONNECTOR中的CRTC_ID属性是同一个property</td></tr><tr><td align="center">SRC_X</td><td align="center">当前framebuffer crop区域的起始偏移x坐标</td></tr><tr><td align="center">SRC_Y</td><td align="center">当前framebuffer crop区域的起始偏移y坐标</td></tr><tr><td align="center">SRC_W</td><td align="center">当前framebuffer crop区域的宽度</td></tr><tr><td align="center">SRC_H</td><td align="center">当前framebuffer crop区域的高度</td></tr><tr><td align="center">CRTC_X</td><td align="center">屏幕显示区域的起始偏移x坐标</td></tr><tr><td align="center">CRTC_Y</td><td align="center">屏幕显示区域的起始偏移y坐标</td></tr><tr><td align="center">CRTC_W</td><td align="center">屏幕显示区域的宽度</td></tr><tr><td align="center">CRTC_H</td><td align="center">屏幕显示区域的高度</td></tr><tr><td align="center">IN_FORMATS</td><td align="center">用于标识特殊的颜色存储格式，如AFBC、IFBC存储格式，该属性为只读</td></tr><tr><td align="center">rotation</td><td align="center">当前图层的旋转角度</td></tr><tr><td align="center">zposition</td><td align="center">当前图层在所有图层中的Z轴顺序</td></tr><tr><td align="center">alpha</td><td align="center">当前图层的global alpha（非pixel alpha），用于多层合成</td></tr><tr><td align="center">pixel blend mode</td><td align="center">当前图层的合成方式，如Pre-multiplied&#x2F;Coverage等</td></tr></tbody></table><ul><li>connector相关</li></ul><table><thead><tr><th align="center">name</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">EDID</td><td align="center">Extended Display Identification Data，标识显示器的参数信息，是一种VESA标准数据格式</td></tr><tr><td align="center">DPMS</td><td align="center">Display Power Management Signaling，用于控制显示器的电源状态，如休眠唤醒。也是一种VESA标准</td></tr><tr><td align="center">link-status</td><td align="center">用于标识当前connector的连接状态，如Good&#x2F;Bad</td></tr><tr><td align="center">CRTC_ID</td><td align="center">当前connector所连接的CRTC object ID，与PLANE中CRTC_ID属性是同一个property</td></tr><tr><td align="center">PATH</td><td align="center">DisplayPort专用的属性，主要用于Multi-Stream Transport (MST) 功能，即多路显示应用场景</td></tr><tr><td align="center">TILE</td><td align="center">用于标识当前connector是否应用于多屏拼接场景，如平时随处可见的多屏拼接显示的广告大屏幕</td></tr></tbody></table></li><li><p>property的类型</p><ul><li><mark>DRM_MODE_PROP_RANGE</mark>：range property会report它们可接受的最大值和最小值范围(unsigned value)，KMS内核验证app设定的值是否符合这个范围。范围属性由drm_property_create_range()函数创建;</li><li><mark>DRM_MODE_PROP_SIGNED_RANGE</mark>：range property会report它们可接受的最大值和最小值范围(signed value)，KMS内核验证app设定的值是否符合这个范围。范围属性由drm_property_create_signed_range()函数创建;</li><li><mark>DRM_MODE_PROP_ENUM</mark>：Enumerated properties(枚举属性)限定一个范围，从0到属性定义的值减1，每个值有一个字符串符号，应用程序可以通过检索值-名称列表，使用数值来获取或者设置属性实例的值。枚举属性由drm_property_create_enum()函数创建；</li><li><mark>DRM_MODE_PROP_BITMASK</mark>：Bitmask properties（位掩码属性），其实就是将所有枚举值范围限定在0-63的枚举值属性，bitmask property的值将属性定义的一个或者多个枚举位组合表示，位掩码属性由drm_property_create_bitmask()函数创建；</li><li><mark>DRM_MODE_PROP_OBJECT</mark>：object property与modeset_object联系，在atomic中广泛使用，通过链接&amp;drm_frmaebuffer和&amp;drm_plane,链接&amp;drm_plane和&amp;drm_crtc，链接&amp;drm_crtc和&amp;drm_connector创建display_pipeline，Object property由drm_property_create_object()函数创建；</li><li><mark>DRM_MODE_PROP_BLOB</mark>：blob property存储一段没有格式限制的二进制blob，它的值表示它链接的blob obj的id，blob property由drm_property_create()函数使用DRM_MODE_PROP_BLOB类型参数创建，带blob数据的blob obj由drm_property_create_blob()创建；</li><li><mark>DRM_MODE_PROP_ATOMIC</mark>：为atomic模式的属性设置，这些属性不会暴露给legacy 用户空间；</li><li><mark>DRM_MODE_PROP_IMMUTABLE</mark>：为用户空间无法改变其值的属性设置，kernel可以改变这些属性的值，通过drm_object_property_set_value()函数；</li></ul></li></ul><div align="center"><h3 id="4-atomic-crtc显示简单示例-property"><a href="#4-atomic-crtc显示简单示例-property" class="headerlink" title="4.atomic-crtc显示简单示例 (property)"></a>4.atomic-crtc显示简单示例 (property)</h3></div><blockquote><p>利用libdrm提供的atomic接口，通过name来获取property，通过id操作property，通过value修改property</p></blockquote><p><mark>第1-6步与legacy plane应用程序中步骤相同</mark></p><ol><li><p>创建buffer</p></li><li><p>获取资源，ctrc、connector、encoder</p></li><li><p>获取plane资源</p></li><li><p>获取connector并且根据其值初始化buffer</p></li><li><p>根据buffer创建framebuffer</p></li><li><p>通过映射的内存地址画framebuffer</p></li><li><p>告知DRM驱动该应用程序支持atomic操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">drmSetClientCap(fd, DRM_CLIENT_CAP_ATOMIC, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取connector properties</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drmModeObjectProperties</span> *<span class="hljs-title">props</span> =</span> drmModeObjectGetProperties(fd, conn_id,DRM_MODE_OBJECT_CONNECTOR);<br><span class="hljs-type">uint32_t</span> property_crtc_id = get_property_id(fd, props, <span class="hljs-string">&quot;CRTC_ID&quot;</span>);  <span class="hljs-comment">//与connector关联的crtc_id</span><br>drmModeFreeObjectProperties(props);    <span class="hljs-comment">//释放props</span><br></code></pre></td></tr></table></figure></li><li><p>获取crtc properties</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">props = drmModeObjectGetProperties(fd, crtc_id, DRM_MODE_OBJECT_CRTC);<br><span class="hljs-type">uint32_t</span> property_active = get_property_id(fd, props, <span class="hljs-string">&quot;ACTIVE&quot;</span>); <span class="hljs-comment">//获取crtc active属性</span><br><span class="hljs-type">uint32_t</span> property_mode_id = get_property_id(fd, props, <span class="hljs-string">&quot;MODE_ID&quot;</span>); <span class="hljs-comment">//获取crtc使用的display mode id</span><br>drmModeFreeObjectProperties(props);  <span class="hljs-comment">//释放props</span><br></code></pre></td></tr></table></figure></li><li><p>创建blob property储存现在的模式，并保存blob id</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> blob_id;<br>drmModeCreatePropertyBlob(fd, &amp;conn-&gt;modes[<span class="hljs-number">0</span>], <span class="hljs-keyword">sizeof</span>(conn-&gt;modes[<span class="hljs-number">0</span>]), &amp;blob_id);<br></code></pre></td></tr></table></figure></li><li><p>mode setting 替代从前的drmModeSetCrtc代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drmModeAtomicReq</span> *<span class="hljs-title">req</span>;</span><br>   req = drmModeAtomicAlloc();  <span class="hljs-comment">//创建atomic请求对象</span><br>drmModeAtomicAddProperty(req, crtc_id, property_active, <span class="hljs-number">1</span>);  <span class="hljs-comment">//设置crtc的property_active值</span><br>drmModeAtomicAddProperty(req, crtc_id, property_mode_id, blob_id);  <span class="hljs-comment">//设置crtc的property_mode_id值</span><br>drmModeAtomicAddProperty(req, conn_id, property_crtc_id, crtc_id);  <span class="hljs-comment">//设置connector的property_crtc_id值</span><br>drmModeAtomicCommit(fd, req, DRM_MODE_ATOMIC_ALLOW_MODESET, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//提交请求</span><br>drmModeAtomicFree(req);  <span class="hljs-comment">//释放请求对象</span><br></code></pre></td></tr></table></figure></li><li><p>从framebuffer(100,150)位置crop一个320x320的plane放到crtc上,显示plane</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">drmModeSetPlane(fd, plane_id, crtc_id, buf.fb_id, <span class="hljs-number">0</span>,<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">320</span>, <span class="hljs-number">320</span>, <span class="hljs-number">100</span> &lt;&lt; <span class="hljs-number">16</span>, <span class="hljs-number">150</span> &lt;&lt; <span class="hljs-number">16</span>, <span class="hljs-number">320</span> &lt;&lt; <span class="hljs-number">16</span>, <span class="hljs-number">320</span> &lt;&lt; <span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure></li><li><p>释放资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">   modeset_destroy_fb(fd, &amp;buf);<br>drmModeFreeConnector(conn);<br>drmModeFreePlaneResources(plane_res);<br>drmModeFreeResources(res);<br>close(fd);<br></code></pre></td></tr></table></figure></li></ol><ul><li>第12步仍然使用的是legacy接口drmModeSetPlane()，现在使用atomic接口替换其功能<ul><li>12.1 获取plane属性<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">props = drmModeObjectGetProperties(fd, plane_id, DRM_MODE_OBJECT_PLANE);<br><span class="hljs-type">uint32_t</span> property_crtc_id = get_property_id(fd, props, <span class="hljs-string">&quot;CRTC_ID&quot;</span>);<br><span class="hljs-type">uint32_t</span> property_fb_id = get_property_id(fd, props, <span class="hljs-string">&quot;FB_ID&quot;</span>);<br><span class="hljs-type">uint32_t</span> property_crtc_x = get_property_id(fd, props, <span class="hljs-string">&quot;CRTC_X&quot;</span>);<br><span class="hljs-type">uint32_t</span> property_crtc_y = get_property_id(fd, props, <span class="hljs-string">&quot;CRTC_Y&quot;</span>);<br><span class="hljs-type">uint32_t</span> property_crtc_w = get_property_id(fd, props, <span class="hljs-string">&quot;CRTC_W&quot;</span>);<br><span class="hljs-type">uint32_t</span> property_crtc_h = get_property_id(fd, props, <span class="hljs-string">&quot;CRTC_H&quot;</span>);<br><span class="hljs-type">uint32_t</span> property_src_x = get_property_id(fd, props, <span class="hljs-string">&quot;SRC_X&quot;</span>);<br><span class="hljs-type">uint32_t</span> property_src_y = get_property_id(fd, props, <span class="hljs-string">&quot;SRC_Y&quot;</span>);<br><span class="hljs-type">uint32_t</span> property_src_w = get_property_id(fd, props, <span class="hljs-string">&quot;SRC_W&quot;</span>);<br><span class="hljs-type">uint32_t</span> property_src_h = get_property_id(fd, props, <span class="hljs-string">&quot;SRC_H&quot;</span>);<br>drmModeFreeObjectProperties(props);<br></code></pre></td></tr></table></figure></li><li>12.2 atomic update plane<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">   req = drmModeAtomicAlloc();<br>drmModeAtomicAddProperty(req, plane_id, property_crtc_id, crtc_id);<br>drmModeAtomicAddProperty(req, plane_id, property_fb_id, buf.fb_id);<br>drmModeAtomicAddProperty(req, plane_id, property_crtc_x, <span class="hljs-number">50</span>);<br>drmModeAtomicAddProperty(req, plane_id, property_crtc_y, <span class="hljs-number">50</span>);<br>drmModeAtomicAddProperty(req, plane_id, property_crtc_w, <span class="hljs-number">320</span>);<br>drmModeAtomicAddProperty(req, plane_id, property_crtc_h, <span class="hljs-number">320</span>);<br>drmModeAtomicAddProperty(req, plane_id, property_src_x, <span class="hljs-number">0</span>);<br>drmModeAtomicAddProperty(req, plane_id, property_src_y, <span class="hljs-number">0</span>);<br>drmModeAtomicAddProperty(req, plane_id, property_src_w, <span class="hljs-number">320</span> &lt;&lt; <span class="hljs-number">16</span>);<br>drmModeAtomicAddProperty(req, plane_id, property_src_h, <span class="hljs-number">320</span> &lt;&lt; <span class="hljs-number">16</span>);<br>drmModeAtomicCommit(fd, req, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>drmModeAtomicFree(req);<br></code></pre></td></tr></table></figure></li></ul></li></ul><div align="center"><h3 id="5-KMS驱动概述"><a href="#5-KMS驱动概述" class="headerlink" title="5.KMS驱动概述"></a>5.KMS驱动概述</h3></div><ul><li><p>DRM框架核心：</p><p><img src="/../images/drm%E9%A9%B1%E5%8A%A8%E6%A0%B8%E5%BF%83.jpg" alt="DRM框架核心"></p><ul><li>上图蓝色部分则是对物理硬件的抽象，黄色部分则是对软件的抽象；</li><li>虚线以上的为 drm_mode_object，虚线以下为 drm_gem_object；</li></ul></li><li><p>各个objects之间的关系：<br><img src="/../images/objs%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="objs结构"></p><ul><li>plane连接fb和crtc</li><li>encoder连接crtc和connector</li></ul></li></ul><h4 id="最简单的KMS驱动代码分析-legacy"><a href="#最简单的KMS驱动代码分析-legacy" class="headerlink" title="最简单的KMS驱动代码分析(legacy)"></a>最简单的KMS驱动代码分析(legacy)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drmP.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_gem_cma_helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_plane.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_plane_helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_crtc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_crtc_helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_encoder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_connector.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_probe_helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_mode_config.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_gem_framebuffer_helper.h&quot;</span></span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_device</span> <span class="hljs-title">drm</span>;</span>    <span class="hljs-comment">//声明drm设备对象</span><br><br><span class="hljs-comment">/*声明drm_obj*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane</span> <span class="hljs-title">primary</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc</span> <span class="hljs-title">crtc</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_encoder</span> <span class="hljs-title">encoder</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector</span> <span class="hljs-title">connector</span>;</span><br><br><span class="hljs-comment">/*声明各个obj操作函数集接口*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane_funcs</span> <span class="hljs-title">vkms_plane_funcs</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_funcs</span> <span class="hljs-title">vkms_crtc_funcs</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_encoder_funcs</span> <span class="hljs-title">vkms_encoder_funcs</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector_funcs</span> <span class="hljs-title">vkms_connector_funcs</span>;</span><br><br><br><span class="hljs-comment">//mode setting函数集</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_mode_config_funcs</span> <span class="hljs-title">vkms_mode_funcs</span> =</span> &#123;<br>   .fb_create = drm_gem_fb_create,  <span class="hljs-comment">//使用gem helper函数 创建framebuffer object\</span><br><span class="hljs-comment">                                       并绑定gem object，drm_gem_framebuffer_helper.h中声明</span><br>&#125;;<br><br><span class="hljs-comment">/*声明plane支持的fb formats*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> vkms_formats = &#123;<br>   DRM_FORMAT_XRGB8888,<br>&#125;;<br><br><span class="hljs-comment">//crtc funcs 中 page flip函数实现</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vkms_page_flip</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc, <span class="hljs-keyword">struct</span> drm_framebuffer *fb, \</span><br><span class="hljs-params">                  <span class="hljs-keyword">struct</span> drm_pending_vblank_event *event, \</span><br><span class="hljs-params">                  <span class="hljs-type">uint32_t</span> flags, <span class="hljs-keyword">struct</span> drm_modeset_acquire_ctx *ctx)</span><br>&#123;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>   crtc-&gt;primary-&gt;fb = fb;<br>   <span class="hljs-keyword">if</span> (event)     <span class="hljs-comment">//自旋等待vsync事件</span><br>   &#123;    <br>      spin_lock_irqsave(&amp;crtc-&gt;dev-&gt;event_lock, flags);<br>      drm_crtc_send_vblank_event(crtc, event);<br>      spin_unlock_irqrestore(&amp;crtc-&gt;dev-&gt;event_lock, flags);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//crtc funcs接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_funcs</span> <span class="hljs-title">vkms_crtc_funcs</span> =</span> &#123;<br>   .set_config = drm_crtc_helper_set_config,           <span class="hljs-comment">//drmModeSetCrtc()会调用此接口，使用helper函数</span><br>   .page_flip = vkms_page_flip,                        <span class="hljs-comment">//drmModePageFlip()会调用此接口</span><br>   .destroy = drm_crtc_cleanup,                        <span class="hljs-comment">//crtc清理函数 crtc funcs中必须有destroy</span><br>&#125;;<br><br><span class="hljs-comment">//crtc helper funcs中dpms的实现 暂为空</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkms_crtc_dpms</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc, <span class="hljs-type">int</span> mode)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//crtc helper funcs中mode_set的实现 暂为空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vkms_crtc_mode_set</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc, <span class="hljs-keyword">struct</span> drm_display_mode *mode,</span><br><span class="hljs-params">         <span class="hljs-keyword">struct</span> drm_display_mode *adjusted_mode, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y,</span><br><span class="hljs-params">         <span class="hljs-keyword">struct</span> drm_framebuffer *old_fb)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//crtc helper funcs中mode_set的实现 暂为空</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkms_crtc_prepare</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//crtc helper funcs中commit的实现 暂为空</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vkms_crtc_commit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//crtc helper funcs接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_helper_funcs</span> <span class="hljs-title">vkms_crtc_helper_funcs</span> =</span> &#123;<br>   .dpms = vkms_crtc_dpms,    <span class="hljs-comment">// crtc power levels control</span><br>   .mode_set = vkms_crtc_mode_set,  <span class="hljs-comment">//This callback is used by the legacy CRTC helpers to set a new mode, \</span><br><span class="hljs-comment">                                       position and framebuffer.</span><br>   .prepare = vkms_crtc_prepare, <span class="hljs-comment">//This callback should prepare the CRTC for a subsequent modeset, \</span><br><span class="hljs-comment">                                    which in practice means the driver should disable the CRTC if it isrunning.</span><br>   .commit = vkms_crtc_commit,    <span class="hljs-comment">//This callback should commit the new mode on the CRTC after a modeset,\</span><br><span class="hljs-comment">                                 which in practice means the driver should enable the CRTC.</span><br>&#125;;<br><br><span class="hljs-comment">//plane funcs 接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane_funcs</span> <span class="hljs-title">vkms_plane_funcs</span> =</span> drm_primary_helper_funcs;  <span class="hljs-comment">//drm_plane_helper.h中声明 drm_plane_helper.c中定义\</span><br><span class="hljs-comment">                                                                           包括update_plane disable_plane destroy三个成员的实现\</span><br><span class="hljs-comment">                                                                           update 在drmModeSetPlane()调用</span><br><br><span class="hljs-comment">//connector funcs 接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector_funcs</span> <span class="hljs-title">vkms_connector_funcs</span> =</span> &#123;<br>   .dpms = drm_helper_connector_dpms,<br>   .fill_modes = drm_helper_probe_single_connector_modes,    <span class="hljs-comment">//drm_probe_helper.c中实现  由drmModeGetConnector()调用</span><br>   .destroy = drm_connector_cleanup,<br>&#125;;<br><br><span class="hljs-comment">//connector helper funcs 中 get_modes实现</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vkms_connector_get_modes</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_connector *connector)</span><br>&#123;<br>   <span class="hljs-type">int</span> count;<br>   count = drm_add_modes_noedid(connector, <span class="hljs-number">8192</span>, <span class="hljs-number">8192</span>);<br>   drm_set_preferred_mode(connector, <span class="hljs-number">1024</span>, <span class="hljs-number">768</span>);<br>   <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//connector helper funcs 中 best_encoder实现</span><br><span class="hljs-keyword">struct</span> drm_encoder *<span class="hljs-title function_">vkms_connector_best_encoder</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_connector *connector)</span><br>&#123;<br>   <span class="hljs-keyword">return</span> &amp;encoder;<br>&#125;<br><span class="hljs-comment">//connector helper funcs 接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector_helper_funcs</span> <span class="hljs-title">vkms_connector_helper_funcs</span> =</span> &#123;<br>   .get_modes = vkms_connector_get_modes,   <span class="hljs-comment">//Add modes to the connector that the panel is attached to and \</span><br><span class="hljs-comment">                                             return the number of modes added.</span><br>   .best_encoder = vkms_connector_best_encoder,  <span class="hljs-comment">//Encoder that should be used for the given connector and connector \</span><br><span class="hljs-comment">                                                   state, or NULL if no suitable encoder exists.</span><br>&#125;;<br><br><br><span class="hljs-comment">//encoder funcs接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_encoder_funcs</span> <span class="hljs-title">vkms_encoder_funcs</span> =</span> &#123;<br>   .destroy = drm_encoder_cleanup,<br>&#125;;<br><br><span class="hljs-comment">/*初始化各个obj*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vkms_modeset_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>   drm_mode_config_init(&amp;drm);  <span class="hljs-comment">//初始化一些全局数据结构，standard properties在此处创建</span><br><br>   drm.mode_config.max_width = <span class="hljs-number">2048</span>;<br>   drm.mode_config.max_height = <span class="hljs-number">2048</span>;<br><br>   drm.mode_config.funcs = &amp;vkms_mode_funcs;   <span class="hljs-comment">//设置mode config函数集</span><br><br>   <span class="hljs-comment">/*创建drm_mode_objects*/</span><br>   drm_universal_plane_init(&amp;drm, &amp;primary, <span class="hljs-number">0</span>, &amp;vkms_plane_funcs, vkms_formats, \<br>   ARRAY_SIZE(vkms_formats), <span class="hljs-literal">NULL</span>, DRM_PLANE_TYPE_PRIMARY, <span class="hljs-literal">NULL</span>);<br>   drm_crtc_init_with_planes(&amp;drm, &amp;crtc, &amp;primary, <span class="hljs-literal">NULL</span>, &amp;vkms_crtc_funcs, <span class="hljs-literal">NULL</span>);<br>   drm_crtc_helper_add(&amp;crtc, &amp;vkms_crtc_helper_funcs);<br>   drm_encoder_init(&amp;drm, &amp;encoder, &amp;vkms_encoder_funcs, DRM_MODE_ENCODER_VIRTUAL, <span class="hljs-literal">NULL</span>);<br>   drm_connector_init(&amp;drm, &amp;connector, &amp;vkms_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);<br>   drm_connector_helper_add(&amp;connector, &amp;vkms_connector_helper_funcs);<br>   drm_connector_attach_encoder(&amp;connector, &amp;encoder);<br>&#125;<br><br><br>DEFINE_DRM_GEM_CMA_FOPS(drm_driver_fops);   <span class="hljs-comment">//drm_gem_cma_helper.h中已经帮忙定义好了\</span><br><span class="hljs-comment">                                             drm driver的相关fops接口，drm_driver_fops为自定义的fops名</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_driver</span> <span class="hljs-title">vkms_driver</span> =</span> &#123;    <span class="hljs-comment">//drm driver</span><br>   .name = <span class="hljs-string">&quot;vkms&quot;</span>, <br>   .desc = <span class="hljs-string">&quot;virtual kernel mode setting&quot;</span>,<br>   .date = <span class="hljs-string">&quot;2022.10.27&quot;</span>,<br>   .major = <span class="hljs-number">1</span>,<br>   .minor = <span class="hljs-number">0</span>,<br>   .driver_features = DRIVER_MODESET | DRIVER_GEM,     <span class="hljs-comment">//驱动支持的操作:mode setting, gem</span><br>   .fops = drm_driver_fops,<br>   .dumb_create = drm_gem_cma_dumb_create,  <span class="hljs-comment">//用于创建gem object并分配物理buffer，直接使用cma helper函数</span><br>&#125;;<br><br><br><span class="hljs-comment">/**模块入口**/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">vkms_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>   <span class="hljs-comment">/****</span><br><span class="hljs-comment">   * 初始化drm_dev设备;</span><br><span class="hljs-comment">   * 将drm device和driver关联</span><br><span class="hljs-comment">   * 此函数会使drm_device结构体下的driver成员变量指向drm_driver</span><br><span class="hljs-comment">   */</span><br>   drm_dev_init(&amp;drm, &amp;vkms_driver, <span class="hljs-literal">NULL</span>);<br><br>   vkms_modeset_init();<br><br>   drm_dev_register(&amp;drm, <span class="hljs-number">0</span>); <span class="hljs-comment">//将drm dev注册进drm core</span><br>&#125;<br><br><span class="hljs-comment">/*模块出口*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">vkms_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>&#125;<br><br>module_init(vkms_init);<br>module_exit(vkms_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;Hector&quot;</span>);  <br></code></pre></td></tr></table></figure><ol><li>定义drm设备对象和drm_mode_objects(crtc plane encoder connector);</li><li>创建驱动核心drm_driver，设置其相关information和features;</li><li>完成driver相关的fops，使用DEFINE_DRM_GEM_CMA_FOPS(drm_driver_fops);</li><li>完成mode_config_funcs；</li><li>完成各个object的drm_xxx_funcs和drm_xxx_helper_funcs</li><li>drm_dec_init</li><li>drm_mode_config_init,完成设备的modeconfig设置</li><li>用drm_xxx_funcs创建各个drm_mode_objects,利用drm_xxx_helper_add绑定各个drm_xxx_helper_funcs</li><li>drm_dev_register</li></ol><blockquote><p>以上为legacy接口驱动，且为最简单的驱动实现，各个drm_xxx_funcs和drm_xxx_helper_funcs无法更精简</p></blockquote><blockquote><p>drm_xxx_funcs 是 drm ioctl 操作的最终入口，但是对于大多数 SoC 厂商来说，它们的 drm_xxx_funcs 操作流程基本相同，只是在寄存器配置上存在差异，因此开发者们将那些 common 的操作流程做成了 helper 函数，而将那些厂商差异化的代码放到了 drm_xxx_helper_funcs 中去，由 SoC 厂商自己实现。</p></blockquote><ul><li>legacy接口重点<ul><li>xxx_funcs必须有，xxx_helper_funcs可以没有</li><li>drm_xxx_init必须有，drm_xxx_helper_add()取决于是否有xxx_helper_funcs</li><li>只有当xxx_funcs采用DRM标准的helper函数实现时才有可能需要定义xxx_helper_funcs接口</li><li>xxx_funcs.destroy()接口必须实现</li></ul></li></ul><h4 id="最简单的KMS驱动代码分析-atomic"><a href="#最简单的KMS驱动代码分析-atomic" class="headerlink" title="最简单的KMS驱动代码分析(atomic)"></a>最简单的KMS驱动代码分析(atomic)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drmP.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_gem_cma_helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_plane.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_plane_helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_crtc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_crtc_helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_encoder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_connector.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_probe_helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_mode_config.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_gem_framebuffer_helper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;linux/hrtimer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;drm/drm_atomic_helper.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_device</span> <span class="hljs-title">drm</span>;</span>    <span class="hljs-comment">//声明drm设备对象</span><br><br><span class="hljs-comment">/*声明drm_obj*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane</span> <span class="hljs-title">primary</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc</span> <span class="hljs-title">crtc</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_encoder</span> <span class="hljs-title">encoder</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector</span> <span class="hljs-title">connector</span>;</span><br><br><span class="hljs-comment">/*声明各个obj操作函数集接口*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane_funcs</span> <span class="hljs-title">vkms_plane_funcs</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_funcs</span> <span class="hljs-title">vkms_crtc_funcs</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_encoder_funcs</span> <span class="hljs-title">vkms_encoder_funcs</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector_funcs</span> <span class="hljs-title">vkms_connector_funcs</span>;</span><br><br><span class="hljs-comment">//vblank依赖的高精度定时器</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hrtimer</span> <span class="hljs-title">vblank_timer</span>;</span><br><br><span class="hljs-comment">//定时器回调函数</span><br><span class="hljs-keyword">enum</span> hrtimer_restart <span class="hljs-title function_">vkms_vblank_timer_function</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> hrtimer *)</span><br>&#123;<br>    drm_crtc_handle_vblank(&amp;crtc);   <span class="hljs-comment">//Drivers should call this routine in their vblank interrupt handlers to \</span><br><span class="hljs-comment">                                        update the vblank counter and send any signals that may be pending.</span><br>    hrtimer_forward_now(&amp;vblank_hrtimer, <span class="hljs-number">16666667</span>);  <span class="hljs-comment">//重新设置定时器的触发时间，相当于重复使用定时器</span><br>    <span class="hljs-keyword">return</span> HRTIMER_RESTART;<br>&#125;<br><br><br><span class="hljs-comment">//mode setting函数集</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_mode_config_funcs</span> <span class="hljs-title">vkms_mode_funcs</span> =</span> &#123;<br>    .fb_create = drm_gem_fb_create,  <span class="hljs-comment">//使用gem helper函数 创建framebuffer object\</span><br><span class="hljs-comment">                                        并绑定gem object，drm_gem_framebuffer_helper.h中声明</span><br>    .<span class="hljs-type">atomic_check</span> = drm_atomic_helper_check,  <span class="hljs-comment">//检查硬件或者驱动是否支持atomic操作</span><br>    .<span class="hljs-type">atomic_commit</span> = drm_atomic_helper_commit,  <span class="hljs-comment">//This is the only hook to commit an atomic modeset update.</span><br>&#125;;<br><br><span class="hljs-comment">/*声明plane支持的fb formats*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> vkms_formats = &#123;<br>    DRM_FORMAT_XRGB8888,<br>&#125;;<br><br><br><span class="hljs-comment">//crtc funcs接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_funcs</span> <span class="hljs-title">vkms_crtc_funcs</span> =</span> &#123;<br>    .set_config = drm_atomic_helper_set_config,     <br>    .page_flip = drm_atomic_helper_page_flip,<br>    .reset = drm_atomic_helper_crtc_reset,<br>    .atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,  <span class="hljs-comment">//Duplicated atomic state or NULL when the allocation failed</span><br>    .atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,    <span class="hljs-comment">//Destroy a state duplicated with @atomic_duplicate_state and release \                                                                    or unreference all resources it references                </span><br>    .destroy = drm_crtc_cleanup,       <br>&#125;;<br><br><br><span class="hljs-comment">//crtc helper funcs中atomic enable的实现</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vkms_crtc_atomic_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc, <span class="hljs-keyword">struct</span> drm_crtc_state *old_crtc_state)</span><br>&#123;<br>    hrtimer_init(&amp;vblank_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);   <span class="hljs-comment">//初始化定时器</span><br>    vblank_timer.function = vkms_vblank_timer_function;       <span class="hljs-comment">//定时器回调函数</span><br>    hrtimer_start(&amp;vblank_timer, <span class="hljs-number">16666667</span>, HRTIMER_MODE_REL); <br>&#125;<br><br><span class="hljs-comment">//crtc helper funcs中atomic disable的实现</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vkms_crtc_atomic_disable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc, <span class="hljs-keyword">struct</span> drm_crtc_state *old_crtc_state)</span><br>&#123;<br>    hrtimer_cancel(&amp;vblank_timer);    <span class="hljs-comment">//等待回调函数执行完取消定时器</span><br>&#125;<br><br><span class="hljs-comment">//crtc helper funcs中atomic flush的实现</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vkms_crtc_atomic_flush</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc, <span class="hljs-keyword">struct</span> drm_crtc_state *old_crtc_state)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br><span class="hljs-keyword">if</span> (crtc-&gt;state-&gt;event) &#123;<br>spin_lock_irqsave(&amp;crtc-&gt;dev-&gt;event_lock, flags);<br>drm_crtc_send_vblank_event(crtc, crtc-&gt;state-&gt;event);<br>spin_unlock_irqrestore(&amp;crtc-&gt;dev-&gt;event_lock, flags);<br><br>crtc-&gt;state-&gt;event = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//crtc helper funcs接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_helper_funcs</span> <span class="hljs-title">vkms_crtc_helper_funcs</span> =</span> &#123;<br>    .<span class="hljs-type">atomic_enable</span> = vkms_crtc_atomic_enable,    <span class="hljs-comment">//This callback should be used to enable the CRTC.</span><br>    .atomic_disable = vkms_crtc_atomic_disable,  <span class="hljs-comment">//This callback should be used to disable the CRTC.</span><br>    .<span class="hljs-type">atomic_flush</span> = vkms_crtc_atomic_flush,      <span class="hljs-comment">//Drivers should finalize an atomic update of multiple planes on a CRTC in this hook. </span><br>&#125;;<br><br><span class="hljs-comment">//plane funcs 接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane_funcs</span> <span class="hljs-title">vkms_plane_funcs</span> =</span> &#123;<br>    .update_plane = drm_atomic_helper_update_plane,<br>    .disable_plane = drm_atomic_helper_disable_plane,<br>    .destroy = drm_plane_cleanup,<br>    .reset = drm_atomic_helper_plane_reset,<br>    .atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,<br>    .atomic_destroy_state = drm_atomic_helper_plane_destroy_state,<br>&#125;;<br><br><span class="hljs-comment">//plane helper funcs中的atomic_update实现 暂为空</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vkms_plane_atomic_update</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_plane *plane, <span class="hljs-keyword">struct</span> drm_plane_state *old_state)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//plane helper funcs接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane_helper_funcs</span> <span class="hljs-title">vkms_plane_helper_funcs</span> =</span> &#123;<br>    .<span class="hljs-type">atomic_update</span> = vkms_plane_atomic_update,  <span class="hljs-comment">//Drivers should use this function to update the plane state.</span><br>&#125;; <br><br><span class="hljs-comment">//connector funcs 接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector_funcs</span> <span class="hljs-title">vkms_connector_funcs</span> =</span> &#123;<br>    .fill_modes = drm_helper_probe_single_connector_modes,    <span class="hljs-comment">//drm_probe_helper.c中实现  由drmModeGetConnector()调用</span><br>    .destroy = drm_connector_cleanup, <br>    .reset = drm_atomic_helper_connector_reset,<br>    .atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,<br>    .atomic_destroy_state = drm_atomic_helper_connector_destroy_state,  <br>&#125;;<br><br><span class="hljs-comment">//connector helper funcs 中 get_modes实现</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vkms_connector_get_modes</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_connector *connector)</span><br>&#123;<br>    <span class="hljs-type">int</span> count;<br>    count = drm_add_modes_noedid(connector, <span class="hljs-number">8192</span>, <span class="hljs-number">8192</span>);<br>drm_set_preferred_mode(connector, <span class="hljs-number">1024</span>, <span class="hljs-number">768</span>);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//connector helper funcs 接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector_helper_funcs</span> <span class="hljs-title">vkms_connector_helper_funcs</span> =</span> &#123;<br>    .get_modes = vkms_connector_get_modes,   <span class="hljs-comment">//Add modes to the connector that the panel is attached to and \</span><br><span class="hljs-comment">                                            return the number of modes added.</span><br>&#125;;<br><br><br><span class="hljs-comment">//encoder funcs接口</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_encoder_funcs</span> <span class="hljs-title">vkms_encoder_funcs</span> =</span> &#123;<br>    .destroy = drm_encoder_cleanup,<br>&#125;;<br><br><span class="hljs-comment">/*初始化各个obj*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vkms_modeset_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    drm_mode_config_init(&amp;drm);  <span class="hljs-comment">//初始化一些全局数据结构，standard properties在此处创建</span><br><br>    drm.mode_config.max_width = <span class="hljs-number">2048</span>;<br>    drm.mode_config.max_height = <span class="hljs-number">2048</span>;<br><br>    drm.mode_config.funcs = &amp;vkms_mode_funcs;   <span class="hljs-comment">//设置mode config函数集</span><br><br>    <span class="hljs-comment">/*创建drm_mode_objects*/</span><br>    drm_universal_plane_init(&amp;drm, &amp;primary, <span class="hljs-number">0</span>, &amp;vkms_plane_funcs, vkms_formats, \<br>    ARRAY_SIZE(vkms_formats), <span class="hljs-literal">NULL</span>, DRM_PLANE_TYPE_PRIMARY, <span class="hljs-literal">NULL</span>);<br>    drm_plane_helper_add(&amp;primary, &amp;vkms_plane_helper_funcs);<br>    drm_crtc_init_with_planes(&amp;drm, &amp;crtc, &amp;primary, <span class="hljs-literal">NULL</span>, &amp;vkms_crtc_funcs, <span class="hljs-literal">NULL</span>);<br>    drm_crtc_helper_add(&amp;crtc, &amp;vkms_crtc_helper_funcs);<br>    drm_encoder_init(&amp;drm, &amp;encoder, &amp;vkms_encoder_funcs, DRM_MODE_ENCODER_VIRTUAL, <span class="hljs-literal">NULL</span>);<br>    drm_connector_init(&amp;drm, &amp;connector, &amp;vkms_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);<br>    drm_connector_helper_add(&amp;connector, &amp;vkms_connector_helper_funcs);<br>    drm_connector_attach_encoder(&amp;connector, &amp;encoder);<br>    drm_mode_config_reset(&amp;drm);  <span class="hljs-comment">//This functions calls all the crtc&#x27;s, encoder&#x27;s and connector&#x27;s -&gt;reset callback. </span><br>&#125;<br><br><br>DEFINE_DRM_GEM_CMA_FOPS(drm_driver_fops);   <span class="hljs-comment">//drm_gem_cma_helper.h中已经帮忙定义好了\</span><br><span class="hljs-comment">                                              drm driver的相关fops接口，drm_driver_fops为自定义的fops名</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_driver</span> <span class="hljs-title">vkms_driver</span> =</span> &#123;    <span class="hljs-comment">//drm driver</span><br>    .name = <span class="hljs-string">&quot;vkms&quot;</span>, <br>    .desc = <span class="hljs-string">&quot;virtual kernel mode setting&quot;</span>,<br>    .date = <span class="hljs-string">&quot;2022.10.27&quot;</span>,<br>    .major = <span class="hljs-number">1</span>,<br>    .minor = <span class="hljs-number">0</span>,<br>    .driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,     <span class="hljs-comment">//驱动支持的操作:mode setting, gem, atomic</span><br>    .fops = drm_driver_fops,<br>    .dumb_create = drm_gem_cma_dumb_create,  <span class="hljs-comment">//用于创建gem object并分配物理buffer，直接使用cma helper函数</span><br>&#125;;<br><br><br><span class="hljs-comment">/**模块入口**/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">vkms_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/****</span><br><span class="hljs-comment">     * 初始化drm_dev设备;</span><br><span class="hljs-comment">     * 将drm device和driver关联</span><br><span class="hljs-comment">     * 此函数会使drm_device结构体下的driver成员变量指向drm_driver</span><br><span class="hljs-comment">    */</span><br>    drm_dev_init(&amp;drm, &amp;vkms_driver, <span class="hljs-literal">NULL</span>);<br><br>    vkms_modeset_init();<br><br>    drm_dev_register(&amp;drm, <span class="hljs-number">0</span>); <span class="hljs-comment">//将drm dev注册进drm core</span><br>&#125;<br><br><span class="hljs-comment">/*模块出口*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">vkms_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>&#125;<br><br>module_init(vkms_init);<br>module_exit(vkms_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;Hector&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>与legacy框架相似，区别主要在于<ul><li>在drm_mode_Config中添加了atomic_check等操作函数</li><li>在driver中添加了DRIVER_ATOMIC feature</li><li>各个drm_mode_objects的funcs和helper funcs改为了atomic接口</li><li>在创建完各个drm_mode_objests后使用drm_mode_config_reset</li></ul></li><li>atomic重点在于<ul><li>driver.feature添加DRIVER＿ATOMIC标志</li><li>drm_mode_config_funcs.atomic_commit()接口是atomic操作的主要入口函数，必须实现</li><li>atomic操作依赖vsync，即vblank，因此需要hrtimer提供软件中断信号，驱动初始化时调用drm_vblank_init(),定时器回调函数中调用drm_handle_vblank</li><li>在各个drm_mode_objs初始化完成后必须调用drm_mode_congfig_reset()来动态创建各个pipeline的软件状态，即drm_xxx_state</li><li>atomic的xxx_funcs必须实现以下接口，它们主要用于维护drm_xxx_state数据结构<ul><li>reset()</li><li>atomic_duplicate_state()</li><li>atomic_destroy_state()</li></ul></li><li>drm_plane_helper_funcs.atomic_update()必须实现</li></ul></li></ul><div align="center"><h3 id="6-GEM驱动概述"><a href="#6-GEM驱动概述" class="headerlink" title="6.GEM驱动概述"></a>6.GEM驱动概述</h3></div><blockquote><p>前面的代码只实现了KMS相关驱动的框架，还需要为驱动添加GEM的功能</p></blockquote><h4 id="最简单的GEM驱动"><a href="#最简单的GEM驱动" class="headerlink" title="最简单的GEM驱动"></a>最简单的GEM驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">DEFINE_DRM_GEM_CMA_FOPS(drm_driver_fops);   <span class="hljs-comment">//drm_gem_cma_helper.h中已经帮忙定义好了\</span><br><span class="hljs-comment">                                              drm driver的相关fops接口，drm_driver_fops为自定义的fops名</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_driver</span> <span class="hljs-title">vkms_driver</span> =</span> &#123;    <span class="hljs-comment">//drm driver</span><br>    .name = <span class="hljs-string">&quot;vkms&quot;</span>, <br>    .desc = <span class="hljs-string">&quot;virtual kernel mode setting&quot;</span>,<br>    .date = <span class="hljs-string">&quot;2022.10.27&quot;</span>,<br>    .major = <span class="hljs-number">1</span>,<br>    .minor = <span class="hljs-number">0</span>,<br>    .driver_features = DRIVER_GEM,     <span class="hljs-comment">//驱动支持的操作: gem</span><br>    .fops = drm_driver_fops,<br>    .dumb_create = drm_gem_cma_dumb_create,  <span class="hljs-comment">//用于创建gem object并分配物理buffer，直接使用cma helper函数</span><br>    .gem_vm_ops = &amp;drm_gem_cma_vm_ops,<br>    .gem_free_ovject_unlocked = drm_gem_cma_free_object,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>driver.feature &#x3D; DRIVER_GEM,表明驱动支持GEM操作</li><li>driver.dumb_create : 分配dumb buffer 的或调接口，主要完成三件事<ul><li>创建gem object</li><li>分配gem handle</li><li>分配物理buffer</li></ul></li><li>fops中有mmap函数，通常用drm_gem_cma_mmap()实现</li><li>gem_vm_ops:主要为mmap服务，必须实现<blockquote><p>其实driver中还有dumb_map_offset和dumb_destroy两个接口，分别对应各自的ioctl函数，如果驱动没有实现这两个回调接口， 那么 DRM 框架会使用默认的 drm_gem_dumb_map_offset() 和 drm_gem_dumb_destroy() 代替。</p></blockquote><!--PC版--></li></ul><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
      <category>DRM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>linux并发与竞争</title>
    <link href="/2022/10/02/linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/"/>
    <url>/2022/10/02/linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/</url>
    
    <content type="html"><![CDATA[<div align="center"><h3 id="并发与竞争简介"><a href="#并发与竞争简介" class="headerlink" title="并发与竞争简介"></a>并发与竞争简介</h3></div><blockquote><p>多任务同时访问同一片内存区域，这些任务可能会相会覆盖内存中的数据，造成内存读写混乱<br>linux系统产生并发的原因：</p></blockquote><ol><li>多线程并发访问</li><li>抢占式并发访问</li><li>中断程序并发访问</li><li>SMP(多核)核间并发访问</li></ol><p><strong>临界区</strong> ：共享数据段<br>保证同一时刻只能有一个任务访问临界区资源</p><h4 id="原子操作（一般用于整型变量或者位操作）"><a href="#原子操作（一般用于整型变量或者位操作）" class="headerlink" title="原子操作（一般用于整型变量或者位操作）"></a>原子操作（一般用于整型变量或者位操作）</h4><ol><li><p>原子变量定义,在使用原子操作时，用原子变量代替整型变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> counter;<br>&#125;<span class="hljs-type">atomic_t</span>;<br></code></pre></td></tr></table></figure><p><code>atomic_t a;  //定义原子变量</code><br><code>atomic_t b = ATOMIC_INIT(0) //定义原子变量b的同时将其初始化为0</code></p></li><li><p>整型原子操作API函数</p><table><thead><tr><th align="center">函数描述</th><th align="center">函数</th></tr></thead><tbody><tr><td align="center">定义时赋初值i</td><td align="center">atomic_t a &#x3D; ATOMIC_INIT(i)</td></tr><tr><td align="center">读取原子变量v的值</td><td align="center">int atomic_read(atomic_t *v)</td></tr><tr><td align="center">向原子变量v写入数据i</td><td align="center">void atomic_set(atomic_t *v, int i)</td></tr><tr><td align="center">原子变量v加上i</td><td align="center">void atomic_add(int i, atomic_t *v)</td></tr><tr><td align="center">原子变量v减去i</td><td align="center">void atomic_sub(int i, atomic_t *v)</td></tr><tr><td align="center">原子变量v自增</td><td align="center">void atomic_inc(atomic_t *v)</td></tr><tr><td align="center">原子变量v自减</td><td align="center">void atomic_dec(atomic_t *v)</td></tr><tr><td align="center">从v减1并返回v的值</td><td align="center">int atomic_dec_return(atomic_t *v)</td></tr><tr><td align="center">从v加1并返回v的值</td><td align="center">int atomic_inc_return(atomic_t *v)</td></tr><tr><td align="center">从v减i，结果为0返回真，否则返回假</td><td align="center">int atomic_sub_and_test(int i, atomic_t *v)</td></tr><tr><td align="center">从v加1，结果为0返回真，否则返回假</td><td align="center">int atomic_inc_and_test(int i, atomic_t *v)</td></tr><tr><td align="center">从v减1，结果为0返回真，否则返回假</td><td align="center">int atomic_dec_and_test(int i, atomic_t *v)</td></tr></tbody></table><blockquote><p>上述API函数针对32位系统，若在64位系统中使用原子变量，上述函数前缀由atomic_改为atomic64_，返回值由int改为long long</p></blockquote></li><li><p>原子位操作API函数(直接对内存操作)</p><table><thead><tr><th align="center">函数描述</th><th align="center">函数</th></tr></thead><tbody><tr><td align="center">将p地址的第nr位置1</td><td align="center">void set_bit(int nr, void *p)</td></tr><tr><td align="center">将p地址的第nr位置0</td><td align="center">void clear_bit(int nr, void *p)</td></tr><tr><td align="center">将p地址的第nr位翻转</td><td align="center">void chang_bit(int nr, void *p)</td></tr><tr><td align="center">获取p地址第nr位的值</td><td align="center">int test_bit(int nr, void *p)</td></tr></tbody></table></li></ol><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><blockquote><p>保证同一资源同时只能被一个任务访问，若其他线程获取锁失败，原地自旋（不断查询锁状态），等待锁可用。其缺点在于自旋状态会浪费处理器资源，降低系统性能，因此自旋锁持有时间不能太长。<br>linux内核使用spinlock_t表示自旋锁类型 spinlock_t lock;</p></blockquote><ul><li>多线程中自旋锁API函数<table><thead><tr><th align="center">函数描述</th><th align="center">函数</th></tr></thead><tbody><tr><td align="center">定义并初始化自旋锁变量（宏）</td><td align="center">DEFINE_SPINLOCK(spinlock_t lock)</td></tr><tr><td align="center">初始化自旋锁</td><td align="center">int spin_lock_init(spinlock_t *lock)</td></tr><tr><td align="center">获取指定的自旋锁(上锁，不推荐使用)</td><td align="center">void spin_lock(spinlock_t *lock)</td></tr><tr><td align="center">释放指定的自旋锁(开锁，不推荐使用)</td><td align="center">void spin_unlock(spinlock_t *lock)</td></tr><tr><td align="center">尝试获取指定自旋锁，获取失败返回0</td><td align="center">int spin_trylock(spinlock_t *lock)</td></tr><tr><td align="center">检查指定自旋锁是否被获取，已获取返回0</td><td align="center">int spin_is_locked(spinlock_t *lock)</td></tr></tbody></table><blockquote><p>以上API函数用于线程与线程之间的并发访问，由自旋锁保护的临界区之中一定调用任何能够引起系统阻塞或者睡眠的函数，否则可能发生死锁现象。</p></blockquote></li><li>涉及到中断的自旋锁API函数<blockquote><p>在中断中可以使用自旋锁，但是在获取锁之前必须关闭本地中断，否则可能出现死锁现象。</p></blockquote><table><thead><tr><th align="center">函数描述</th><th align="center">函数</th></tr></thead><tbody><tr><td align="center">禁止本地中断并获取自旋锁</td><td align="center">void spin_lock_irq(spinlock_t *lock)</td></tr><tr><td align="center">激活本地中断并释放自旋锁</td><td align="center">void spin_unlock_irq(spinlock_t *lock)</td></tr><tr><td align="center">保存中断状态，禁止本地中断，获取自旋锁</td><td align="center">void spin_lock_irqsave(spinlock_t *lock, unsigned long flas)</td></tr><tr><td align="center">恢复中断状态，激活本地中断，释放自旋锁</td><td align="center">void spin_unlock_irqstore(spinlock_t *lock, unsigned long flags)</td></tr></tbody></table><blockquote><p>在涉及到中断的程序中，使用自旋锁时，建议在线程中使用spin_lock_irqsave和spin_unlock_irqstore函数，在中断服务函数中使用spin_lock_irq和spin_unlock_irq函数。</p></blockquote></li><li>使用自旋锁的注意事项<ul><li>自旋锁自旋时间要短，否则会降低系统性能。如果临界区资源较大，运行时间较长，要考虑其他的并发处理方式。</li><li>自旋锁保护的临界区不能使用任何可能导致系统休眠的函数，负责可能产生死锁现象</li><li>不能递归申请自旋</li><li>考虑驱动程序的可移植性，无论多核还是单核，都将其视作多核CPU编写驱动代码</li></ul></li></ul><h4 id="其他内核中常用的锁"><a href="#其他内核中常用的锁" class="headerlink" title="其他内核中常用的锁"></a>其他内核中常用的锁</h4><ol><li>读写自旋锁<blockquote><p>读写自旋锁为读操作和写操作提供不同的锁。一次只允许一个写操作，也就是同一时间只允许一个线程持有写锁，且不能进行读操作；但是当没有写操作时，允许一个或多个线程持有读锁，允许并发执行读操作。</p></blockquote></li></ol><ul><li><p>linux内核使用rwlock_t表示读写锁类型</p><table><thead><tr><th align="center">函数描述</th><th align="center">函数</th></tr></thead><tbody><tr><td align="center">定义并初始化读写锁</td><td align="center">DEFINE_RWLOCK(rwlock_t lock)</td></tr><tr><td align="center">初始化读写锁</td><td align="center">void rwlock_init(rwlock_t *lock)</td></tr><tr><td align="center">获取读锁</td><td align="center">void read_lock(rwlock_t *lock)</td></tr><tr><td align="center">释放读锁</td><td align="center">void read_unlock(rwlock_t *lock)</td></tr><tr><td align="center">禁止本地中断并获取读锁</td><td align="center">void read_lock_irq(rwlock_t *lock)</td></tr><tr><td align="center">打开本地中断并释放读锁</td><td align="center">void read_unlock_irq(rwlock_t *lock)</td></tr><tr><td align="center">获取写锁</td><td align="center">void write_lock(rwlock_t *lock)</td></tr><tr><td align="center">释放写锁</td><td align="center">void write_unlock(rwlock_t *lock)</td></tr><tr><td align="center">禁止本地中断获取写锁</td><td align="center">void write_lock_irq(rwlock_t *lock)</td></tr><tr><td align="center">打开本地中断释放写锁</td><td align="center">void write_unlock_irq(rwlock_t *lock)</td></tr></tbody></table></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><blockquote><p>获取资源信号量加一 释放资源信号量减一<br>与自旋锁不同 信号量使线程休眠 且进入休眠状态后会切换线程</p></blockquote><ul><li>使用信号量的注意事项<ul><li>信号量使线程进入休眠状态，因此适合占用临界区资源较久的情景</li><li>信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠</li><li>临界区资源持有时间较短不适合使用信号量，因为频繁进入休眠切换线程造成的资源开销远大于休眠节省的资源</li></ul></li><li>信号量原型<ul><li>Linux中使用semaphore结构体表示信号量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span>&#123;</span><br>   <span class="hljs-type">raw_spinlock_t</span> lock;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">wait_list</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li>信号量API函数</li></ul><table><thead><tr><th align="center">函数描述</th><th align="center">函数</th></tr></thead><tbody><tr><td align="center">定义一个信号量并设置其值为1</td><td align="center">DEFINE_SEMAPHORE(name)</td></tr><tr><td align="center">初始化信号量并设置信号量的值</td><td align="center">void sema_init(struct semaphore *sem, int val)</td></tr><tr><td align="center">获取信号量，获取失败进入休眠,不能在中断中使用，且使用此函数进入休眠后不能被信号打断</td><td align="center">void down(struct semaphore *sem)</td></tr><tr><td align="center">尝试获取信号量，获取成功返回0;获取失败不会进入休眠</td><td align="center">int down_trylock(struct semaphore *sem)</td></tr><tr><td align="center">获取信号量，与down类似，此函数进入休眠后可以被信号打断</td><td align="center">void down_interruptible(struct semaphore *sem)</td></tr><tr><td align="center">释放信号量 值加一</td><td align="center">void up(struct semaphore *sem)</td></tr></tbody></table><ul><li>示例代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">sem</span>;</span>   <span class="hljs-comment">//定义信号量</span><br>sem_init(&amp;sem, <span class="hljs-number">1</span>);      <span class="hljs-comment">//初始化信号量</span><br>down(&amp;sem);             <span class="hljs-comment">//获取信号量</span><br><span class="hljs-comment">/* 临界区 */</span><br>up(&amp;sem);               <span class="hljs-comment">//释放信号量</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h4><blockquote><p>驱动中使用互斥的地方建议使用互斥体而非二值信号量</p></blockquote><ul><li><p>互斥体原型<br>struct mutex{<br>   atomic_t count;<br>   spinlock_t wait_lock;<br>};</p></li><li><p>互斥体注意事项</p><ul><li>mutex同样导致系统休眠，不能在中断中使用</li><li>临界区可以调用引起阻塞的API函数</li><li>一次只能有一个线程持有mutex,必须由mutex的持有者释放，不能递归上锁和释放</li></ul></li><li><p>互斥体API函数</p><table><thead><tr><th align="center">函数描述</th><th align="center">函数</th></tr></thead><tbody><tr><td align="center">定义并初始化mutex变量</td><td align="center">DEFINE_MUTEX(name)</td></tr><tr><td align="center">初始化mutex</td><td align="center">void mutex_init(struct mutex *lock)</td></tr><tr><td align="center">获取mutex，上锁，获取失败进入休眠</td><td align="center">void mutex_lock(struct mutex *lock)</td></tr><tr><td align="center">释放mutex</td><td align="center">void mutex_ulock(struct mutex *lock)</td></tr><tr><td align="center">尝试获取Mutex，成功返回1 失败返回0</td><td align="center">int mutex_try_lock(struct mutex *lock)</td></tr><tr><td align="center">判断mutex是否被获取，是-1 否-0</td><td align="center">int mutex_is_locked(struct mutex *lock)</td></tr><tr><td align="center">mutex上锁，使用此函数进入休眠后可以被信号打断</td><td align="center">void mutex_lock_interruptible(struct mutex *lock)</td></tr></tbody></table><ul><li>示例代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">lock</span>;</span>   <span class="hljs-comment">//定义一个互斥体</span><br>mutex_init(&amp;lock);   <span class="hljs-comment">//初始化互斥体</span><br>mutex_lock(&amp;lock);   <span class="hljs-comment">//上锁</span><br><span class="hljs-comment">/* 临界区 */</span><br>mutex_unlock(&amp;lock);<br></code></pre></td></tr></table></figure></li></ul><!--PC版--></li></ul><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pinctrl和gpio子系统</title>
    <link href="/2022/09/23/pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/09/23/pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<div align="center"><h3 id="pinctrl子系统"><a href="#pinctrl子系统" class="headerlink" title="pinctrl子系统"></a>pinctrl子系统</h3></div><h4 id="1-关于pinctrl"><a href="#1-关于pinctrl" class="headerlink" title="1. 关于pinctrl"></a>1. 关于pinctrl</h4><h5 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h5><ol><li>pin的枚举和命名</li><li>pin的复用</li><li>pin的配置（上下拉、驱动能力、是否开漏等）</li></ol><h5 id="1-2-pinctrl的核心数据结构"><a href="#1-2-pinctrl的核心数据结构" class="headerlink" title="1.2 pinctrl的核心数据结构"></a>1.2 pinctrl的核心数据结构</h5><ul><li>使用struct pinctrl_desc描述一个pin ctroller</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_desc</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_pin_desc</span> *<span class="hljs-title">pins</span>;</span>   <span class="hljs-comment">//array 描述所有的pins 每一个元素描述一个单独的pin</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npins;                    <span class="hljs-comment">//size of array   pins和npins构成一个索引</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_ops</span> *<span class="hljs-title">pctlops</span>;</span>     <span class="hljs-comment">//引脚控制操作func 用来获取某组引脚 解析设备树节点</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinmux_ops</span> *<span class="hljs-title">pmxops</span>;</span>       <span class="hljs-comment">//引脚复用操作func</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinconf_ops</span> *<span class="hljs-title">confops</span>;</span>     <span class="hljs-comment">//引脚配置操作func</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_custom_params;<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinconf_generic_params</span> *<span class="hljs-title">custom_params</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pin_config_item</span> *<span class="hljs-title">custom_conf_items</span>;</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>使用struct pinctrl_pin_desc描述单个引脚</p><blockquote><p>在pinctrl_pin_desc中以数组形式存在，与npins成员构成索引，方便驱动和具体的pin对应</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_pin_desc</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> number;     <span class="hljs-comment">//引脚序号</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">//引脚名</span><br>    <span class="hljs-type">void</span> *drv_data;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>使用group_desc描述一组特定引脚，如IIC、UART等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">group_desc</span>&#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> *pins;    <span class="hljs-comment">//应该group中pins对应的npins成员的下标数组</span><br>    <span class="hljs-type">int</span> num_pins; <span class="hljs-comment">//group中pin的个数</span><br>    <span class="hljs-type">void</span> *data;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>pinctrl_ops函数族  主要从设备树中获取group节点信息并map</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_ops</span> &#123;</span>   <br>    <span class="hljs-type">int</span> (*get_groups_count) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev);   <span class="hljs-comment">//获取整个pin_controller中的group个数并建立索引，后续根根索引操作group</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *(*get_group_name) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-type">unsigned</span> selector );  <span class="hljs-comment">//获取组名，selector就是需要获得的group的索引号</span><br>    <span class="hljs-type">int</span> (*get_group_pins) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-type">unsigned</span> selector, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> **pins, <span class="hljs-type">unsigned</span> *num_pins);  <span class="hljs-comment">//获取某组的引脚 获取到的信息保存到pins和num_pins指针中</span><br>    <span class="hljs-type">void</span> (*pin_dbg_show) ();  <span class="hljs-comment">//这玩意儿感觉没啥用 debug相关？</span><br>    <span class="hljs-type">int</span> (*dt_node_to_map) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-keyword">struct</span> device_node *np_config, <span class="hljs-keyword">struct</span> pinctrl_map **<span class="hljs-built_in">map</span>, <span class="hljs-type">unsigned</span> *num_maps); <span class="hljs-comment">//解析设备树节点，转换成pinctrl_map，这是一个重点函数   </span><br>    <span class="hljs-type">void</span> (*dt_free_map) ();  <span class="hljs-comment">//释放map</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>pinmux_ops函数族 引脚复用相关</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinmux_ops</span> &#123;</span><br>    <span class="hljs-type">int</span> (*request) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-type">unsigned</span> offset); <span class="hljs-comment">//如果一个pin已作他用 request失败 </span><br>    <span class="hljs-type">int</span> (*<span class="hljs-built_in">free</span>) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-type">unsigned</span> offset);       <br>    <span class="hljs-type">int</span> (*get_functions_count) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev);   <span class="hljs-comment">//获取function数量       </span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *(*get_function_name) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-type">unsigned</span> selector);  <span class="hljs-comment">//获取function名       </span><br>    <span class="hljs-type">int</span> (*get_function_groups) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-type">unsigned</span> selector, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> **groups, <span class="hljs-type">unsigned</span> *num_groups);   <span class="hljs-comment">//获取function下的group       </span><br>    <span class="hljs-type">int</span> (*set_mux) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-type">unsigned</span> func_selector, <span class="hljs-type">unsigned</span> group_selector);   <span class="hljs-comment">//设置复用  将指定的group设置为指定的function</span><br>    <span class="hljs-type">int</span> (*gpio_request_enable) ();<br>    <span class="hljs-type">void</span> (*gpio_disable_free) ();<br>    <span class="hljs-type">int</span> (*gpio_set_direction) ();<br>    <span class="hljs-type">bool</span> strict;  <span class="hljs-comment">//设为true时说明不允许pin作为gpio和其他功能同时使用</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>pinconf_ops函数族 引脚配置相关</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinconf_ops</span> &#123;</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span><br>    <span class="hljs-type">bool</span> is_generic;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span>        </span><br>    <span class="hljs-type">int</span> (*pin_config_get) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-type">unsigned</span> pin, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *config);   <span class="hljs-comment">//获取单个引脚配置  保存在config指针中      </span><br>    <span class="hljs-type">int</span> (*pin_config_set) (<span class="hljs-keyword">struct</span> pinctrl_dev *pctldev, <span class="hljs-type">unsigned</span> pin, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *configs, <span class="hljs-type">unsigned</span> num_configs);    <span class="hljs-comment">//使用config指针配置单个引脚        </span><br>    <span class="hljs-type">int</span> (*pin_config_group_get) ();   <span class="hljs-comment">//获取某组引脚配置        </span><br>    <span class="hljs-type">int</span> (*pin_config_group_set) ();   <span class="hljs-comment">//配置某组引脚        </span><br>    <span class="hljs-type">int</span> (*pin_config_dbg_parse_modify) ();   <span class="hljs-comment">//用以debugfs修改pin配置信息       </span><br>    <span class="hljs-type">void</span> (*pin_config_dbg_show) ();   <span class="hljs-comment">//用以debugfs提供pin配置信息        </span><br>    <span class="hljs-type">void</span> (*pin_config_group_dbg_show) ();   <span class="hljs-comment">//用以debugfs提供group配置信息        </span><br>    <span class="hljs-type">void</span> (*pin_config_config_dbg_show) (s);   <span class="hljs-comment">//用以debugfs解析并显示pin的配置</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="1-3-pin-state"><a href="#1-3-pin-state" class="headerlink" title="1.3 pin state"></a>1.3 pin state</h5><blockquote><p>设备在某一状态下，其pin（group）、function（功能）、configuratio（配置）是唯一确定的，把这三个元素组成的状态抽象为pin state.核心数据结构为pictrl_map。由pinctrl_ops函数族中的dt_node_to_map函数完成。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_map</span> &#123;</span><br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dev_name;   <span class="hljs-comment">//device的名称</span><br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;   <span class="hljs-comment">//pin state的名称</span><br> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">pinctrl_map_type</span> <span class="hljs-title">type</span>;</span>   <span class="hljs-comment">//该map的类型</span><br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ctrl_dev_name;  <span class="hljs-comment">//pin controller device的名字</span><br> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_map_mux</span> <span class="hljs-title">mux</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_map_configs</span> <span class="hljs-title">configs</span>;</span><br> &#125; data;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">pinctrl_map_type</span> &#123;</span><br> PIN_MAP_TYPE_INVALID,<br> PIN_MAP_TYPE_DUMMY_STATE,    <span class="hljs-comment">//不需要任何配置，仅仅为了表示state的存在</span><br> PIN_MAP_TYPE_MUX_GROUP,  <span class="hljs-comment">//配置管脚复用</span><br> PIN_MAP_TYPE_CONFIGS_PIN,  <span class="hljs-comment">//配置pin</span><br> PIN_MAP_TYPE_CONFIGS_GROUP,  <span class="hljs-comment">//配置pin group</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_map_mux</span> &#123;</span><br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *group;  <span class="hljs-comment">//group的名字</span><br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *function;  <span class="hljs-comment">//function的名字</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pinctrl_map_configs</span> &#123;</span><br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *group_or_pin;  <span class="hljs-comment">//该pin或者pin group的名字</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *configs;  <span class="hljs-comment">//config数组</span><br> <span class="hljs-type">unsigned</span> num_configs;  <span class="hljs-comment">//配置项的个数</span><br>&#125;; <br></code></pre></td></tr></table></figure><h4 id="2-pinctrl和GPIO的设备树和基本API"><a href="#2-pinctrl和GPIO的设备树和基本API" class="headerlink" title="2 pinctrl和GPIO的设备树和基本API"></a>2 pinctrl和GPIO的设备树和基本API</h4><blockquote><p>（源码位置 drivers&#x2F;pinctrl）</p></blockquote></div><h5 id="2-1-pin配置信息详解"><a href="#2-1-pin配置信息详解" class="headerlink" title="2.1 pin配置信息详解"></a>2.1 pin配置信息详解</h5><p>一般在设备树中创建一个节点描述pin信息，以imx6u为例：<br>imx6ull.dtsi中有iomuxc节点描述外设pin信息</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">iomuxc:</span> <span class="hljs-title class_">iomuxc@020e0000</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,imx6ul-iomuxc&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x020e0000</span> <span class="hljs-number">0x4000</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>reg属性中的0x020e0000为iomuxc外设节点的首地址。<br>在.dts文件中以&amp;iomuxc引用方式向.dtsi文件中iomuxc节点追加信息</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-variable">&amp;iomuxc</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">pinctrl-names</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">;</span><br>    pinctrl<span class="hljs-number">-0</span> = <span class="hljs-params">&lt;<span class="hljs-variable">&amp;pinctrl_hog_1</span>&gt;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-title class_">imx6ul-evk</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        pinctrl_hog_1:</span> <span class="hljs-title class_">hoggrp-1</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">fsl,pins</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><br><span class="hljs-params">                MX6UL_PAD_UART1_RTS_B__GPIO1_IO19       <span class="hljs-number">0x17059</span></span><br><span class="hljs-params">                MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT    <span class="hljs-number">0x17059</span></span><br><span class="hljs-params">                MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        <span class="hljs-number">0x17059</span></span><br><span class="hljs-params">                MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID    <span class="hljs-number">0x13058</span></span><br><span class="hljs-params">            &gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-punctuation">&#125;;</span><br>        ...<br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>在内核源码中全局搜索iomuxc节点的compatible属性即可得到pinctrl驱动文件源码。<br>以pinctrl_hog_1节点为例，<code>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19       0x17059</code></p><ul><li><strong>MX6UL_PAD_UART1_RTS_B__GPIO1_IO19</strong>是一个宏定义，定义在<strong>arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ul-pinfunc.h</strong>。定义如下：<br><code>#define MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 0x0090 0x031C 0x0000 0x5 0x0</code><ul><li><strong>0x0090</strong>(mux_reg寄存器偏移地址): 为IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B寄存器地址基于IOMUXC外设首地址的偏移量（复用配置）</li><li><strong>0x031C</strong>(conf_reg寄存器偏移地址): 为IOMUXC_SW_PAD_CTL_PAD_UART1_RTS_B寄存器地址基于IOMUXC外设首地址的偏移量（电器属性配置）</li><li><strong>0x0000</strong>(input_reg寄存器偏移地址): 有些外设有input_reg寄存器，此值为input_reg寄存器偏移量</li><li><strong>0x5</strong>(mux_reg寄存器值): 设置IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B寄存器值为0x5</li><li><strong>0x0</strong>(input_reg寄存器值): 设置input_reg寄存器值，此处无效</li></ul></li><li><strong>0x17059</strong> 为confg_reg寄存器的值，根据具体需求配置</li></ul><blockquote><p><em>注：.dtsi文件引用imx6ull-pinfunc.h文件，而imx6ull-pinfunc.h文件再引用imx6ull-pinfunc.h</em></p></blockquote><h5 id="2-2设备树中添加pinctrl节点"><a href="#2-2设备树中添加pinctrl节点" class="headerlink" title="2.2设备树中添加pinctrl节点"></a>2.2设备树中添加pinctrl节点</h5><blockquote><p>例：虚拟一个名为“test”的设备，设备使用GPIO1_IO00这个PIN的GPIO功能。<br>具体步骤如下：</p></blockquote><ol><li>在dts文件中iomuxc节点下的imx6ul-evk节点下添加”pinctrl_test”节点，前缀必须为”pinctrl_”<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">pinctrl_test:</span>testgrp<span class="hljs-punctuation">&#123;</span><br>    待添加的具体的PIN信息<br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li><li>添加”fsl,pins”属性，pinctrl驱动通过读取设备树中”fsl,pins”属性的内容来获取PIN的配置信息，不同芯片属性可能会有差别<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">pinctrl_test:</span>testgrp<span class="hljs-punctuation">&#123;</span><br>    fsl,pins<span class="hljs-params">&lt;</span><br><span class="hljs-params">     待添加的PIN的配置信息</span><br><span class="hljs-params">    &gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li><li>添加pin的配置信息,即复用引脚和config值<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">pinctrl_test:</span>testgrp<span class="hljs-punctuation">&#123;</span><br>    fsl,pins<span class="hljs-params">&lt;</span><br><span class="hljs-params">     MX6UL_PAD_GPIO1_IO00__GPIO1_IO00 config</span><br><span class="hljs-params">    &gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li></ol><div align="center"><h5 id="2-3-gpio-API"><a href="#2-3-gpio-API" class="headerlink" title="2.3 gpio API"></a>2.3 gpio API</h5></div><p>gpio子系统的作用：初始化GPIO并提供相应的API函数</p><ul><li>设备树中的GPIO信息</li></ul><ol><li>添加pinctrl名字<br><code>pinctrl-name = &quot;defaul&quot;;</code></li><li>在设备节点中添加设备所需的PIN的pinctrl信息所在子节点信息<br><code>pinctrl-n = &lt;&amp;pinctrl_xxx&gt;;</code><br>驱动根据pinctrl信息设置pin的复用功能和电气属性</li><li>在设备节点中添加描述GPIO属性的语句<br><code>xxx_gpios = &lt;&amp;GPIO组 pin号 有效电平&gt;</code><br>比如<br><code>cd_gpios = &lt;&amp;gpio1 19 GPIO_ACTIVE_LOW&gt;;</code></li></ol><ul><li>gpio子系统函数</li></ul><ol><li><strong>API函数</strong> <mark> &lt;linux&#x2F;gpio.h&gt; </mark><br><code>int gpio_request(unsigned gpio, const char *label)</code><br><strong>gpio</strong>:要申请的gpio标号，通过of_get_named_gpio函数获取此标号<br><strong>label</strong>：给此gpio设置一个名字<br><strong>返回值</strong>：0-申请成功 其他值-申请失败<ol start="2"><li>释放GPIO管脚<br><code>void gpio_free(unsigned gpio)</code><br><strong>gpio</strong>:要释放的gpio标号</li><li>设置gpio为输入模式<br><code>int gpio_direction_input(unsigned gpio) </code><br><strong>gpio</strong>：要设置的gpio标号<br><strong>返回值</strong>：0-设置成功 其他值-失败</li><li>设置gpio为输出模式<br><code>int gpio_direction_output(unsigned gpio)</code><br><strong>gpio</strong>：要设置的gpio标号<br><strong>返回值</strong>：0-设置成功 其他值-失败</li><li>获取gpio的值(宏函数)<br><code>int gpio_get_value(unsigned gpio) </code><br><strong>gpio</strong>：要获取的gpio标号<br><strong>返回值</strong>：gpio值</li><li>设置gpio的值（宏函数）<br><code>void gpio_set_value(unsigned gpio, int value)</code><br><strong>gpio</strong>：要设置的gpio标号<br><strong>value</strong>：要设置的gpio值</li></ol></li><li><strong>gpio相关的of函数</strong><mark> &lt;linux&#x2F;of_gpio.h&gt; </mark><ol><li>获取某属性中定义gpio信息的个数<br><code>int of_gpio_named_count(struct device_node* np, const char *propname)</code><br><strong>np</strong>：设备节点<br><strong>propname</strong>：要统计gpio个数的属性名<br><strong>返回值</strong>：gpio数目 负值表示失败</li><li>获取”gpios”属性的gpio信息的个数<br><code>int of_gpio_count(struct device_node* np)</code><br><strong>np</strong>：设备节点<br><strong>返回值</strong>：gpio数目 负值表示失败</li><li>获取GPIO标号<br><code>int of_get_named_gpio(struct device_node* np, const char *propname, int index)</code><br><strong>np</strong>：设备节点<br><strong>propname</strong>：要获取的GPIO所属属性名<br><strong>index</strong>：GPIO索引，一个属性中可能含有多个GPIO信息<br><strong>返回值</strong>：gpio标号 负值表示失败</li></ol></li></ol><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设备树详解</title>
    <link href="/2022/09/22/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/09/22/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h3><p>以树形结构描述板级设备节点</p><h4 id="设备树编译命令"><a href="#设备树编译命令" class="headerlink" title="设备树编译命令"></a>设备树编译命令</h4><ol><li>设备树源文件扩展名： .dts</li><li>设备树文件扩展名： .dtb </li><li>将设备树源文件编译成设备树文件： make dtbs</li><li>将指定xxx.dts编译为设备树文件： make xxx.dtb</li><li>设备树支持头文件引用，头文件扩展名为.dtsi，同样支持.h .dts文件的引用</li></ol><h4 id="设备树中的设备节点"><a href="#设备树中的设备节点" class="headerlink" title="设备树中的设备节点"></a>设备树中的设备节点</h4><ol><li><strong>根节点</strong>：&#x2F; 每个设备树文件只能有一个根节点，dts和dtsi中的根节点会合并为同一个根节点</li><li><strong>节点命名格式</strong>：<code>label:node-name@unit-address</code><br><strong>label（可有可无）</strong>:节点标签，可用&amp;label引用节点<br><strong>node-name</strong>:节点名称<br><strong>unit-address</strong>:设备地址或者寄存器首地址</li><li>设备树中数据格式：<table><thead><tr><th align="center">数据类型</th><th align="center">表达式</th></tr></thead><tbody><tr><td align="center">字符串</td><td align="center">“string”</td></tr><tr><td align="center">字符串列表</td><td align="center">“string1”,”string2”</td></tr><tr><td align="center">32位无符号整数</td><td align="center">&lt;0&gt;</td></tr><tr><td align="center">数组</td><td align="center">&lt;0 0x2412 1&gt;</td></tr></tbody></table></li></ol><h3 id="设备树标准属性"><a href="#设备树标准属性" class="headerlink" title="设备树标准属性"></a>设备树标准属性</h3><h4 id="compatible（兼容性属性）"><a href="#compatible（兼容性属性）" class="headerlink" title="compatible（兼容性属性）"></a>compatible（兼容性属性）</h4><p><strong>compatible属性值格式</strong>：<code>compatible = &quot;manufacture1,model1&quot;,&quot;manufacture2,model2&quot;...</code><br><strong>manufacture</strong>: 厂商名称<br><strong>model</strong>: 模块对应的驱动名称</p><blockquote><p>注1：驱动程序中的.of_match_table表储存驱动匹配的compatible值，驱动中的compatible属性与设备节点的compatible属性匹配成功后执行probe函数~</p></blockquote><blockquote><p>注2：根节点下的compatible属性用于内核判断是否支持当前设备~</p></blockquote><h4 id="model-（设备属性）"><a href="#model-（设备属性）" class="headerlink" title="model （设备属性）"></a>model （设备属性）</h4><p><strong>model属性值格式</strong>：<code>model=&quot;alpha_led&quot;</code></p><blockquote><p>字符串用于描述设备信息，比如名字、型号~</p></blockquote><h4 id="status（状态属性）"><a href="#status（状态属性）" class="headerlink" title="status（状态属性）"></a>status（状态属性）</h4><p><strong>status属性值格式</strong>：<code>status=&quot;string&quot;</code><br><strong>string表示设备状态</strong></p><table><thead><tr><th align="center">string值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">okay</td><td align="center">设备可操作</td></tr><tr><td align="center">disabled</td><td align="center">非使能状态，不可操作</td></tr><tr><td align="center">fail</td><td align="center">设备错误，不可操作</td></tr><tr><td align="center">fail-sss</td><td align="center">同fail，sss为错误信息</td></tr></tbody></table><h4 id="address-cells-和-size-cells"><a href="#address-cells-和-size-cells" class="headerlink" title="#address-cells 和 #size-cells"></a>#address-cells 和 #size-cells</h4><p>可用于任何拥有子节点的设备树节点中，用于描述子节点地址信息<br><strong>属性值格式</strong>：<code>#address-cells=&lt;1&gt;  #size-cells=&lt;0&gt;</code></p><ol><li><strong>#address-cells</strong>:描述子节点中reg属性中地址信息占用的字长</li><li><strong>#size-cells</strong>:描述子节点reg属性中长度信息占用的字长</li></ol><h4 id="reg-（设备地址空间资源属性）"><a href="#reg-（设备地址空间资源属性）" class="headerlink" title="reg （设备地址空间资源属性）"></a>reg （设备地址空间资源属性）</h4><p><strong>reg属性值格式</strong>：<code>reg=&lt;address length&gt;</code><br><strong>address</strong>: 空间首地址<br><strong>length</strong>: 空间长度</p><h4 id="ranges-（地址映射表，可以为空）"><a href="#ranges-（地址映射表，可以为空）" class="headerlink" title="ranges （地址映射表，可以为空）"></a>ranges （地址映射表，可以为空）</h4><p><strong>ranges属性值格式</strong>：<code>ranges=&lt;child-bus-address parent-bus-address length&gt;</code><br><strong>child-bus-address</strong>:子总线起始地址<br><strong>parent-bus-address</strong>:父总线起始地址<br><strong>length</strong>:长度</p><h3 id="查找节点属性的of操作函数"><a href="#查找节点属性的of操作函数" class="headerlink" title="查找节点属性的of操作函数"></a>查找节点属性的of操作函数</h3><p><mark> 包含头文件：<code>&lt;linux/of.h&gt;</code></mark></p><h4 id="查找节点函数"><a href="#查找节点函数" class="headerlink" title="查找节点函数"></a>查找节点函数</h4><ul><li><strong>使用结构体struct device_node 表示设备节点</strong></li></ul><ol><li><code>struct device_node *of_find_node_by_name(struct device_node *from, const char *name)</code><br> <strong>from</strong>：起始节点，为NULL时从根节点开始查找<br> <strong>name</strong>：需要查找的节点名称<br> <strong>返回值</strong>：找到的节点指针，如果为NULL表示查找失败 <br/></li><li><code>struct device_node *of_find_node_by_type(struct device_node *from, const char *type)</code><br> <strong>from</strong>：起始节点，为NULL时从根节点开始查找<br> <strong>type</strong>：需要查找的节点类型<br> <strong>返回值</strong>：找到的节点指针，如果为NULL表示查找失败 <br/></li><li><code>struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible)</code><br> <strong>from</strong>：起始节点，为NULL时从根节点开始查找<br> <strong>type</strong>：需要查找的节点类型<br> <strong>compatible</strong>：节点兼容性属性<br> <strong>返回值</strong>：找到的节点指针，如果为NULL表示查找失败 <br/></li><li><code>struct device_node *of_find_node_by_path(consy char *path)</code><br><strong>path</strong>：带有全路径的节点名<br><strong>返回值</strong>：找到的节点指针，如果为NULL表示查找失败</li></ol><h4 id="查找父节点和子节点函数"><a href="#查找父节点和子节点函数" class="headerlink" title="查找父节点和子节点函数"></a>查找父节点和子节点函数</h4><ol><li><code>struct device_node *of_get_parent(const struct device_node *node)</code><br><strong>node</strong>：子节点指针<br><strong>返回值</strong>：找到的父节点指针，如果为NULL表示查找失败<br/></li><li>struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev)<br><strong>node</strong>：父节点指针<br><strong>prev</strong>：前一个子节点，也就是设置从哪个子节点开始迭代查找，如果设置为NULL，表示从第一个子节点开始</li></ol><h4 id="提取节点属性值函数"><a href="#提取节点属性值函数" class="headerlink" title="提取节点属性值函数"></a>提取节点属性值函数</h4><p><mark>使用结构体<code>struct property</code>表示节点属性</mark><br><strong>property原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *name;   <span class="hljs-comment">//属性名字</span><br>    <span class="hljs-type">int</span> length;   <span class="hljs-comment">//属性长度</span><br>    <span class="hljs-type">void</span> *value;  <span class="hljs-comment">//属性值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//下一个属性指针</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _flags;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> unique_id;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bin_attrbiute</span> <span class="hljs-title">attr</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>查找指定属性<br><code>struct property *of_find_property(const struct device_node *np, const char *name, int *lenp)</code><br><strong>np</strong>：设备节点<br><strong>name</strong>：需要查找的属性名字<br><strong>lenp</strong>：属性值的字节数<br><strong>返回值</strong>：查找到的属性，NULL表示失败</p><br/></li><li><p>获取属性中元素数量<br><code>int of_property_cunt_elems_of_size(const struct device_node *np, const char *propname, int elemsize)</code><br><strong>np</strong>：设备节点<br><strong>propname</strong>：属性名字<br><strong>elemsize</strong>：元素长度<br><strong>返回值</strong>：元素个数</p><br/></li><li><p>读u32数组元素值<br><code>int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *outv_alue)</code><br><strong>np</strong>：设备节点<br><strong>propname</strong>：属性名称<br><strong>index</strong>：要读取的u32类型数据下标<br><strong>out_value</strong>:读取到的值存入此地址<br><strong>返回值</strong>：0-成功  负值-失败</p><br/></li><li><p>读属性中的数组数据</p><ul><li><code>int of_property_read_u8_arry (struct device_node *np,const char *propname,u8 *out_values,size_t sz)</code></li><li><code>int of_property_read_u16_arry (struct device_node *np,const char *propname,u16 *out_values,size_t sz)</code></li><li><code>int of_property_read_u32_arry (struct device_node *np,const char *propname,u32 *out_values,size_t sz)</code></li><li><code>int of_property_read_u64_arry (struct device_node *np,const char *propname,u64 *out_values,size_t sz)</code><br><strong>np</strong>：设备节点<br><strong>propname</strong>：属性名<br><strong>out_values</strong>：读取到的数组值存储位置的首地址<br><strong>sz</strong>：要读取的数组元素的数量<br/></li></ul></li><li><p>读取数组中的整型值（属性只有一个整型值）</p><ul><li><code>int of_property_read_u8(struct device_node *nd, const char * propname,u8 *outvalue)</code></li><li><code>int of_property_read_u16(struct device_node *nd, const char * propname,u16 *outvalue)</code></li><li><code>int of_property_read_u32(struct device_node *nd, const char * propname,u32 *outvalue)</code></li><li><code>int of_property_read_u64(struct device_node *nd, const char * propname,u64 *outvalue)</code><br><strong>nd</strong>：设备节点<br><strong>propname</strong>：属性名称<br><strong>outvalue</strong>: 值存储到此地址<br>返回值：0-成功 负值-失败</br></li></ul></li><li><p>读取属性中的字符串<br><code>int of_property_read_string(struct device_node *np, const char *propname, char **out_string);</code><br><strong>nd</strong>：设备节点<br><strong>propname</strong>：属性名称<br><strong>outvalue</strong>: 字符串储存地址<br>返回值：0-成功 负值-失败</p></br></li><li><p>读取#address-cells值<br><code>int of_n_addr_cells(struct device_node *np)</code><br><strong>np</strong>：设备节点<br><strong>返回值</strong>：addr-cell的值</p><br/></li><li><p>读取#size-cells值<br><code>int of_n_size_cells(struct device_node *np)</code><br><strong>np</strong>：设备节点<br><strong>返回值</strong>：size-cell的值</p></li></ol><h4 id="其他常用of函数"><a href="#其他常用of函数" class="headerlink" title="其他常用of函数"></a>其他常用of函数</h4><ol><li><p>检查设备节点兼容性<br><code>int of_device_is_compatible(struct device_node *np, const char *compat)</code><br><strong>np</strong>：设备节点<br><strong>compat</strong>：要检查的兼容性字符串<br><strong>返回值</strong>：0-compatible属性中不包含此字符串<br>       1-compatible属性中包含此字符串</p><br/></li><li><p>获取地址相关属性<br><code>const __be32 *of_get_address(struct device_node *np,int index, u64 *size, unsigned int *flags)</code><br><strong>np</strong>：设备节点<br><strong>index</strong>: 要读取的地址标号<br><strong>size</strong>：地址长度<br><strong>flags</strong>：参数 IORESOURCE_IOIORESOURCE_MEM 等<br><strong>返回值</strong>：读到的地址数据首地址，为NULL表示读取失败</p></li></ol><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>   ]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符设备框架</title>
    <link href="/2022/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="通用头文件"><a href="#通用头文件" class="headerlink" title="通用头文件"></a>通用头文件</h3><p>以下三个头文件几乎所有的linux驱动代码都需要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="设备结构体并创建设备对象"><a href="#设备结构体并创建设备对象" class="headerlink" title="设备结构体并创建设备对象"></a>设备结构体并创建设备对象</h3><h4 id="定义设备结构体"><a href="#定义设备结构体" class="headerlink" title="定义设备结构体"></a>定义设备结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xxx_CNT 1      <span class="hljs-comment">//设备数量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xxx_NAME  <span class="hljs-string">&quot;xxx&quot;</span>  <span class="hljs-comment">//驱动名称</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span>&#123;</span><br>    <span class="hljs-type">dev_t</span> devid;        <span class="hljs-comment">//设备号</span><br>    <span class="hljs-type">int</span> major;          <span class="hljs-comment">//主设备号</span><br>    <span class="hljs-type">int</span> minor;          <span class="hljs-comment">//从设备号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span>   <span class="hljs-comment">//cdev结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">//类结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span>  <span class="hljs-comment">//设备结构体</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>cdev</strong> 需要包含头文件<mark>#include &lt;linux&#x2F;cdev.h&gt;</mark><br><strong>class和device</strong>需要包含头文件<mark>#include &lt;linux&#x2F;devices.h&gt;</mark></p><h4 id="创建设备对象"><a href="#创建设备对象" class="headerlink" title="创建设备对象"></a>创建设备对象</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> <span class="hljs-title">xxx</span>;</span><br></code></pre></td></tr></table></figure><h3 id="file-operation集各项函数具体实现"><a href="#file-operation集各项函数具体实现" class="headerlink" title="file_operation集各项函数具体实现"></a>file_operation集各项函数具体实现</h3><h4 id="open函数具体实现"><a href="#open函数具体实现" class="headerlink" title="open函数具体实现"></a>open函数具体实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xxx_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    filp-&gt;private_data = &amp;xxx; 将设备结构体对象设为私有数据<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read函数具体实现"><a href="#read函数具体实现" class="headerlink" title="read函数具体实现"></a>read函数具体实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">xxx_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx_dev</span> *<span class="hljs-title">dev</span> =</span> (xxx_dev *)filp-&gt;private_data;   <span class="hljs-comment">//获取私有数据</span><br>    copy_to_user(目标buf, 源, cnt);<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>copy_to_uaer</strong>函数需要包含头文件<code>#include &lt;asm/uaccess.h&gt;</code></p><h4 id="write函数具体实现"><a href="#write函数具体实现" class="headerlink" title="write函数具体实现"></a>write函数具体实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">xxx_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br>    copy_from_user(目标buf, 源, cnt);<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="release函数具体实现"><a href="#release函数具体实现" class="headerlink" title="release函数具体实现"></a>release函数具体实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">XXX_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设备操作函数集合-需包含头文件-include-lt-linux-fs-h-gt"><a href="#设备操作函数集合-需包含头文件-include-lt-linux-fs-h-gt" class="headerlink" title="设备操作函数集合 需包含头文件#include &lt;linux/fs.h&gt;"></a>设备操作函数集合 需包含头文件<code>#include &lt;linux/fs.h&gt;</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">xxx_fops</span>=</span><br>&#123;<br>    .owner = THIS_MODUle,       <span class="hljs-comment">//模块拥有者</span><br>    .open = xxx_open,           <span class="hljs-comment">//open函数具体实现       </span><br>    .read = xxx_read,           <span class="hljs-comment">//read函数具体实现</span><br>    .write = xxx_write,         <span class="hljs-comment">//write函数具体实现</span><br>    .release = xxx_release,     <span class="hljs-comment">//release函数具体实现</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="模块入口函数"><a href="#模块入口函数" class="headerlink" title="模块入口函数"></a>模块入口函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ...<br>    ...<br>    <span class="hljs-comment">/* 分配设备号 */</span><br>    <span class="hljs-keyword">if</span>(xxx.major)       <span class="hljs-comment">//如果已经分配主设备号</span><br>    &#123;<br>        xxx.devid = MKDIR(xxx.major, <span class="hljs-number">0</span>);  <span class="hljs-comment">//创建设备号</span><br>        register_chrdev_region(XXX.devid, xxx_CNT, xxx_NAME);  <span class="hljs-comment">//注册设备号</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        alloc_chrdev_region(&amp;xxx.devid, <span class="hljs-number">0</span>, xxx_CNT, xxx_NAME);  <span class="hljs-comment">//分配设备号 0为从设备号起始值</span><br>        xxx.major = MAJOR(xxx.devid);<br>        xxx.minor = MINOR(xxx.devid);<br>    &#125;<br><br>    <span class="hljs-comment">/*初始化cdev*/</span><br>    xxx.cdev.owner = THIS_MODULE;<br>    cdev_init(&amp;xxx.cdev, &amp;xxx_fops);<br>    <span class="hljs-comment">/*添加cdev*/</span><br>    cdev_add(&amp;xxx.cdev, xxx.devid, xxx_CNT);<br><br>    <span class="hljs-comment">/* 创建类 */</span><br>    xxxx-&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> =</span> class_create(THIS_MODULE, xxx_NAME);<br>    <span class="hljs-comment">/* 类下创建设备 */</span><br>    xxx-&gt;device = device_create(xxx.class, <span class="hljs-literal">NULL</span>, xxx.devid, <span class="hljs-literal">NULL</span>, xxx_NAME);<br><br>    ...<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出口函数形式"><a href="#出口函数形式" class="headerlink" title="出口函数形式"></a>出口函数形式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">xxx_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    cdev_del(&amp;xxx.cdev);     <span class="hljs-comment">//删除cdev</span><br>    unregister_chrdev_region(xxx.devid, xxx_CNT);  <span class="hljs-comment">//注销字符设备</span><br>    device_destroy(xxx-&gt;class, xxx-&gt;device);<br>    class_destroy(xxx-&gt;class);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模块入口和模块出口"><a href="#模块入口和模块出口" class="headerlink" title="模块入口和模块出口"></a>模块入口和模块出口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">module_init(xxx_init);    <span class="hljs-comment">//模块入口</span><br>module_exit(xxx_exit);    <span class="hljs-comment">//模块出口</span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);    <span class="hljs-comment">//模块协议</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;Hector&quot;</span>);  <span class="hljs-comment">//模块作者</span><br></code></pre></td></tr></table></figure><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Makefile详解</title>
    <link href="/2022/09/21/Makefile/"/>
    <url>/2022/09/21/Makefile/</url>
    
    <content type="html"><![CDATA[<h3 id="Makefile-简介"><a href="#Makefile-简介" class="headerlink" title="Makefile 简介"></a>Makefile 简介</h3><ul><li>Makefile作用：<strong>记录依赖关系和编译规则；</strong></li><li>Makefile三要素：<strong>目标、依赖、命令</strong></li><li>Makefile基本格式：<br>  目标：依赖的文件或者其他目标<br>  &lt;tab&gt;命令1<br>  &lt;tab&gt;命令2<br>  …</li><li>设置伪目标：.PHONY: clean</li><li>指定Makefile文件：make -f Makefile2</li></ul><h3 id="Makefile变量及模式规则"><a href="#Makefile变量及模式规则" class="headerlink" title="Makefile变量及模式规则"></a>Makefile变量及模式规则</h3><ul><li>自定义变量</li></ul><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">延时赋值（调用时赋值）</td></tr><tr><td align="center">:&#x3D;</td><td align="center">立即赋值</td></tr><tr><td align="center">?&#x3D;</td><td align="center">空赋值（变量为空时赋值）</td></tr><tr><td align="center">+&#x3D;</td><td align="center">追加赋值（不覆盖原值，在后面追加）</td></tr></tbody></table><ul><li><p>自动化变量</p><ol><li>$&lt; 第一个依赖文件</li><li>$^ 所有的依赖文件</li><li>$@ 目标文件</li></ol></li><li><p>模式匹配：%匹配任意多个非空字符</p></li><li><p>默认规则：.o文件默认.c文件编译</p></li></ul><h3 id="Makefile条件分支"><a href="#Makefile条件分支" class="headerlink" title="Makefile条件分支"></a>Makefile条件分支</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span>(var1,var2)       |         <span class="hljs-keyword">ifneq</span>(var1,var2)<br>    ...               |             ...<br><span class="hljs-keyword">else</span>                  |         <span class="hljs-keyword">else</span><br>    ...               |             ...<br><span class="hljs-keyword">endif</span>                 |         <span class="hljs-keyword">endif</span> <br></code></pre></td></tr></table></figure><h3 id="Makefile常用函数"><a href="#Makefile常用函数" class="headerlink" title="Makefile常用函数"></a>Makefile常用函数</h3><ul><li>patsubst(模式替换函数): <code>$&#123;patsubst pattern, replace_pattern, text&#125;</code> %作通配符</li><li>notdir(取文件名函数): <code>$&#123;notdir .../.../name&#125;</code>去掉目录部分只取文件名</li><li>wildcard(取匹配文件名函数)：<code>$&#123;wildcard pattern&#125;</code>取当前目录下所有符合pattern模式的文件名，*作通配符</li><li>foreach(遍历函数)：<code>$&#123;foreach var, list, text&#125;</code>将list中每一个单词赋值给var,然后在text中使用var</li></ul><h3 id="编写Makefile"><a href="#编写Makefile" class="headerlink" title="编写Makefile"></a>编写Makefile</h3><ul><li>创建目录用于存储编译过程中生成的文件：BUILD_DIR</li><li>源文件目录（存放.c及.s后缀文件）：SRC_DIR</li><li>头文件目录（存放.h文件）：INC_DIR</li><li>搜索路径关键字：VPATH</li><li>编译器头文件路径：CFLAGS -I + 头文件路径</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> ($&#123;ARCH&#125;,x86)   //判断当前编译环境 win上编译命令：make ARCH=x86<br>CC = gcc<br><span class="hljs-keyword">else</span><br>CC = arm-linux-gnuenbihf-gcc<br><span class="hljs-keyword">endif</span><br><br>TARGET = output     //输出可执行文件名<br>BUILD_DIR = build   //生成文件储存目录<br>SRC_DIR = .         //源文件存储于当前面目录<br>INC_DIR = .         //头文件存储与当前目录<br><br>SOURCES_C = $&#123;foreach dir,$&#123;SRC_DIR&#125;,$&#123;wildcard $&#123;dir&#125;/*.c&#125;&#125;   //所有.c文件路径<br>SOURCES_S = $&#123;foreach dir,$&#123;SRC_DIR&#125;,$&#123;wildcard $&#123;dir&#125;/*.s&#125;&#125;   //所有.s文件路径<br>INCLUDES = $&#123;foreach dir,$&#123;INC_DIR&#125;,$&#123;wildcard $&#123;dir&#125;/*.h&#125;&#125;    //所有头文件路径<br>OBJS = $&#123;patsubst %.c,$&#123;BUILD_DIR&#125;/%.o,$&#123;notdir $&#123;SOURCES_C&#125;&#125;&#125; //.c文件生成的.o文件名<br>OBJS += $&#123;patsubst %.s,$&#123;BUILD_DIR&#125;/%.o,$&#123;notdir $&#123;SOURCES_C&#125;&#125;&#125; //.s文件生成的.o文件名<br>VPATH = $&#123;SRC_DIR&#125;   //编译器搜索路径为源文件路径<br>CFLAGS = $&#123;patsubst %,-I%,$&#123;INC_DIR&#125;&#125;  //编译器头文件路径<br><br><span class="hljs-section">$&#123;BUILD_DIR&#125;/$&#123;TARGET&#125;:$&#123;OBJS&#125;</span><br>$&#123;CC&#125; <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> $&#123;CFLAGS&#125;<br><br><span class="hljs-section">$&#123;BUILD_DIR&#125;/%.o:%.c $&#123;INCLUDES&#125; | create_build</span><br>$&#123;CC&#125; -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span> $&#123;CFLAGS&#125;<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean create_build  //伪目标</span><br><br><span class="hljs-section">clean:                     //make clean时执行清除rm命令</span><br>rm -r $&#123;BUILD_DIR&#125;<br><br><br><span class="hljs-section">create_build:             //创建build目录</span><br>mkdir -p $&#123;BUILD_DIR&#125;<br></code></pre></td></tr></table></figure><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Drivers</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="/2022/09/21/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/09/21/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>1.块级元素：占据一行或者多<br>2.行内元素：只占据自身所需要的空间</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">## 六级标题(标题前加#， 后留空格)：<br># 标题一 （# 标题一）<br>## 标题二 （## 标题二）<br>### 标题三 （### 标题三）<br># ...<br></code></pre></td></tr></table></figure><h1 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h1><h2 id="引用（前加-gt-）："><a href="#引用（前加-gt-）：" class="headerlink" title="引用（前加 &gt; ）："></a>引用（前加 &gt; ）：</h2><blockquote><p>这是一段引用(&gt; 这是一段引用)</p></blockquote><h2 id="无序列表（前加-或者-）："><a href="#无序列表（前加-或者-）：" class="headerlink" title="无序列表（前加 - 或者 *）："></a>无序列表（前加 - 或者 *）：</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>第一步 (- 第一步)<br><span class="hljs-bullet">* </span>第二步 (* 第二步)<br><span class="hljs-bullet">- </span>第三步<br><span class="hljs-bullet">- </span>...<br></code></pre></td></tr></table></figure><ul><li>第一步 (- 第一步)</li></ul><ul><li>第二步 (* 第二步)</li></ul><ul><li>第三步</li><li>…</li></ul><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>（前加 -  [ ] 注意加空格 中括号中加x表示任务完成]）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">- <span class="hljs-selector-attr">[ ]</span> 吃饭 (- <span class="hljs-selector-attr">[ ]</span> 吃饭)<br>- <span class="hljs-selector-attr">[x]</span> 睡觉 (- <span class="hljs-selector-attr">[x]</span> 睡觉)<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 吃饭 (- [ ] 吃饭)</li><li><input checked="" disabled="" type="checkbox"> 睡觉 (- [x] 睡觉)</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>三个反引号 + 语言类型  结束用三个反引号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mian</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world \r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">姓名</span>|<span class="hljs-string">年龄</span>|<span class="hljs-string">成绩</span>|<br>|<span class="hljs-string">:---:</span>|<span class="hljs-string">:---:</span>|<span class="hljs-string">:---:</span>|<br>|<span class="hljs-string">张三</span>|<span class="hljs-string">24</span>|<span class="hljs-string">89</span>|<br>|<span class="hljs-string">李四</span>|<span class="hljs-string">23</span>|<span class="hljs-string">98</span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">姓名</th><th align="center">年龄</th><th align="center">成绩</th></tr></thead><tbody><tr><td align="center">张三</td><td align="center">24</td><td align="center">89</td></tr><tr><td align="center">李四</td><td align="center">23</td><td align="center">98</td></tr></tbody></table><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">一键三连<span class="hljs-selector-attr">[^三连]</span><br></code></pre></td></tr></table></figure><p>一键三连[^三连]</p><h2 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><hr><h1 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[百度]</span>(www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> <span class="hljs-string">&quot;一个搜索引擎&quot;</span>)<br></code></pre></td></tr></table></figure><p><a href="http://www.baidu.com/" title="一个搜索引擎">百度</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">![图片]( /images/自由动态.png )<br>&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;/images/自由动态.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;20%&quot;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;20%&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="/images/%E8%87%AA%E7%94%B1%E5%8A%A8%E6%80%81.png" alt="图片"></p><div align=center><img src="/images/自由动态.png" width="20%" height="20%"></div><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体*</span>  <span class="hljs-strong">**加粗**</span> <span class="hljs-code">`printf(&quot;hello world&quot;);`</span> &lt;u&gt;下划线&lt;/u&gt;<br><span class="hljs-meta">:simile:</span><br>H&lt;sub&gt;2&lt;/sub&gt;O  X&lt;sup&gt;2&lt;sup&gt;  &lt;mark&gt;这是一段高亮文字&lt;/mark&gt;<br></code></pre></td></tr></table></figure><p><em>斜体</em>  <strong>加粗</strong> <code>printf(&quot;hello world&quot;);</code> <u>下划线</u></p><p>:smile:</p><p>H<sub>2</sub>O  X<sup>2</sup></p><p><mark>这是一段高亮文字</mark></p><!--PC版--><div id="SOHUCS" ></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cywhVLBNm',conf: 'prod_449188a899f144a2be2e05b0a1b8f390'});</script>]]></content>
    
    
    <categories>
      
      <category>others</category>
      
      <category>MarkDown</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>



<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Hector">
  <meta name="keywords" content="">
  
    <meta name="description" content="浅析d71 komeda driver 框架">
<meta property="og:type" content="article">
<meta property="og:title" content="d71 komeda driver">
<meta property="og:url" content="http://example.com/2023/04/25/d71%20komeda_driver/index.html">
<meta property="og:site_name" content="Hector&#39;s Blog Page">
<meta property="og:description" content="浅析d71 komeda driver 框架">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/d71_images/single%20pipeline%20data%20flow.png">
<meta property="og:image" content="http://example.com/images/d71_images/slave%20pipeline.png">
<meta property="og:image" content="http://example.com/images/d71_images/layer%20input%20flow.png">
<meta property="og:image" content="http://example.com/images/d71_images/layer%20split%20pipeline.png">
<meta property="og:image" content="http://example.com/images/d71_images/writeback%20data%20flow.png">
<meta property="og:image" content="http://example.com/images/d71_images/writeback%20split%20data%20flow.png">
<meta property="og:image" content="http://example.com/images/d71_images/display%20data%20flow.png">
<meta property="article:published_time" content="2023-04-25T13:50:23.000Z">
<meta property="article:modified_time" content="2023-04-25T14:35:00.914Z">
<meta property="article:author" content="Hector">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/d71_images/single%20pipeline%20data%20flow.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>d71 komeda driver - Hector&#39;s Blog Page</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  


<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Hector</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">d71 komeda driver</span>
          
        </div>

      </br>
      </br>
        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-25 21:50" pubdate>
          2023年4月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          226 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div> 
</div>



</div>


  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">d71 komeda driver</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-D71-资源概述"><a href="#1-D71-资源概述" class="headerlink" title="1 D71 资源概述"></a>1 D71 资源概述</h1><h1 id="1-1-D71-IP概览"><a href="#1-1-D71-IP概览" class="headerlink" title="1.1 D71 IP概览"></a>1.1 D71 IP概览</h1><ul>
<li>D71采用灵活的、模块化的架构。一个display pipieline由多个独立的components组成，每个component拥有自身特殊的功能对显示流程中的像素数据进行处理。</li>
<li>D71 component<ul>
<li>Layer<blockquote>
<p>pipeline的第一个阶段，其功能是为下一阶段准备像素数据。具体工作为：</p>
</blockquote>
<ul>
<li>从内存中获取像素数据，如果数据是AFBC(D71中使用的一种帧缓冲压缩方法)，Layer还负责对数据进行解码。</li>
<li>旋转源图像数据(rotate)</li>
<li>将YUV格式像素转换为RGB</li>
</ul>
</li>
<li>Scaler<blockquote>
<p>负责图形缩放。用法极其灵活</p>
</blockquote>
<ul>
<li>连接至Layer的输出用作Layer的缩放</li>
<li>连接至Compositor对整个显示帧进行缩放，同时也可以通过wb_layer将缩放后的显示帧写回内存</li>
</ul>
</li>
<li>Compositor<blockquote>
<p>将多个Layer或者像素数据流混合为一个显示帧</p>
</blockquote>
<ul>
<li>输出帧可以接至improc用于显示</li>
<li>输出帧可以接至wb_layer写回内存</li>
<li>用户可以在Compositor和wb_layer之间加入一个Scaler对显示帧进行缩放之后在写回memory</li>
</ul>
</li>
<li>Writeback Layer(wb_layer)<blockquote>
<p>连接至Compositor，将Compositor的处理结果写回memory</p>
</blockquote>
</li>
<li>Post Image Processor(improc)<blockquote>
<p>调整帧数据，比如gamma值和像素的color space等，使像素格式匹配显示器</p>
</blockquote>
</li>
<li>Timing controller(timing_ctrlr)<blockquote>
<p>display pipeline的最后阶段，用于控制显示时序</p>
</blockquote>
</li>
<li>Merger<blockquote>
<p>D71的scaler只有Layer一半的输入输出能力，比如Layer支持4k，scaler就只支持2k。为了实现全帧显示，D71引入了<strong>Layer Split</strong>，将一副画面分割成两份，分别使用两个Layer，然后针对两个Layer独立使用Scaler进行缩放，最后通过Merger将两个缩放完成后的画面融合成一幅画面，然后将结果输出至compositor。</p>
</blockquote>
</li>
<li>Splitter<blockquote>
<p>与Layer Split功能相似，当时此component针对的是writeback，将compositor的输出结果分割成两幅画面，再独立缩放后写回内存</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="1-2-possible-D71-Pipeline-usage"><a href="#1-2-possible-D71-Pipeline-usage" class="headerlink" title="1.2 possible D71 Pipeline usage"></a>1.2 possible D71 Pipeline usage</h1><ul>
<li>D71拥有两个display pipeline，因此支持两种工作模式：<ul>
<li>双显模式<blockquote>
<p>两个pipeline独立工作，分别驱动各自的display output</p>
</blockquote>
<ul>
<li>单个pipeline数据流程如下图：<br><img src="/../images/d71_images/single%20pipeline%20data%20flow.png" srcset="/img/loading.gif" lazyload alt="single pipeline data flow"></li>
</ul>
</li>
<li>单显模式<blockquote>
<p>两个pipeline同时工作，驱动同一个display output。此种模式下，可以将pipeline_B视为pipeline_A的从设备：pipeline_B将自身compositor的结果输出至pipeline_A，并且其pixel timing也从pipeline_A的timing ctrlr中获得。</p>
</blockquote>
<ul>
<li>单显模式下的数据流程如下图：<br><img src="/../images/d71_images/slave%20pipeline.png" srcset="/img/loading.gif" lazyload alt="slave pipeline"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="1-3-sub-pipeline"><a href="#1-3-sub-pipeline" class="headerlink" title="1.3 sub-pipeline"></a>1.3 sub-pipeline</h1><blockquote>
<p>根据pixel data flow的input&#x2F;output可以一个完整的pipeline划分为几个sub-pipeline：<br>以下3个sub-pipeline与KMS中的<strong>plane&#x2F;wb_conn&#x2F;crtc</strong>一一对应</p>
</blockquote>
<ul>
<li><p>Layer(input) pipeline</p>
<ul>
<li><p>layer input data flow</p>
<p><img src="/../images/d71_images/layer%20input%20flow.png" srcset="/img/loading.gif" lazyload alt="layer input data flow"></p>
</li>
<li><p>layer split pipeline</p>
<p><img src="/../images/d71_images/layer%20split%20pipeline.png" srcset="/img/loading.gif" lazyload alt="layer split pipeline"></p>
</li>
</ul>
</li>
<li><p>Writeback(output) pipeline</p>
<ul>
<li><p>writeback(output) data flow</p>
<p><img src="/../images/d71_images/writeback%20data%20flow.png" srcset="/img/loading.gif" lazyload alt="writeback data flow"></p>
</li>
<li><p>writeback split data flow</p>
<p><img src="/../images/d71_images/writeback%20split%20data%20flow.png" srcset="/img/loading.gif" lazyload alt="writeback split data flow"></p>
</li>
</ul>
</li>
<li><p>Display(output) pipeline</p>
<p>  <img src="/../images/d71_images/display%20data%20flow.png" srcset="/img/loading.gif" lazyload alt="display data flow"></p>
</li>
</ul>
<h1 id="1-4-komeda-资源的抽象"><a href="#1-4-komeda-资源的抽象" class="headerlink" title="1.4 komeda 资源的抽象"></a>1.4 komeda 资源的抽象</h1><blockquote>
<p>d71驱动侧同样采用了与硬件相似的架构，使用pipelin&#x2F;component描述硬件的特点和功能，每个的component都包含以下两部分：</p>
</blockquote>
<ul>
<li>数据流控制</li>
<li>component特征和功能<blockquote>
<p>下面对描述d71资源的各个数据结构进行说明：</p>
</blockquote>
</li>
</ul>
<h2 id="struct-komeda-component"><a href="#struct-komeda-component" class="headerlink" title="struct komeda_component"></a>struct komeda_component</h2><blockquote>
<p>驱动侧将所有的component的共性抽象出来，用komeda_component进行描述，所有的component都可以看作此结构体的子类</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct komeda_component describe the data flow capabilities for how to link a</span><br><span class="hljs-comment"> * component into the display pipeline.</span><br><span class="hljs-comment"> * all specified components are subclass of this structure.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_private_obj</span> <span class="hljs-title">obj</span>;</span>  <span class="hljs-comment">//将component视为一个provate obj</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">pipeline</span>;</span>  <span class="hljs-comment">//此component所属的pipeline</span><br>	<span class="hljs-type">char</span> name[<span class="hljs-number">32</span>];  <span class="hljs-comment">//component name</span><br>	u32 __iomem *reg; <span class="hljs-comment">//component基地址 由d71初始化，并且仅被d71使用</span><br>	u32 id;  <span class="hljs-comment">//component id</span><br>	u32 hw_id; <span class="hljs-comment">//component 硬件id 由d71初始化，并且仅被d71使用</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @max_active_inputs:</span><br><span class="hljs-comment">	 * @max_active_outputs:</span><br><span class="hljs-comment">     * 同一时刻 可以使用的最大数量的inputs/outputs </span><br><span class="hljs-comment">     * 此数据与supported_inputs/outputs的数量不同，后者表示最多支持的inputs/outputs数量</span><br><span class="hljs-comment">     * 但不一定所有的inputs/outputs可以同时使用</span><br><span class="hljs-comment">	 */</span><br>	u8 max_active_inputs;  <br>	u8 max_active_outputs;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @supported_inputs:</span><br><span class="hljs-comment">	 * @supported_outputs:</span><br><span class="hljs-comment">	 * bitmask of BIT(component-&gt;id) for the supported inputs/outputs,</span><br><span class="hljs-comment">     * 描述component连接至pipeline的方法</span><br><span class="hljs-comment">	 */</span><br>	u32 supported_inputs;<br>	u32 supported_outputs;<br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component_funcs</span> *<span class="hljs-title">funcs</span>;</span> <span class="hljs-comment">//访问硬件的方法</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="struct-komeda-component-output"><a href="#struct-komeda-component-output" class="headerlink" title="struct komeda_component_output"></a>struct komeda_component_output</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component_output</span> &#123;</span><br>	<span class="hljs-comment">/** @component: indicate which component the data comes from */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component</span> *<span class="hljs-title">component</span>;</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @output_port:</span><br><span class="hljs-comment">	 * the output port of the &amp;komeda_component_output.component</span><br><span class="hljs-comment">	 */</span><br>	u8 output_port;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="struct-komeda-component-state"><a href="#struct-komeda-component-state" class="headerlink" title="struct komeda_component_state"></a>struct komeda_component_state</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component_state</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_private_state</span> <span class="hljs-title">obj</span>;</span> <span class="hljs-comment">//使用drm_atomic_state跟踪此component state</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component</span> *<span class="hljs-title">component</span>;</span>  <span class="hljs-comment">//backpointer to the component</span><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc</span> *<span class="hljs-title">crtc</span>;</span>  <span class="hljs-comment">//backpointer for user crtc</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane</span> *<span class="hljs-title">plane</span>;</span>  <span class="hljs-comment">//backpointer for user plane</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_connector</span> *<span class="hljs-title">wb_conn</span>;</span>  <span class="hljs-comment">//backpointer for user wb_connector</span><br>		<span class="hljs-type">void</span> *binding_user;<br>	&#125;;<br>    u16 active_inputs;  <span class="hljs-comment">//active_inputs is bitmask of @inputs index</span><br>	u16 changed_active_inputs;  <span class="hljs-comment">//bitmask of the changed @active_inputs</span><br>	u16 affected_inputs;  <span class="hljs-comment">//bitmask for affected @inputs</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @inputs:</span><br><span class="hljs-comment">	 * the specific inputs[i] only valid on BIT(i) has been set in</span><br><span class="hljs-comment">	 * @active_inputs, if not the inputs[i] is undefined.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component_output</span> <span class="hljs-title">inputs</span>[<span class="hljs-title">KOMEDA_COMPONENT_N_INPUTS</span>];</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>关于<strong>bingding_user</strong>，前面在讲sub-pipeline的时候就提过，可以将几个sub-pipeline与kms中的plane&#x2F;wb_conn&#x2F;crtc对应起来，因此我们可以将kms中的各个组件视为d71各个component的user：</p>
</blockquote>
<ul>
<li>对于 <strong>Layer</strong>，user为<strong>plane</strong></li>
<li>对于<strong>compiz&#x2F;improc&#x2F;timing_ctrlr</strong>，user为<strong>crtc</strong></li>
<li>对于<strong>wb_layer</strong>，user为<strong>wb_conn</strong></li>
<li>对于<strong>Scaler</strong>，当它连接至<strong>Layer</strong>时，user为<strong>plane</strong>，当它连接至<strong>compiz</strong>时，user为<strong>wb_conn</strong></li>
</ul>
<h2 id="struct-komeda-pipeline"><a href="#struct-komeda-pipeline" class="headerlink" title="struct komeda_pipeline"></a>struct komeda_pipeline</h2><blockquote>
<p>Represent a complete display pipeline and hold all functional components.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_private_obj</span> <span class="hljs-title">obj</span>;</span>  <span class="hljs-comment">//link pipeline as private obj of drm_atomic_state</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev</span> *<span class="hljs-title">mdev</span>;</span>  <span class="hljs-comment">//the parent komeda_dev</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk</span> *<span class="hljs-title">pxlclk</span>;</span>  <span class="hljs-comment">//pixel clock</span><br>	<span class="hljs-type">int</span> id;  <span class="hljs-comment">//pipeline id </span><br>	u32 avail_comps;  <span class="hljs-comment">//available components mask of pipeline</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @standalone_disabled_comps:</span><br><span class="hljs-comment">	 * When disable the pipeline, some components can not be disabled</span><br><span class="hljs-comment">	 * together with others, but need a sparated and standalone disable.</span><br><span class="hljs-comment">	 * The standalone_disabled_comps are the components which need to be</span><br><span class="hljs-comment">	 * disabled standalone, and this concept also introduce concept of</span><br><span class="hljs-comment">	 * two phase.</span><br><span class="hljs-comment">	 * phase 1: for disabling the common components.</span><br><span class="hljs-comment">	 * phase 2: for disabling the standalong_disabled_comps.</span><br><span class="hljs-comment">	 */</span><br>	u32 standalone_disabled_comps;<br>	<span class="hljs-type">int</span> n_layers;  <span class="hljs-comment">//the number of layer on @layers</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_layer</span> *<span class="hljs-title">layers</span>[<span class="hljs-title">KOMEDA_PIPELINE_MAX_LAYERS</span>];</span>  <span class="hljs-comment">//the pipeline layers</span><br>	<span class="hljs-type">int</span> n_scalers;  <span class="hljs-comment">//the number of scaler on @scalers</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_scaler</span> *<span class="hljs-title">scalers</span>[<span class="hljs-title">KOMEDA_PIPELINE_MAX_SCALERS</span>];</span>  <span class="hljs-comment">//the pipeline scalers</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_compiz</span> *<span class="hljs-title">compiz</span>;</span>  <span class="hljs-comment">//compositor</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_splitter</span> *<span class="hljs-title">splitter</span>;</span>  <span class="hljs-comment">//for split the compiz output to two half data flows</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_merger</span> *<span class="hljs-title">merger</span>;</span>  <br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_layer</span>  *<span class="hljs-title">wb_layer</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_improc</span> *<span class="hljs-title">improc</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_timing_ctrlr</span> *<span class="hljs-title">ctrlr</span>;</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline_funcs</span> *<span class="hljs-title">funcs</span>;</span>  <span class="hljs-comment">//chip private pipeline functions</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">of_node</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">of_output_port</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">of_output_links</span>[2];</span>  <span class="hljs-comment">//output connector device nodes</span><br>	<span class="hljs-type">bool</span> dual_link;  <span class="hljs-comment">//true if of_output_links[0] and [1] are both valid</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="struct-komeda-pipeline-state"><a href="#struct-komeda-pipeline-state" class="headerlink" title="struct komeda_pipeline_state"></a>struct komeda_pipeline_state</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline_state</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_private_state</span> <span class="hljs-title">obj</span>;</span>  <span class="hljs-comment">//tracking pipeline_state by drm_atomic_state</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">//backpointer to the pipeline</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc</span> *<span class="hljs-title">crtc</span>;</span>  <span class="hljs-comment">//当前绑定的crtc</span><br>	u32 active_comps;  <span class="hljs-comment">//bitmask - BIT(component-&gt;id) of active components</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="1-5-d71资源获取与初始化"><a href="#1-5-d71资源获取与初始化" class="headerlink" title="1.5 d71资源获取与初始化"></a>1.5 d71资源获取与初始化</h1><blockquote>
<p>由于Komeda不仅仅只作d71的驱动，还要兼容后续设备，因此将komeda device划分为了两层：</p>
</blockquote>
<ul>
<li>CORE：共有的特点和功能</li>
<li>CHIP：寄存器操作和硬件特点</li>
<li>CORE可以通过三个函数集访问CHIP<ul>
<li>struct komeda_dev_funcs</li>
<li>struct komeda_pipeline_funcs</li>
<li>struct komeda_component_funcs</li>
</ul>
</li>
<li>而关于设备资源的获取和初始化，集中在komeda_dev_funcs中</li>
</ul>
<h2 id="struct-komeda-dev-funcs"><a href="#struct-komeda-dev-funcs" class="headerlink" title="struct komeda_dev_funcs"></a>struct komeda_dev_funcs</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev_funcs</span> &#123;</span><br>	<span class="hljs-type">void</span> (*init_format_table)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//初始化komeda_dev-&gt;format_table，此函数需要在enum_resource前调用</span><br>	<span class="hljs-type">int</span> (*enum_resources)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//向core中添加pipeline或者component资源</span><br>	<span class="hljs-type">void</span> (*cleanup)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//clean komeda_dev-&gt;chip data</span><br>	<span class="hljs-type">int</span> (*connect_iommu)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//Optional, connect to external iommu</span><br>	<span class="hljs-type">int</span> (*disconnect_iommu)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);  <span class="hljs-comment">//Optional, disconnect to external iommu</span><br>	<span class="hljs-type">irqreturn_t</span> (*irq_handler)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-keyword">struct</span> komeda_events *events);  <span class="hljs-comment">//中断处理</span><br>	<span class="hljs-type">int</span> (*enable_irq)(<span class="hljs-keyword">struct</span> komeda_dev *mdev); <br>	<span class="hljs-type">int</span> (*disable_irq)(<span class="hljs-keyword">struct</span> komeda_dev *mdev);<br>	<span class="hljs-type">void</span> (*on_off_vblank)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-type">int</span> master_pipe, <span class="hljs-type">bool</span> on);  <span class="hljs-comment">//告知硬件开/关vblank</span><br>	<span class="hljs-type">void</span> (*dump_register)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-keyword">struct</span> seq_file *seq);<br>	<span class="hljs-type">int</span> (*change_opmode)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-type">int</span> new_mode);  <span class="hljs-comment">//Notify HW to switch to a new display operation mode</span><br>	<span class="hljs-type">void</span> (*flush)(<span class="hljs-keyword">struct</span> komeda_dev *mdev, <span class="hljs-type">int</span> master_pipe, u32 active_pipes);  <span class="hljs-comment">//Notify the HW to flush or kickoff the update</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>此函数集由chip .data引入（xxx_identify）</p>
</blockquote>
<h2 id="struct-komeda-dev"><a href="#struct-komeda-dev" class="headerlink" title="struct komeda_dev"></a>struct komeda_dev</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br>	u32 __iomem   *reg_base;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_dma_parameters</span> <span class="hljs-title">dma_parms</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_chip_info</span> <span class="hljs-title">chip</span>;</span>  <span class="hljs-comment">//描述chip的特性</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps_table</span> <span class="hljs-title">fmt_tbl</span>;</span>  <span class="hljs-comment">//initialized by &amp;komeda_dev_funcs-&gt;init_format_table</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clk</span> *<span class="hljs-title">aclk</span>;</span>  <br>	<span class="hljs-type">int</span> irq;  <span class="hljs-comment">//中断号</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">lock</span>;</span><br>	u32 dpmode;  <span class="hljs-comment">//当前显示模式</span><br>	<span class="hljs-type">int</span> n_pipelines;  <span class="hljs-comment">//the number of pipe in @pipelines</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">pipelines</span>[<span class="hljs-title">KOMEDA_MAX_PIPELINES</span>];</span>  <span class="hljs-comment">//the komeda pipelines</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev_funcs</span> *<span class="hljs-title">funcs</span>;</span>  <span class="hljs-comment">//chip funcs to access to HW</span><br>	<span class="hljs-type">void</span> *chip_data;  <span class="hljs-comment">//chip data will be added by &amp;komeda_dev_funcs.enum_resources() and destroyed by &amp;komeda_dev_funcs.cleanup()</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iommu_domain</span> *<span class="hljs-title">iommu</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">debugfs_root</span>;</span>  <span class="hljs-comment">//root directory of komeda debugfs</span><br>	u16 err_verbosity;<br>	<span class="hljs-comment">/* Print a single line per error per frame with error events. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_ERR_EVENTS BIT(0)</span><br>	<span class="hljs-comment">/* Print a single line per warning per frame with error events. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_WARN_EVENTS BIT(1)</span><br>	<span class="hljs-comment">/* Print a single line per info event per frame with error events. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_INFO_EVENTS BIT(2)</span><br>	<span class="hljs-comment">/* Dump DRM state on an error or warning event. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_DUMP_STATE_ON_EVENT BIT(8)</span><br>	<span class="hljs-comment">/* Disable rate limiting of event prints (normally one per commit) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KOMEDA_DEV_PRINT_DISABLE_RATELIMIT BIT(12)</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_fbdev</span> *<span class="hljs-title">fbdev</span>[2];</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_display_thread</span> <span class="hljs-title">display_thread</span>[<span class="hljs-title">KOMEDA_MAX_PIPELINES</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="1-6-格式处理"><a href="#1-6-格式处理" class="headerlink" title="1.6 格式处理"></a>1.6 格式处理</h1><h2 id="struct-komeda-fomat-caps"><a href="#struct-komeda-fomat-caps" class="headerlink" title="struct komeda_fomat_caps"></a>struct komeda_fomat_caps</h2><blockquote>
<p>komeda_format_caps is for describing ARM display specific features and limitations for a specific format, and format_caps will be linked into <strong>&amp;komeda_framebuffer</strong> like a extension of &amp;drm_format_info.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps</span> &#123;</span><br>	u32 hw_id;<br>	u32 fourcc;<br>	u32 supported_layer_types;  <span class="hljs-comment">//支持此格式的layer</span><br>	u32 supported_rots;         <span class="hljs-comment">//此格式允许的旋转方式</span><br>	u32 supported_afbc_layouts;  <br>	u64 supported_afbc_features;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="struct-komeda-format-caps-table"><a href="#struct-komeda-format-caps-table" class="headerlink" title="struct komeda_format_caps_table"></a>struct komeda_format_caps_table</h2><blockquote>
<p>用于管理komeda_format_caps</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps_table</span> &#123;</span><br>	u32 n_formats;       <span class="hljs-comment">//size of @format_caps</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps</span> *<span class="hljs-title">format_caps</span>;</span>    <span class="hljs-comment">//array of format_caps list</span><br>	<span class="hljs-type">bool</span> (*format_mod_supported)(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> komeda_format_caps *caps,<br>				     u32 layer_type, u64 modifier, u32 rot);  <span class="hljs-comment">//某些硬件可能不能抽象为format_caps 使用此函数对硬件提供支持</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="struct-Komeda-fb"><a href="#struct-Komeda-fb" class="headerlink" title="struct Komeda_fb"></a>struct Komeda_fb</h2><blockquote>
<p>根据komeda属性扩展drm_framebuffer</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_fb</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_framebuffer</span> <span class="hljs-title">base</span>;</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps</span> *<span class="hljs-title">format_caps</span>;</span>  <span class="hljs-comment">//根据komeda的format_caps扩展drm_format_info</span><br>	<span class="hljs-type">bool</span> is_va;   <span class="hljs-comment">//smmu status</span><br>	u32 aligned_w;  <span class="hljs-comment">//aligned frame buffer width</span><br>	u32 aligned_h;  <span class="hljs-comment">//aligned frame buffer height</span><br>	u32 afbc_size;  <span class="hljs-comment">//minimum size of afbc</span><br>	u32 offset_payload;  <span class="hljs-comment">//afbc payload 的起始位置</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="1-7-attach-komeda-dev-and-DRM-KMS"><a href="#1-7-attach-komeda-dev-and-DRM-KMS" class="headerlink" title="1.7 attach komeda_dev and DRM-KMS"></a>1.7 attach komeda_dev and DRM-KMS</h1><ul>
<li>komeda将所有的资源抽象为pipeline或者components，DRM-KMS使用的抽象资源为crtc&#x2F;plane&#x2F;connector。一个KMS obj不能由一个单独的component表示，比如设置gamma、mode等操作，在DRM中都由crtc来完成，但是在komeda中需要compiz、improc和timing_ctrlr共同完成。</li>
<li>因此，将第三章中的三种sub_pipeline分别抽象为plan&#x2F;wb_connector&#x2F;crtc<ul>
<li>Layer(input) pipeline ———– plane</li>
<li>Writeback(output) pipeline —— wb_connector</li>
<li>Display(output) pipeline ——– crtc<blockquote>
<p>将每个KMS obj都视为pipeline&#x2F;component的user（对应第4章中komeda_component_state的binding_user成员），每个pipeline&#x2F;component同一时刻只能被一个KMS obj使用，每个pipeline&#x2F;component都作为drm_private_obj，其状态都由drm_atomic_state管理。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="1-8-关于komeda-kms的抽象"><a href="#1-8-关于komeda-kms的抽象" class="headerlink" title="1.8 关于komeda_kms的抽象"></a>1.8 关于komeda_kms的抽象</h1><h2 id="struct-komeda-kms-dev"><a href="#struct-komeda-kms-dev" class="headerlink" title="struct komeda_kms_dev"></a>struct komeda_kms_dev</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_kms_dev</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_device</span> <span class="hljs-title">base</span>;</span><br>	<span class="hljs-type">int</span> n_crtcs;  <span class="hljs-comment">//有效的crtc数</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_crtc</span> <span class="hljs-title">crtcs</span>[<span class="hljs-title">KOMEDA_MAX_PIPELINES</span>];</span>  <span class="hljs-comment">//crtc list</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="struct-komeda-plane"><a href="#struct-komeda-plane" class="headerlink" title="struct komeda_plane"></a>struct komeda_plane</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_plane</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane</span> <span class="hljs-title">base</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_layer</span> *<span class="hljs-title">layer</span>;</span>  <span class="hljs-comment">//输入对应pipeline的有效layer</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="struct-komeda-plane-state"><a href="#struct-komeda-plane-state" class="headerlink" title="struct komeda_plane_state"></a>struct komeda_plane_state</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_plane_state</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_plane_state</span> <span class="hljs-title">base</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">zlist_node</span>;</span>  <span class="hljs-comment">//z向的层面顺序链表</span><br>	u8 layer_split : <span class="hljs-number">1</span>;  <span class="hljs-comment">//layer_split的开关</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="struct-komeda-wb-connector"><a href="#struct-komeda-wb-connector" class="headerlink" title="struct komeda_wb_connector"></a>struct komeda_wb_connector</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_wb_connector</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_writeback_connector</span> <span class="hljs-title">base</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_layer</span> *<span class="hljs-title">wb_layer</span>;</span>  <span class="hljs-comment">//represents associated writeback pipeline of komeda</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="struct-komeda-crtc"><a href="#struct-komeda-crtc" class="headerlink" title="struct komeda_crtc"></a>struct komeda_crtc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_crtc</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc</span> <span class="hljs-title">base</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">master</span>;</span>  <span class="hljs-comment">//only master has display output (对应的单显/双显模式中的display output pipeline)</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">slave</span>;</span>  <span class="hljs-comment">//optional,Doesn&#x27;t have its own display output, the handled data flow will merge into the master.</span><br>	<span class="hljs-type">bool</span> side_by_side;<br>	u32 sbs_overlap;<br>	u32 slave_planes;  <span class="hljs-comment">//komeda slave planes mask</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_wb_connector</span> *<span class="hljs-title">wb_conn</span>;</span>  <span class="hljs-comment">//komeda write back connector</span><br><br>	<span class="hljs-comment">/* this flip_done is for trace the disable */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> *<span class="hljs-title">disable_done</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">slave_planes_property</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">clock_ratio_property</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">side_by_side_property</span>;</span><br>	<span class="hljs-comment">/* assertive display properties */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">assertiveness_property</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">strength_limit_property</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">drc_property</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">hdr_data_property</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">coproc_property</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">vrr_property</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_property</span> *<span class="hljs-title">vrr_enable_property</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_commit</span> *<span class="hljs-title">commit</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="struct-komeda-crtc-state"><a href="#struct-komeda-crtc-state" class="headerlink" title="struct komeda_crtc_state"></a>struct komeda_crtc_state</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_crtc_state</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_crtc_state</span> <span class="hljs-title">base</span>;</span><br>	u32 affected_pipes;  <span class="hljs-comment">//the affected pipelines in once display instance</span><br>	u32 active_pipes;  <span class="hljs-comment">//the active pipelines in once display instance</span><br>	u64 clock_ratio;  <span class="hljs-comment">//ratio of (aclk &lt;&lt; 32)/pxlclk</span><br>	u32 max_slave_zorder;  <span class="hljs-comment">//the maximum of slave zorder</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="komeda-crtc-atomic-check"><a href="#komeda-crtc-atomic-check" class="headerlink" title="komeda_crtc_atomic_check"></a>komeda_crtc_atomic_check</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">komeda_crtc_atomic_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_crtc *crtc, <span class="hljs-keyword">struct</span> drm_atomic_state *state)</span><br><span class="hljs-comment">/***</span><br><span class="hljs-comment">@crtc: drm crtc</span><br><span class="hljs-comment">@state: crtc state obj</span><br><span class="hljs-comment">@description: crtc_atomic_check is the final check stage, so beside build a display data pipeline according to the crtc_state, but still needs to release or disable the unclaimed pipeline resources.</span><br><span class="hljs-comment">***/</span><br></code></pre></td></tr></table></figure>
<h2 id="komeda-plane-atomic-check"><a href="#komeda-plane-atomic-check" class="headerlink" title="komeda_plane_atomic_check"></a>komeda_plane_atomic_check</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">komeda_plane_atomic_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> drm_plane *plane, <span class="hljs-keyword">struct</span> drm_atomic_state *state)</span><br><span class="hljs-comment">/***</span><br><span class="hljs-comment">@plane: drm plane</span><br><span class="hljs-comment">@state: plane state obj</span><br><span class="hljs-comment">***/</span><br></code></pre></td></tr></table></figure>

<h1 id="2-komeda-drv-based-on-component-framework"><a href="#2-komeda-drv-based-on-component-framework" class="headerlink" title="2 komeda_drv based on component framework"></a>2 komeda_drv based on component framework</h1><ul>
<li>通过component framework对整个display subsystem进行管理，d71作为master device对其余的component device（比如dsi、dp）进行管控。本章主要对d71作为master device在component framework中的注册流程进行梳理和分析。</li>
</ul>
<h2 id="2-1-component-framework-简介"><a href="#2-1-component-framework-简介" class="headerlink" title="2.1 component framework 简介"></a>2.1 component framework 简介</h2><blockquote>
<p>主要作用：用来处理内核模块加载&#x2F;卸载顺序，保证最后加载的模块在需要先加载的模块都加载后加载。<br>component framework包含两种设备：master和component。master是超级设备，通过设备树管控多个component加载&#x2F;卸载顺序，保证所有组件正常加载&#x2F;卸载。<br>component framework通过两个链表来维持整个框架中所有的master&#x2F;component device</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">LIST_HEAD</span><span class="hljs-params">(component_list)</span>;   <span class="hljs-comment">//整个component框架中所有的components 可能不属于同一个master device</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">LIST_HEAD</span><span class="hljs-params">(masters)</span>;          <span class="hljs-comment">//所有的master device，每个master device通过一个链表维护下属的components</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>master device</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">master</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span>    <span class="hljs-comment">//下属的components </span><br><span class="hljs-type">bool</span> bound;               <span class="hljs-comment">//绑定状态</span><br><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_master_ops</span> *<span class="hljs-title">ops</span>;</span> <span class="hljs-comment">//回调函数 .attach .bind .unbind</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_match</span> *<span class="hljs-title">match</span>;</span>  <span class="hljs-comment">//master device 通过这个结构体匹配正确的components</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">dentry</span>;</span><br> &#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>component match<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_match</span> &#123;</span><br><span class="hljs-type">size_t</span> alloc;           <span class="hljs-comment">//分配的内存</span><br><span class="hljs-type">size_t</span> num;             <span class="hljs-comment">//实际compare的数量  alloc与num在master未注册之前是不等的 分配的内存会比实际占用内存更大 在master注册时 会根据compare的实际数量重新分配内存</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_match_array</span> *<span class="hljs-title">compare</span>;</span>  <span class="hljs-comment">//匹配表 包含匹配数据和匹配方法 每一个compare表示一个component_device</span><br> &#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>component_match_array<blockquote>
<p>一般需要传入的就是.data和.compare，将master下属的component device作为data保存至此表，匹配时调用compare将待匹配的设备与此表中的data进行比较，相同即匹配成功。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_match_array</span> &#123;</span><br>  <span class="hljs-type">void</span> *data;<br>  <span class="hljs-type">int</span> (*compare)(<span class="hljs-keyword">struct</span> device *, <span class="hljs-type">void</span> *);<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>component device</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span>  <span class="hljs-comment">//所属链表头</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">master</span> *<span class="hljs-title">master</span>;</span>  <span class="hljs-comment">//所属的master</span><br>    <span class="hljs-type">bool</span> bound;             <span class="hljs-comment">//绑定状态</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">component_ops</span> *<span class="hljs-title">ops</span>;</span>  <span class="hljs-comment">//回调函数 .bind .unbind</span><br>    <span class="hljs-type">int</span> subcomponent;       <span class="hljs-comment">//子设备数 一般为0</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>绑定流程</p>
<blockquote>
<p>在向componnet framework中注册master device 或者 component device时，都会执行<code>try_to_bring_up_master</code>函数，在此函数中会按照master的匹配表的顺序对各个component进行匹配，只有所有的component都已经注册进component framework，此函数才能执行成功。所有components匹配成功后，将执行<code>master-&gt;ops-&gt;bind</code>，在bind函数中执行<code>component_bind_all()</code>，在此函数中将回调所有component的.bind函数。</p>
</blockquote>
</li>
</ul>
<h2 id="2-2-设备树节点"><a href="#2-2-设备树节点" class="headerlink" title="2.2 设备树节点"></a>2.2 设备树节点</h2><ul>
<li>komeda d71作为display_subsystem的master device，其设备树节点如下：  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">mdp_ss_dpu0:</span> <span class="hljs-title class_">dpu@e6c80000</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;arm,mali-d71&quot;</span>, <span class="hljs-string">&quot;syscon&quot;</span><span class="hljs-punctuation">;</span><br>        ...<br><span class="hljs-symbol">        dp0_pipe0:</span> <span class="hljs-title class_">pipeline@0</span> <span class="hljs-punctuation">&#123;</span><br>            ...<br>            <span class="hljs-title class_">ports</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>                <span class="hljs-meta">#size-cells = &lt;0&gt;;</span><br>                <span class="hljs-title class_">port@0</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">                    dp0_pipe0_out:</span> <span class="hljs-title class_">endpoint</span> <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">remote-endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;dsi_in</span>&gt;</span><span class="hljs-punctuation">;</span><br>                    <span class="hljs-punctuation">&#125;;</span><br>                <span class="hljs-punctuation">&#125;;</span><br>            <span class="hljs-punctuation">&#125;;</span><br>        <span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li>
<li>驱动源码文件为<code>komeda_drv.c</code></li>
</ul>
<h2 id="2-3-probe函数"><a href="#2-3-probe函数" class="headerlink" title="2.3 probe函数"></a>2.3 probe函数</h2><ul>
<li>其<code>probe</code>函数主要作用为将其作为master设备注册进component框架，主要分为以下三步：<ol>
<li><p>通过设备树获取属于master的component设备节点，并将其保存至所属的component链表中。</p>
<ul>
<li>通过设备树中的<code>remote-endpoint</code>节点找到其下属的component device:<ul>
<li>首先获取endpoint节点：<code>of_graph_get_endpoint_by_regs(node, port, endpoint)</code></li>
<li>找到endpoint下属的remote节点，并通过remote节点找到component设备<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">   np = of_graph_get_remote_endpoint(node);  <br>pp = of_graph_get_port_parent(np);  <span class="hljs-comment">//此np即为remote节点</span><br><span class="hljs-keyword">return</span> pp;<br></code></pre></td></tr></table></figure></li>
<li>关于pp节点的获取，存在一点疑问：<ul>
<li><code>of_graph_get_port_parent</code>源码为：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-keyword">for</span> (depth = <span class="hljs-number">3</span>; depth &amp;&amp; node; depth--) &#123;  <span class="hljs-comment">//求三级父节点</span><br>       node = of_get_next_parent(node);<br>       <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">2</span> &amp;&amp; !of_node_name_eq(node, <span class="hljs-string">&quot;ports&quot;</span>))  <span class="hljs-comment">//结合设备树来看，实际上获得的是ports节点</span><br>           <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> node;<br></code></pre></td></tr></table></figure></li>
<li><code>remote</code>设备树节点为：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">mdp_ss_dsi:</span> <span class="hljs-title class_">dsi@e6d90000</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;siengine,se1000-mipi-dsi&quot;</span><span class="hljs-punctuation">;</span><br>    ...<br>    <span class="hljs-title class_">ports</span> <span class="hljs-punctuation">&#123;</span><br>        ...<br>        <span class="hljs-title class_">port@0</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">            dsi_in:</span> <span class="hljs-title class_">endpoint</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">remote-endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;dp0_pipe0_out</span>&gt;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-punctuation">&#125;;</span><br>        <span class="hljs-punctuation">&#125;;</span><br>        ...<br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li>
<li><strong>以源码来看，它最终获取的节点是<code>remote</code>节点的二级<code>parent</code>节点–<code>ports</code>节点，但是根据component framework的逻辑来看，最终获取的节点应该是<code>dsi</code>节点。</strong><mark><strong>此处存疑</strong></mark></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>将设备树中找到的component节点保存至<mark>master-&gt;match-&gt;compare[match-&gt;num]-&gt;data</mark>，具体流程为以下四层调用：</p>
<blockquote>
<p>|- drm_of_component_match_add(master, match, compare_of, remote);</p>
</blockquote>
<blockquote>
<p>|— component_match_add_release(master, matchptr, drm_release_of, compare, node);</p>
</blockquote>
<blockquote>
<p>|—– __component_match_add(master, matchptr, release, compare, NULL, compare_data);</p>
</blockquote>
<blockquote>
<p>|——-最终调用：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">     <span class="hljs-comment">/*为新的compare分配内存，一旦之前为match分配的内存使用完 就再为其分配16个sizeof(compare)的内存空间*/</span><br>     	<span class="hljs-keyword">if</span> (match-&gt;num == match-&gt;alloc) &#123;<br><span class="hljs-type">size_t</span> new_size = match-&gt;alloc + <span class="hljs-number">16</span>;<br>ret = component_match_realloc(master, match, new_size);<br>...<br>   &#125;<br>     <span class="hljs-comment">/*对新的compare赋值*/</span><br>     	match-&gt;compare[match-&gt;num].compare = compare;  <span class="hljs-comment">//匹配函数 非常简单 判断节点是否相等即可</span><br>      ...<br>      match-&gt;compare[match-&gt;num].data = compare_data; <span class="hljs-comment">//匹配数据 被匹配函数调用 compare_data为形参，实际上最终传入的是(void *) (struct device_node *remote)，即component node</span><br>      ...<br>      match-&gt;num++;<br></code></pre></td></tr></table></figure></p>
</blockquote>
</li>
<li><p>注册带match表的master_device</p>
<ul>
<li>component_master_add_with_match(dev, &amp;komeda_master_ops, match);<blockquote>
<p>此函数将master设备注册至component framework的masters链表中，并执行<code>try_to_bring_up_master</code>函数。</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">   ...<br>   master-&gt;dev = dev;<br>master-&gt;ops = ops;  <span class="hljs-comment">//master device 回调函数  .bind/.unbind</span><br>master-&gt;match = match;<br>   list_add(&amp;master-&gt;node, &amp;masters);  <span class="hljs-comment">//将master添加至component framework维护的masters表</span><br>   ...<br>   ret = try_to_bring_up_master(master, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//尝试进行匹配和绑定</span><br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="3-d71-资源初始化及attach-kms"><a href="#3-d71-资源初始化及attach-kms" class="headerlink" title="3 d71 资源初始化及attach kms"></a>3 d71 资源初始化及attach kms</h2><ul>
<li>本章主要讨论的是master-&gt;ops-&gt;bind()函数，其主要功能是完成对d71资源的获取和初始化，并将各个sub_pipeline与对应的kms obj进行attach</li>
<li>bind函数围绕着以下数据结构展开，其中两个成员分别在1.5节和1.8节中展开描述过。例化了一个komeda_drv::<mark>mdrv</mark><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_drv</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev</span> *<span class="hljs-title">mdev</span>;</span>     <span class="hljs-comment">//d71设备资源抽象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_kms_dev</span> *<span class="hljs-title">kms</span>;</span> <br> &#125;;<br></code></pre></td></tr></table></figure></li>
<li>整个bind函数主要由两个动作构成：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_drv</span> *<span class="hljs-title">mdrv</span>;</span><br>...<br>mdrv-&gt;mdev = komeda_dev_create(dev);  <span class="hljs-comment">//获取资源并初始化</span><br>...<br>mdrv-&gt;kms = komeda_kms_attach(mdrv-&gt;mdev);  <span class="hljs-comment">//attach mdrv-&gt;mdev and mdrv-&gt;kms</span><br>...<br></code></pre></td></tr></table></figure></li>
<li>下面分别对上述两个函数进行讨论</li>
</ul>
<h2 id="3-1-komeda-dev-create-dev"><a href="#3-1-komeda-dev-create-dev" class="headerlink" title="3.1 komeda_dev_create(dev)"></a>3.1 komeda_dev_create(dev)</h2><ol>
<li>在1.5节中提到过一个结构体<code>struct komeda_dev_funcs</code>,此函数集用于core获取chip级的资源，并访问硬件。对应的是<code>komeda_dev.funcs</code>成员。komeda驱动中定义了此函数集，并通过of_match_table的.data成员将此函数集赋值给mdrv-&gt;mdev.funcs。<ul>
<li><code>&#123; .compatible = &quot;arm,mali-d71&quot;, .data = d71_identify, &#125;,</code> ，其中d71_identify为一个函数指针，指向的函数内包含了funcs的赋值操作。在bind()中，此函数的调用方法为： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">komeda_identify_func komeda_identify;<br>...<br>komeda_identify = of_device_get_match_data(dev);  <span class="hljs-comment">//获取identify函数</span><br>...<br>mdev-&gt;reg_base = devm_platform_ioremap_resource(pdev, <span class="hljs-number">0</span>);<br>...<br>mdev-&gt;funcs = komeda_identify(mdev-&gt;reg_base, &amp;mdev-&gt;chip);<br>...<br></code></pre></td></tr></table></figure></li>
<li>d71_identify<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> komeda_dev_funcs *<span class="hljs-title function_">d71_identify</span><span class="hljs-params">(u32 __iomem *reg_base, <span class="hljs-keyword">struct</span> komeda_chip_info *chip)</span><br>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev_funcs</span> *<span class="hljs-title">funcs</span>;</span><br>	u32 product_id;<br>	chip-&gt;core_id = malidp_read32(reg_base, GLB_CORE_ID);<br>	product_id = MALIDP_CORE_ID_PRODUCT_ID(chip-&gt;core_id);<br>	<span class="hljs-keyword">switch</span> (product_id) &#123;<br>		<span class="hljs-keyword">case</span> MALIDP_D71_PRODUCT_ID:<br>		...<br>			funcs = &amp;d71_chip_funcs;<br>			<span class="hljs-keyword">break</span>;<br>		...<br>	&#125;<br>	chip-&gt;arch_id	= malidp_read32(reg_base, GLB_ARCH_ID);<br>	chip-&gt;core_info	= malidp_read32(reg_base, GLB_CORE_INFO);<br>	chip-&gt;bus_width	= D71_BUS_WIDTH_16_BYTES;<br>	<span class="hljs-keyword">return</span> funcs;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>由上述源码可知，d71_identify返回了chip的访问函数集<mark>d71_chip_funcs</mark>的同时，还通过读寄存器的操作对<strong>mdrv-&gt;mdev-&gt;chip</strong>的各个数据进行了初始化。</li>
</ul>
</li>
<li>通过<strong>funcs-&gt;init_format_table</strong>初始化<strong>mdev-&gt;fmt_tbl</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mdev-&gt;funcs-&gt;init_format_table(mdev);  <span class="hljs-comment">//实际上调用的d71_init_fmt_tbl</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这一点在1.5节中介绍komeda_dev结构体时已经说明过，此函数内部基本上就是单纯的数据结构的赋值 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">d71_init_fmt_tbl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> komeda_dev *mdev)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_format_caps_table</span> *<span class="hljs-title">table</span> =</span> &amp;mdev-&gt;fmt_tbl;<br><br>	table-&gt;format_caps = d71_format_caps_table;<br>	table-&gt;format_mod_supported = d71_format_mod_supported;<br>	table-&gt;n_formats = ARRAY_SIZE(d71_format_caps_table);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过<strong>funcs-&gt;enum_resources</strong>获取d71资源列表<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">err = mdev-&gt;funcs-&gt;enum_resources(mdev);  <span class="hljs-comment">//实际上调用d71_enum_resources</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>此函数功能是对mdev-&gt;chipdata(类型为void *)成员进行初始化</p>
<ul>
<li>定义了一个d71_dev类型对chip资源进行描述，通过大量的寄存器操作对以下成员进行初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d71_dev</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_dev</span> *<span class="hljs-title">mdev</span>;</span><br>	<span class="hljs-type">int</span>	num_blocks;<br>	<span class="hljs-type">int</span>	num_pipelines;<br>	<span class="hljs-type">int</span>	num_rich_layers;<br>	u32	max_line_size;<br>	u32	max_vsize;<br>	u32	supports_dual_link : <span class="hljs-number">1</span>;<br>	u32	integrates_tbu : <span class="hljs-number">1</span>;<br>	u32 __iomem	*gcu_addr;    <span class="hljs-comment">//mdev-&gt;reg_base</span><br>	u32 __iomem	*glb_scl_coeff_addr[D71_MAX_GLB_SCL_COEFF];<br>	u32 __iomem	*periph_addr;  <span class="hljs-comment">//mdev-&gt;reg_base + (D71_BLOCK_OFFSET_PERIPH &gt;&gt; 2);</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d71_pipeline</span> *<span class="hljs-title">pipes</span>[<span class="hljs-title">D71_MAX_PIPELINE</span>];</span><br>&#125;;<br>...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d71_dev</span> *<span class="hljs-title">d71</span>;</span><br>...<br>mdev-&gt;chip_data = d71;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>需要关注的是此函数中对pipeline的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; d71-&gt;num_pipelines; i++) &#123;<br>pipe = komeda_pipeline_add(mdev, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> d71_pipeline),<br>			   &amp;d71_pipeline_funcs);<br>...<br>d71-&gt;pipes[i] = to_d71_pipeline(pipe);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>komeda_pipeline_add()功能是根据d71-&gt;num_pipelines对mdev-&gt;pipelines[]进行初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">pipe</span>;</span><br>...<br>pipe-&gt;mdev = mdev;<br>pipe-&gt;id   = mdev-&gt;n_pipelines;<br>pipe-&gt;funcs = funcs;  <span class="hljs-comment">//pipe的操作函数集</span><br>mdev-&gt;pipelines[mdev-&gt;n_pipelines] = pipe;<br>...<br></code></pre></td></tr></table></figure></li>
<li>to_d71_pipeline()是一个container宏，实际上是已komeda_pipeline为base，扩展称为一个d71_pipeline类型，返回指针并存入d71-&gt;pipes[]表中。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> to_d71_pipeline(x)	container_of(x, struct d71_pipeline, base)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>通过<code>komeda_assemble_pipelines(mdev)</code>对pipe下的component进行获取，并验证pipeline各个component之间的连接<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">  	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mdev-&gt;n_pipelines; i++) &#123;<br>	pipe = mdev-&gt;pipelines[i];<br>	komeda_pipeline_assemble(pipe);<br>	komeda_pipeline_dump(pipe);    <span class="hljs-comment">//这函数好像没啥用 最后就输出一堆log</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>komeda_pipeline_assemble(pipe)</code>工作主要由此函数完成<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> avail_comps = pipe-&gt;avail_comps;<br>for_each_set_bit(id, &amp;avail_comps, <span class="hljs-number">32</span>) &#123;<br>c = komeda_pipeline_get_component(pipe, id);<br>komeda_component_verify_inputs(c);<br>&#125;<br>...<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>komeda_pipeline_get_component</strong>主要通过位操作获取当前pipe下属的component，并将其component指针返回，其调用了<code>komeda_pipeline_get_component_pos(pipe, id)</code>以compositor为例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_component</span> **<span class="hljs-title">pos</span> =</span> <span class="hljs-literal">NULL</span>;<br>  ...<br>  <span class="hljs-keyword">switch</span> (id) &#123;<br>...<br><span class="hljs-keyword">case</span> KOMEDA_COMPONENT_COMPIZ0:<br><span class="hljs-keyword">case</span> KOMEDA_COMPONENT_COMPIZ1:<br>	temp = mdev-&gt;pipelines[id - KOMEDA_COMPONENT_COMPIZ0];<br>	pos = to_cpos(temp-&gt;compiz);  <span class="hljs-comment">//to_cops是一个宏 将&amp;(temp-&gt;compiz)转换为一个struct component **指针</span><br>	<span class="hljs-keyword">break</span>;<br>...<br>  &#125;<br>  ...<br>  <span class="hljs-keyword">return</span> pos;<br></code></pre></td></tr></table></figure>
<ul>
<li>komeda_pipeline_get_component在上述源码外由封装了一层 返回的是*pos，因此c是一个struct component *类型</li>
</ul>
</li>
<li><strong>komeda_component_verify_inputs</strong>同样通过位操作找到当前component的input方法，即在pipeline中找到可以作为它上一个stage的component_2，并将component_2的supported_outputs通过位操作与当前component的id进行关联，使pipeline连通<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"> ...<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> supported_inputs = c-&gt;supported_inputs;<br> ...<br> for_each_set_bit(id, &amp;supported_inputs, <span class="hljs-number">32</span>) &#123;<br>input = komeda_pipeline_get_component(pipe, id);<br>...<br>input-&gt;supported_outputs |= BIT(c-&gt;id);<br> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="3-2-komeda-kms-attach-mdrv-gt-mdev"><a href="#3-2-komeda-kms-attach-mdrv-gt-mdev" class="headerlink" title="3.2 komeda_kms_attach(mdrv-&gt;mdev)"></a>3.2 komeda_kms_attach(mdrv-&gt;mdev)</h2><ul>
<li>此函数主要完成drm kms中的一系列操作，围绕两个例化对象展开：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_kms_dev</span> *<span class="hljs-title">kms</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_device</span> *<span class="hljs-title">drm</span>;</span><br>drm = &amp;kms-&gt;base;<br>drm-&gt;dev_private = mdev;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>结合drm_driver 创建drm container device — kms<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">kms = devm_drm_dev_alloc(mdev-&gt;dev, &amp;komeda_kms_driver,<br>	 <span class="hljs-keyword">struct</span> komeda_kms_dev, base);<br></code></pre></td></tr></table></figure>
<ul>
<li>关于<code>komeda_kms_driver</code>的定义<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">	 <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_driver</span> <span class="hljs-title">komeda_kms_driver</span> =</span> &#123;<br>		.driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,<br>		.lastclose			= komeda_lastclose,<br>		DRM_GEM_CMA_DRIVER_OPS_WITH_DUMB_CREATE(komeda_gem_cma_dumb_create),<br>		.fops = &amp;komeda_cma_fops,<br>		.name = <span class="hljs-string">&quot;komeda&quot;</span>,<br>		.desc = <span class="hljs-string">&quot;Arm Komeda Display Processor driver&quot;</span>,<br>		.date = <span class="hljs-string">&quot;20181101&quot;</span>,<br>		.major = <span class="hljs-number">0</span>,<br>		.minor = <span class="hljs-number">1</span>,<br>		.gem_free_object_unlocked       = drm_gem_cma_free_object,<br>		.gem_vm_ops                     = &amp;drm_gem_cma_vm_ops,<br>		.dumb_create                    = komeda_gem_cma_dumb_create,<br>		.prime_handle_to_fd             = drm_gem_prime_handle_to_fd,<br>		.prime_fd_to_handle             = drm_gem_prime_fd_to_handle,<br>		.gem_prime_export               = drm_gem_prime_export,<br>		.gem_prime_import               = drm_gem_prime_import,<br>		.gem_prime_get_sg_table         = drm_gem_cma_prime_get_sg_table,<br>		.gem_prime_import_sg_table      = drm_gem_cma_prime_import_sg_table,<br>		.gem_prime_vmap                 = drm_gem_cma_prime_vmap,<br>		.gem_prime_vunmap               = drm_gem_cma_prime_vunmap,<br>		.gem_prime_mmap                 = drm_gem_cma_prime_mmap,<br>     &#125;;<br>	 ```  <br><span class="hljs-number">2.</span> mode_config_init drm框架中最重要的操作之一<br>   ```c<br>   <span class="hljs-title function_">komeda_kms_mode_config_init</span><span class="hljs-params">(kms, mdev)</span>;<br></code></pre></td></tr></table></figure></li>
<li>在此函数内对mode_config进行初始化，并创建standard property objs<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drm_mode_config</span> *<span class="hljs-title">config</span> =</span> &amp;kms-&gt;base.mode_config;<br>drm_mode_config_init(&amp;kms-&gt;base);  <br>komeda_kms_setup_crtcs(kms, mdev);<br><span class="hljs-comment">/* Get value from dev */</span><br>config-&gt;min_width	= <span class="hljs-number">0</span>;<br>config-&gt;min_height	= <span class="hljs-number">0</span>;<br>config-&gt;max_width	= <span class="hljs-number">4096</span>;<br>config-&gt;max_height	= <span class="hljs-number">4096</span>;<br>config-&gt;allow_fb_modifiers = <span class="hljs-literal">true</span>;<br>config-&gt;funcs = &amp;komeda_mode_config_funcs;<br>config-&gt;helper_private = &amp;komeda_mode_config_helpers;<br></code></pre></td></tr></table></figure></li>
<li>重点关注 <strong>komeda_kms_setup_crtcs(kms, mdev)<strong>函数，此函数主要是根据mdrv-&gt;mdev中的pipeline填充mdrv-&gt;kms-&gt;crtc[]表。其中的</strong>slave</strong>只有在<strong>单显模式</strong>下才存在，之前在1.2节中已经有描述，相关数据结构前文也已说明。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_crtc</span> *<span class="hljs-title">crtc</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline</span> *<span class="hljs-title">master</span>;</span><br>kms-&gt;n_crtcs = <span class="hljs-number">0</span>;<br>   ...<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mdev-&gt;n_pipelines; i++) &#123;<br> crtc = &amp;kms-&gt;crtcs[kms-&gt;n_crtcs];<br> master = mdev-&gt;pipelines[i];<br> ...<br> crtc-&gt;master = master;<br> crtc-&gt;slave  = komeda_pipeline_get_slave(master);<br> ...<br> kms-&gt;n_crtcs++;<br>&#125;<br>...<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>将各个pipeline&#x2F;component设为drm_private_obj<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">komeda_kms_add_private_objs(kms, mdev);<br></code></pre></td></tr></table></figure>
<ul>
<li>封装以下函数：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*****</span><br><span class="hljs-comment">xxx为d71组件，包括：</span><br><span class="hljs-comment">- pipeline</span><br><span class="hljs-comment">- layer</span><br><span class="hljs-comment">- wb_layer</span><br><span class="hljs-comment">- scaler</span><br><span class="hljs-comment">- compositor</span><br><span class="hljs-comment">- splitter</span><br><span class="hljs-comment">- merger</span><br><span class="hljs-comment">- improc</span><br><span class="hljs-comment">- timing_ctrlr</span><br><span class="hljs-comment">*****/</span><br>komeda_xxx_obj_add(kms, xxx);<br></code></pre></td></tr></table></figure>
<ul>
<li>各个函数最终调用：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">komeda_pipeline_state</span> *<span class="hljs-title">st</span>;</span><br>...<br>drm_atomic_private_obj_init(&amp;kms-&gt;base, &amp;xxx-&gt;obj, &amp;st-&gt;obj, &amp;komeda_xxx_obj_funcs);<br></code></pre></td></tr></table></figure>
<ul>
<li>funcs的类型为：<code>struct drm_private_state_funcs</code>，状态操作函数，包括<code>.xxx_atomic_duplicate_state</code>和<code>.xxx_atomic_destroy_state</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>向KMS中添加KMS obj，创建各个obj的属性<ul>
<li><code>komeda_kms_add_planes(kms, mdev);</code><ul>
<li><code>komeda_plane_add</code><ul>
<li><code>drm_universal_plane_init(&amp;kms-&gt;base, plane,    get_possible_crtcs(kms, c-&gt;pipeline),    &amp;komeda_plane_funcs,    formats, n_formats, komeda_supported_modifiers,    get_plane_type(kms, c),    &quot;%s&quot;, c-&gt;name);</code>  &#x2F;&#x2F;plane初始化 xxx_plane_funcs注册</li>
<li><code>drm_plane_helper_add(plane, &amp;komeda_plane_helper_funcs);</code>  &#x2F;&#x2F;xxx_plane_helper_funcs注册</li>
<li><code>drm_plane_create_rotation_property(plane, DRM_MODE_ROTATE_0, layer-&gt;supported_rots);</code> &#x2F;&#x2F;创建属性并与obj attach</li>
</ul>
</li>
</ul>
</li>
<li><code>komeda_kms_add_crtcs(kms, mdev)</code><ul>
<li><code>komeda_crtc_add</code><ul>
<li><code>drm_crtc_init_with_planes(&amp;kms-&gt;base, crtc,        get_crtc_primary(kms, kcrtc), NULL,        &amp;komeda_crtc_funcs, NULL);</code>  &#x2F;&#x2F;crtc初始化 xxx_crtc_funcs注册</li>
<li><code>drm_crtc_helper_add(crtc, &amp;komeda_crtc_helper_funcs);</code>  &#x2F;&#x2F;xxx_crtc_helper_funcs注册</li>
<li><code>crtc-&gt;port = kcrtc-&gt;master-&gt;of_output_port;</code> &#x2F;&#x2F;crtc output port nede</li>
<li><code>komeda_crtc_create_slave_planes_property(kcrtc);</code>  &#x2F;&#x2F;创建属性并attach</li>
</ul>
</li>
</ul>
</li>
<li><code>komeda_kms_add_wb_connectors(kms, mdev);</code> <ul>
<li><code>komeda_wb_connector_add</code></li>
<li><code>drm_writeback_connector_init(&amp;kms-&gt;base, wb_conn,             &amp;komeda_wb_connector_funcs,             &amp;komeda_wb_encoder_helper_funcs,             formats, n_formats);</code>  &#x2F;&#x2F;创建并初始化wb_connector，同时创建一个内部encoder与之关联</li>
<li>drm_connector_helper_add(&amp;wb_conn-&gt;base, &amp;komeda_wb_conn_helper_funcs);</li>
</ul>
</li>
</ul>
</li>
<li>根据crtc初始化vblank<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_crtcs; i++) &#123;<br>...<br>init_waitqueue_head(&amp;vblank-&gt;<span class="hljs-built_in">queue</span>);<br>...<br>timer_setup(&amp;vblank-&gt;disable_timer, vblank_disable_fn, <span class="hljs-number">0</span>);<br>...<br>drmm_add_action_or_reset(dev, drm_vblank_init_release, vblank);<br>...<br>drm_vblank_worker_init(vblank);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>component_bind_all(mdev-&gt;dev, kms);</code> &#x2F;&#x2F;完成component framework的绑定 与drm无关</li>
<li>drm_mode_config_reset(drm);</li>
<li>中断申请<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">devm_request_irq(drm-&gt;dev, mdev-&gt;irq,<br>       komeda_kms_irq_handler, IRQF_SHARED,<br>       drm-&gt;driver-&gt;name, drm);  <span class="hljs-comment">//注册中断处理函数</span><br></code></pre></td></tr></table></figure>
<ul>
<li>对<code>komeda_kms_irq_handler</code>进行分析<ul>
<li>其中定义了<code>struct komeda_events evts;</code>用于表示d71的中断事件</li>
<li>调用<code>mdev-&gt;funcs-&gt;irq_handler(mdev, &amp;evts);</code>通过读取寄存器中相关中断标志位生成对应的中断事件<ul>
<li>实际调用<code>d71_irq_handler</code>，此函数是函数集<code>d71_chip_funcs</code>中的一员，在3.1节中有提到过</li>
<li>相关操作如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">gcu_status = malidp_read32(d71-&gt;gcu_addr, GLB_IRQ_STATUS);<br><br><span class="hljs-keyword">if</span> (gcu_status &amp; GLB_IRQ_STATUS_GCU) &#123;<br> raw_status = malidp_read32(d71-&gt;gcu_addr, BLK_IRQ_RAW_STATUS);<br> <span class="hljs-keyword">if</span> (raw_status &amp; GCU_IRQ_CVAL0)<br>	evts-&gt;pipes[<span class="hljs-number">0</span>] |= KOMEDA_EVENT_FLIP;<br> <span class="hljs-keyword">if</span> (raw_status &amp; GCU_IRQ_CVAL1)<br>	evts-&gt;pipes[<span class="hljs-number">1</span>] |= KOMEDA_EVENT_FLIP;<br> <span class="hljs-keyword">if</span> (raw_status &amp; GCU_IRQ_ERR) &#123;<br>	status = malidp_read32(d71-&gt;gcu_addr, BLK_STATUS);<br>	<span class="hljs-keyword">if</span> (status &amp; GCU_STATUS_MERR) &#123;<br>		evts-&gt;global |= KOMEDA_ERR_MERR;<br>		malidp_write32_mask(d71-&gt;gcu_addr, BLK_STATUS,<br>					GCU_STATUS_MERR, <span class="hljs-number">0</span>);<br>	&#125;<br>&#125;<br>malidp_write32(d71-&gt;gcu_addr, BLK_IRQ_CLEAR, raw_status);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>将上一级的中断事件传递给真正的处理函数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">komeda_crtc_handle_event(&amp;kms-&gt;crtcs[i], &amp;evts);  <span class="hljs-comment">//由crtc根据不同的中断事件进行不同的显示处理</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><code>drm_dev_register(drm, 0);</code>   &#x2F;&#x2F;注册drm device</li>
</ol>
<blockquote>
<p>kms attach中的内容是很标准的drm-kms驱动框架，与<a target="_blank" rel="noopener" href="https://withector.github.io/2022/10/21/DRM%E7%BB%BC%E5%90%88/#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84KMS%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-atomic">withector.github.io–DRM应用及驱动浅析</a>中<code>最简单的kms驱动</code>流程基本一致，但是其中涉及的硬件操作，引入的wb_connector的obj，以及各个硬件与KMS obj的映射都要复杂很多。</p>
</blockquote>
  <!--PC版-->
<div id="SOHUCS" ></div>
<script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script>
<script type="text/javascript">
window.changyan.api.config({
appid: 'cywhVLBNm',
conf: 'prod_449188a899f144a2be2e05b0a1b8f390'
});
</script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  
    <span>></span>
    
  <a href="/categories/Linux/Drivers/" class="category-chain-item">Drivers</a>
  
  
    <span>></span>
    
  <a href="/categories/Linux/Drivers/DRM/" class="category-chain-item">DRM</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>d71 komeda driver</div>
      <div>http://example.com/2023/04/25/d71 komeda_driver/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Hector</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/09/%E6%97%B6%E9%92%9F%E5%AD%90%E7%B3%BB%E7%BB%9F/" title="时钟子系统">
                        <span class="hidden-mobile">时钟子系统</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'http://example.com/2023/04/25/d71%20komeda_driver/';
          this.page.identifier = '/2023/04/25/d71%20komeda_driver/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       Hector > 保持好奇-保持热爱 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
